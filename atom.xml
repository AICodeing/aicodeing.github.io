<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AICoding Technical Blog</title>
  
  <subtitle>AICoding team</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aicodeing.github.io/"/>
  <updated>2019-05-31T06:37:49.378Z</updated>
  <id>http://aicodeing.github.io/</id>
  
  <author>
    <name>AICoding Team</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android-ContentProvider的装载流程</title>
    <link href="http://aicodeing.github.io/Android-ContentProvider%E7%9A%84%E8%A3%85%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
    <id>http://aicodeing.github.io/Android-ContentProvider的装置流程/</id>
    <published>2019-05-29T11:22:00.000Z</published>
    <updated>2019-05-31T06:37:49.378Z</updated>
    
    <content type="html"><![CDATA[<p>前两天项目中使用了 <code>android jetpak</code>中的<code>lifecyle-process</code>组件，帮助我们管理生命周期，接入后发现不需要任何初始化操作，它的源码也比较简单，就4个文件，发现它使用<code>ContentProvider</code>的装载特性来做自动初始化操作。联想到多年前在做插件化时遇到<code>ContentProvider</code> 需要提前处理的情况。才发现，<code>Google</code>也会<code>投机取巧</code>啦。  本文我们就分析一下<code>ContentProvider</code>的装载流程。  </p><h3 id="1-ContentProvider-启动装载的场景"><a href="#1-ContentProvider-启动装载的场景" class="headerlink" title="1.ContentProvider 启动装载的场景"></a>1.ContentProvider 启动装载的场景</h3><p>先把结论抛出来,触发 <code>ContentProvider</code>装载的几个场景有:  </p><ul><li>进程启动，初始化Application时</li><li><p>三方应用通过<code>ContentResolver</code>调用<code>ContentProvider</code>的相关功能时</p><p>我们先跟踪一下 进程启动时的场景  </p></li></ul><h3 id="2-ContentProvider-进程启动装载"><a href="#2-ContentProvider-进程启动装载" class="headerlink" title="2. ContentProvider 进程启动装载"></a>2. ContentProvider 进程启动装载</h3><p>我们都知道 <code>Android</code>进程启动需要给定一个入口类，而每个程序的进程入口类就是<code>ActivityThread</code>。  </p><p><em>我们基于android-28，也就是Android P</em>  </p><p><code>ActivityThread</code>的入口函数为<code>main</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会调用 <code>ActivityThread</code>的<code>attach</code>方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;<span class="comment">//我们的进程属于 非系统进程，会执行该逻辑</span></span><br><span class="line">          ...</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通知 AMS 执行 attachApplication 操作</span></span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//系统进程执行的逻辑，因为允许在系统进程，直接生产 Application 实例，执行生命周期方法即可</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">                mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">                ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我继续跟入 <code>ActivityManagerService</code>的<code>attachApplication</code> 方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续<code>attachApplicationLocked</code>方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//前面 获取 ProcessRecord</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">             <span class="comment">//因为系统进程已经ready ，所以这里就会向 PackageManagerService 查询 apk的所有 ContentProvider 标签对应的 ProviderInfo</span></span><br><span class="line">             <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">         List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">         ...</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//到目前为止 已经有了 ContentProvider的信息了，但是 ConentProvider 还没有装载</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">                <span class="comment">// being bound to an application.</span></span><br><span class="line">                thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>正常情况下我们没有使用 <code>Instrumentation</code>所以 会执行 最后一个 <code>else</code>  </p><p>以后执行时序会再次进入到 <code>ActivityThread</code>中，也就是从AMS 进程进入到了我们的App进程中 ，同时把前面的  <code>providers</code>传入。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">                String buildSerial, <span class="keyword">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">            data.trackAllocation = trackAllocation;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            data.buildSerial = buildSerial;</span><br><span class="line">            data.autofillCompatibilityEnabled = autofillCompatibilityEnabled;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line">``` </span><br><span class="line"> 到目前为止，通过`Handler` 消息 将 `Binder` 进程释放，这样就避免了一个App的启动持续 Block 住系统进程  </span><br><span class="line"> </span><br><span class="line"> ```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p> 之后又进入到了 <code>handleBindApplication</code>方法  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">               <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">               mInstrumentation = (Instrumentation)</span><br><span class="line">                   cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Unable to instantiate instrumentation "</span></span><br><span class="line">                   + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//按照前面的分析，如果没有 AMS 调用时没有传入 instrumentationName，就会自动生成一个</span></span><br><span class="line">mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">     mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//生成Application实例，内部还会调用Application 的 attach 方法</span></span><br><span class="line">           app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">           app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);</span><br><span class="line"></span><br><span class="line">           mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">           <span class="comment">// app's custom Application class</span></span><br><span class="line">           <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">               <span class="comment">// ！！！！！重点重点，这里就开启装载ContentProvider的流程</span></span><br><span class="line">                   installContentProviders(app, data.providers);</span><br><span class="line">                   <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">                   <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">                   mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">           <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                          mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                   + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//!!!!! 通过 mInstrumentation 调用 Application的 onCreate 方法</span></span><br><span class="line">               mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                     <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                     + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">           <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">           <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                   || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">               StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过这段代码分析，我们清楚的知道，<code>ContentProvider</code>的装载时机在 <code>Application</code>的<code>attach</code>之后，在 <code>onCreate</code>之前。这就是当初做插件化的时候，必须在<code>onCreate</code>之前替换掉 <code>ProviderInfo</code>的原因,否则装载 <code>ContentProvider</code>必定失败。  </p><p> 下面我们再分析一下 <code>installContentProviders</code>方法  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">           <span class="comment">//遍历装载每一个 ContentProvider</span></span><br><span class="line">           ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                   <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">           <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">               cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">               results.add(cph);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//装载完成后通知 AMS，ContentProvider 装载完毕，后面就可以正常使用了</span></span><br><span class="line">           ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">          ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">   ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">      IContentProvider provider;</span><br><span class="line">      <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;<span class="comment">//前面传入的 holder 为null</span></span><br><span class="line">                      Context c = <span class="keyword">null</span>;</span><br><span class="line">          ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (info.splitName != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  c = c.createContextForSplit(info.splitName);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">              LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// System startup case.</span></span><br><span class="line">                  packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//通过反射得到生成一个 Provider 的实例</span></span><br><span class="line">              localProvider = packageInfo.getAppFactory()</span><br><span class="line">                      .instantiateProvider(cl, info.name);</span><br><span class="line">                      <span class="comment">//获取Provider的Binder接口</span></span><br><span class="line">              provider = localProvider.getIContentProvider();</span><br><span class="line">              <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">                        info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">                        info.applicationInfo.sourceDir);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//该方法最终会调动 Provider的 onCreate 方法</span></span><br><span class="line">              localProvider.attachInfo(c, info);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          provider = holder.provider;</span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 到目前为止，<code>ContentProvider</code> 已经启动完成。<br> 后面的操作就是建立 <code>ContentProviderHolder</code>,将 <code>ContentProviderHolder</code> 存放到<code>mProviderMap</code>,<code>mLocalProviders</code>,<code>mLocalProvidersByName</code>等集合中，方便下次使用和索引。  </p><p> 再回到调用栈的上一级<code>installContentProviders</code>  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">               StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">               buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">               buf.append(cpi.authority);</span><br><span class="line">               buf.append(<span class="string">": "</span>);</span><br><span class="line">               buf.append(cpi.name);</span><br><span class="line">               Log.i(TAG, buf.toString());</span><br><span class="line">           &#125;</span><br><span class="line">           ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                   <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">           <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">               cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">               results.add(cph);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 在该方法的最后执行了  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br></pre></td></tr></table></figure><p> 它会通知<code>AMS</code>,<code>AMS</code>进程会将 <code>providers</code>信息存储在 成员变量中，方便其他进程使用  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">           List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       enforceNotIsolatedCaller(<span class="string">"publishContentProviders"</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="comment">//获取调用者的进程信息，这里就是我们provider程序的进程信息</span></span><br><span class="line">           <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;<span class="comment">//遍历装载好的Provider</span></span><br><span class="line">               ContentProviderHolder src = providers.get(i);</span><br><span class="line">               <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//从之前解析好的ProviderInfo 列表中查找 出对应的 ContentProviderRecord</span></span><br><span class="line">               ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">               <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;<span class="comment">//因为在Provider装载之前就通过 generateApplicationProvidersLocked 方法生成了ContentProviderRecord实例，所以不会为null</span></span><br><span class="line">                   ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                   <span class="comment">//!!!! 重点:将Provider的信息记录到mProviderMap中，方便下次调用</span></span><br><span class="line">                   mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                   String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                       mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                   &#125;</span><br><span class="line">...<span class="comment">//省略部分的操作是将等待Provider装载的状态重置</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                   <span class="comment">//将 刚装载成功的Provider的Binder接口记录到ContentProviderRecord中，在此之前，ContentProviderRecord实例中都没有Provider 的Binder引用，都是不可用状态</span></span><br><span class="line">                       dst.provider = src.provider;</span><br><span class="line">                       dst.proc = r;</span><br><span class="line">                       dst.notifyAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   updateOomAdjLocked(r, <span class="keyword">true</span>);</span><br><span class="line">                   maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                           src.info.authority);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 从此之后，<code>ContentProvider</code>已经是Ready状态了，可以直接供使用了。  </p><h3 id="3-Client-调用-ContentProvider"><a href="#3-Client-调用-ContentProvider" class="headerlink" title="3. Client 调用 ContentProvider"></a>3. Client 调用 ContentProvider</h3><p>常规的调用方式是通过<code>ContentResolver</code>,获取<code>ContentResolver</code> 都是通过<code>Context</code>来实现  </p><p><em>android.content.Context.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><em>android.content.ContextWrapper.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getContentResolver();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们知道真正的<code>Context</code>实例是 <code>ContextImpl</code>类型的，下面分析一下<code>ContextImpl</code>的实现方式:<br><em>android.content. ContextImpl.java</em>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mContentResolver;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>mContentResolver</code> 对象是 <code>ApplicationContentResolver</code>类型的  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContentResolver</span> <span class="keyword">extends</span> <span class="title">ContentResolver</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ActivityThread mMainThread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ApplicationContentResolver</span><span class="params">(Context context, ActivityThread mainThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(context);</span><br><span class="line">            mMainThread = Preconditions.checkNotNull(mainThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireExistingProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseProvider</span><span class="params">(IContentProvider provider)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.releaseProvider(provider, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseUnstableProvider</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.releaseProvider(icp, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unstableProviderDied</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            mMainThread.handleUnstableProviderDied(icp.asBinder(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appNotRespondingViaProvider</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            mMainThread.appNotRespondingViaProvider(icp.asBinder());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">resolveUserIdFromAuthority</span><span class="params">(String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ContentProvider.getUserIdFromAuthority(auth, getUserId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们以 <code>ContentResolver</code>的<code>insert</code>方法作为切入点，进行分析  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Uri <span class="title">insert</span><span class="params">(@RequiresPermission.Write @NonNull Uri url,</span></span></span><br><span class="line"><span class="function"><span class="params">                @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        Preconditions.checkNotNull(url, <span class="string">"url"</span>);</span><br><span class="line">        <span class="comment">//1.首先根据URI 找到 ConentProvider的远端Binder引用</span></span><br><span class="line">        IContentProvider provider = acquireProvider(url);</span><br><span class="line">        <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown URL "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//2.调用 ConentProvider</span></span><br><span class="line">            Uri createdRow = provider.insert(mPackageName, url, values);</span><br><span class="line">            <span class="keyword">long</span> durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">            maybeLogUpdateToEventLog(durationMillis, url, <span class="string">"insert"</span>, <span class="keyword">null</span> <span class="comment">/* where */</span>);</span><br><span class="line">            <span class="keyword">return</span> createdRow;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseProvider(provider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于我们分析的是 <code>ContentProvider</code>的装载流程，所以只分析 <code>acquireProvider</code>方法  </p><p>最终会进入到<code>ApplicationContentResolver</code>的<code>acquireProvider</code>方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>mMainThread 就是 ActivityThread 对象  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//!!! 首先在本进程空间内查询 已经装载的 ContentProvider</span></span><br><span class="line">        <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There is a possible race here.  Another thread may try to acquire</span></span><br><span class="line">        <span class="comment">// the same provider at the same time.  When this happens, we want to ensure</span></span><br><span class="line">        <span class="comment">// that the first one wins.</span></span><br><span class="line">        <span class="comment">// Note that we cannot hold the lock while acquiring and installing the</span></span><br><span class="line">        <span class="comment">// provider since it might take a long time to run and it could also potentially</span></span><br><span class="line">        <span class="comment">// be re-entrant in the case where the provider is in the same process.</span></span><br><span class="line">        ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">            <span class="comment">//如果本进程空间内不存在ConentProvider，就委托AMS去查询</span></span><br><span class="line">                holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                        getApplicationThread(), auth, userId, stable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">        <span class="comment">// any ties in the race.</span></span><br><span class="line">        holder = installProvider(c, holder, holder.info,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">        <span class="keyword">return</span> holder.provider;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法 首先支持在本进程空间内查询 <code>ConentProvider</code>,其实就是从前面分析中提到的 <code>mProviderMap</code>中获取，在 随进程启动时装载的<code>Provider</code> 被放在<code>mProviderMap</code>中，这时就能直接访问使用了。  但也有可能需要查询不到,出现这种情况的情景如下:  </p><ul><li>请求的<code>Provider</code>需要独立进程允许，但是该进程还未启动，所以 <code>Provider</code> 未被装载。</li><li>请求的<code>Provider</code>是第三方程序的，需要通过AMS 获得。</li><li>请求的<code>Provider</code>是系统进程所有的，比如媒体库的<code>Provider</code>,这也需要AMS提供</li></ul><p>不管是以上三种情况的哪一种，都会进入到AMS， 我们选一种最长路径的情况做分析<br><mark><strong>假设我们请求的<code>Provider</code>是一个第三方APP的，但是这个App 还没有运行。</strong></mark>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           IApplicationThread caller, String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">       enforceNotIsolatedCaller(<span class="string">"getContentProvider"</span>);</span><br><span class="line">       <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">           String msg = <span class="string">"null IApplicationThread when getting content provider "</span></span><br><span class="line">                   + name;</span><br><span class="line">           Slog.w(TAG, msg);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span></span><br><span class="line">       <span class="comment">// with cross-user grant.</span></span><br><span class="line">       <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, stable, userId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>真正执行的是<code>getContentProviderImpl</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            String name, IBinder token, <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">     <span class="comment">// First check if this content provider has been published...</span></span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">            <span class="comment">// If that didn't work, check if it exists for user 0 and then</span></span><br><span class="line">            <span class="comment">// verify that it's a singleton provider before using it.</span></span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">                <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cpi = cpr.info;</span><br><span class="line">                    <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                            cpi.name, cpi.flags)</span><br><span class="line">                            &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                        userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                        checkCrossUser = <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cpr = <span class="keyword">null</span>;</span><br><span class="line">                        cpi = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">boolean</span> providerRunning = cpr != <span class="keyword">null</span> &amp;&amp; cpr.proc != <span class="keyword">null</span> &amp;&amp; !cpr.proc.killed;</span><br><span class="line">            <span class="keyword">if</span> (providerRunning) &#123;<span class="comment">//根据我们的假设，Provider 是未运行状态</span></span><br><span class="line">            </span><br><span class="line">            ...         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先AMS 从 <code>mProviderMap</code>中获取，前面分析随进程启动而装载的Provider 在自己进程装载完成后会通过<code>publishContentProviders</code>将 <code>Provider</code>列表保持在AMS中，其实就是保存在AMS的<code>mProviderMap</code>中。<br>根据我们的假设 Provider 所在的进程还未启动，所以 <code>mProviderMap</code>中是查询不到的  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         checkTime(startTime, <span class="string">"getContentProviderImpl: before resolveContentProvider"</span>);</span><br><span class="line">         <span class="comment">// ！！！首先通过PMS 查询 Provider的Info信息，为下一步的装载做准备</span></span><br><span class="line">         cpi = AppGlobals.getPackageManager().</span><br><span class="line">             resolveContentProvider(name,</span><br><span class="line">                            STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: after resolveContentProvider"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//如果找不大，说明未在 Manifest 文件中注册或者 程序未安装，直接返回NUll</span></span><br><span class="line">   <span class="keyword">if</span> (cpi == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//是否是singleton？其实就是 Provider在 Manifest 注册的时候是否增加了'singleUser'属性</span></span><br><span class="line">   <span class="comment">//如果 singleUser 属性设置为 true，意味着多用户环境下可以共用Provider对象。</span></span><br><span class="line">   <span class="comment">//其他情况就是系统Provider 是保持单例的</span></span><br><span class="line">   <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid);</span><br><span class="line">   <span class="keyword">if</span> (singleton) &#123;</span><br><span class="line">      userId = UserHandle.USER_SYSTEM;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//按照之前的假设，我们要访问的Provider 是不支持多用户共享的，所以需要重新装载</span></span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//后面就是一些检验Provider 的访问权限的校验，这里就不分析了</span></span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//获取目标Provider的进程信息，如果进程信息存在，说明目前进程是启动状态</span></span><br><span class="line">    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                                cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.d(TAG_PROVIDER,<span class="string">"Installing in existing process "</span> + proc);</span><br><span class="line">        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: scheduling install"</span>);</span><br><span class="line">            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通知目标进程装载指定的Provider</span></span><br><span class="line">                 proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          checkTime(startTime, <span class="string">"getContentProviderImpl: before start process"</span>);</span><br><span class="line">          <span class="comment">//如果目标进程未启动，先启动目标进程</span></span><br><span class="line">          proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                    cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">                                    <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                            cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">          checkTime(startTime, <span class="string">"getContentProviderImpl: after start process"</span>);</span><br><span class="line">          <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     cpr.launchingApp = proc;</span><br><span class="line">     <span class="comment">//将ProcessRecord添加到正在等待启动的列表中，如果完成Provider的装载后会从mLaunchingProviders列表中</span></span><br><span class="line">     mLaunchingProviders.add(cpr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上诉代码中得知:</p><ol><li>当目标 Provider 未装载运行时，会通过PMS 获取Provider信息，为装载做准备</li><li>检测目标 Provider 的进程是否在运行</li><li>如果目标进程已经运行，会自己通知目标进程去装载指定的Provider</li><li>如果目标进程未运行，会先启动进程</li></ol><p>当是情况<code>3</code>时， 代码最终会执行进入 ActivityThread.installContentProviders(Context context, List<providerinfo> providers) 中，这个方法在分析 随进程启动时装载Provider 中已经介绍过。  </providerinfo></p><p>当是情况<code>4</code>时，会执行 AMS 的 <code>startProcessLocked</code>方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">                hostingName, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继而又调用 另一个重载方法:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="comment">//正常情况下我们的目标进程不是隔离进程，前一步也的确传入false</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don't have to do anything more if:</span></span><br><span class="line">        <span class="comment">// (1) There is an existing application record; and</span></span><br><span class="line">        <span class="comment">// (2) The caller doesn't think it is dead, OR there is no thread</span></span><br><span class="line">        <span class="comment">//     object attached to it so we know it couldn't have crashed; and</span></span><br><span class="line">        <span class="comment">// (3) There is a pid assigned to it, so it is either starting or</span></span><br><span class="line">        <span class="comment">//     already running.</span></span><br><span class="line">        <span class="comment">//如源码注释所说，启动前判断一下目标进程其实是存活的，什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">                checkTime(startTime, <span class="string">"startProcess: done, added package to proc"</span>);</span><br><span class="line">                <span class="keyword">return</span> app;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这种情况下，说明需要认定目标进程已经死了，以下代码处理清除目标进程的操作</span></span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: bad proc running, killing"</span>);</span><br><span class="line">            killProcessGroup(app.uid, app.pid);</span><br><span class="line">            handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: done killing old proc"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String hostingNameStr = hostingName != <span class="keyword">null</span></span><br><span class="line">                ? hostingName.flattenToShortString() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常情况下 app 为 null，我们需要启动进程</span></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">            <span class="comment">//创建代表进程状态的 ProcessRecord 对象</span></span><br><span class="line">            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">         &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//继续启动进程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">        <span class="keyword">return</span> success ? app : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续启动进程  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">           String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义进程启动的入口类是 "android.app.ActivityThread"</span></span><br><span class="line">      <span class="keyword">final</span> String entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">      <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                   startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码规定了，进程的入口是 “android.app.ActivityThread”   </p><p>后面会继续进入到 <code>startProcess</code>方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                    app.processName);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">            <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">            <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">                startResult = startWebView(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startResult = Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里发现对 <code>webview_service</code> 进程做了单独处理,应该是因为Android接入的是 Chromium 内核,<br>最后 通过 <code>Process.start</code>方法开启真正的进程之旅啊<br>下面顺带着简单介绍下进程的启动流程，不过不会深入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现通过 Zygote 进程孵化  </p><p><strong>android.os.ZygoteProcess.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一堆 Zygote 参数</span></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">            argsForZygote.add(invokeWith);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <strong><code>openZygoteSocketIfNeeded(abi)</code></strong> 这里打开了  zygote的socket连接，说明 孵化进程通过经典的<code>socket</code>进行通信。有兴趣的同学可以深入了解下  </p><p><code>zygote socket</code> 打开之后，我们继续分析<code>zygoteSendArgsAndGetResult</code> 方法  </p><pre><code class="java"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span><span class="function"><span class="params">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span><span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>{        <span class="keyword">try</span> {            <span class="keyword">int</span> sz = args.size();            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {                <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) {                    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);                }            }            <span class="comment">//往 socket 中写入命令数据，包括 进程的入口类</span>            <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;            <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;            writer.write(Integer.toString(args.size()));            writer.newLine();            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {                String arg = args.get(i);                writer.write(arg);                writer.newLine();            }            writer.flush();            <span class="comment">// Should there be a timeout on this?</span>            Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();            <span class="comment">//从 socket 中读取启动结果</span>            result.pid = inputStream.readInt();            result.usingWrapper = inputStream.readBoolean();            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) {                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);            }            <span class="keyword">return</span> result;        } <span class="keyword">catch</span> (IOException ex) {            zygoteState.close();            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);        }    }</code></pre><p>再往后 具体如何调用 <code>ActivityThread</code>的<code>main</code>方法就不做具体深入了。<br>最终会执行<code>ActivityThread</code>的<code>main</code>，这又回到了文章开头介绍的，进程启动时装载<code>Provider</code>的场景。  </p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol><li><code>Provider</code>的装载分两种场景，分别是 <em>随进程启动而装载 和 被调用时装载</em></li><li>随进程启动的<code>Provider</code>装载时机在<code>Application</code>的<code>onCreate</code>方法之前，<code>attach</code>方法之后</li><li>装载后的<code>Provider</code>会记录在本进程空间的<code>mProviderMap</code>中，同时也会通知 AMS，AMS 也会保持在它自己的 <code>mProviderMap</code>中</li><li>在 Client 通过<code>ContentResolver</code>调用<code>Provider</code>时 首先到调用者的进程空间中去查询，如果存在直接返回使用; 如果不存在，通知AMS 去获取。如果AMS中直接有保持的实例，直接返回实例，否则AMS去装载Provider。</li><li>AMS 去装载时有区分是否目标进程已经存在还是未存在; 如果已经存在，直接调用 目标进程的<code>scheduleInstallProvider</code>方法去装载；如果目标进程不存在，同 <code>zygote</code> 进程去启动进程,进而 <code>Provider</code> 随着进程启动而装载。</li><li>还需要注意的是，如果<code>Provider</code>是设置了 <code>singleUser</code>属性，会被多个用户共享。</li><li>如第<code>4</code>条。如果通过<code>AMS</code> 获取到了别的进程的 <code>Provider</code>实例，需要在自己的进程空间保留一份引用，方便下次调用时，直接返回，而不再需要通过AMS获取。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天项目中使用了 &lt;code&gt;android jetpak&lt;/code&gt;中的&lt;code&gt;lifecyle-process&lt;/code&gt;组件，帮助我们管理生命周期，接入后发现不需要任何初始化操作，它的源码也比较简单，就4个文件，发现它使用&lt;code&gt;ContentProvi
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="ContentProvider" scheme="http://aicodeing.github.io/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>Android-Binder通信的数据传输载体-Parcel</title>
    <link href="http://aicodeing.github.io/Android-Binder%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BD%BD%E4%BD%93-Parcel/"/>
    <id>http://aicodeing.github.io/Android-Binder通信的数据传输载体-Parcel/</id>
    <published>2019-03-19T06:09:19.000Z</published>
    <updated>2019-05-29T11:19:08.286Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在 Android上常用的两种对象序列化工具是<code>Serializable</code>和<code>Parcelable</code>。尤其我们做和<code>Binder</code>相关的数据传输时，选择的都是<code>Parcelable</code>数据。<code>Parcelable</code>其实就是一个接口，约定，如果一个对象希望使用<code>Parcelable</code>方式将数据序列化到内存中，必须实现 <code>Parcelable</code>接口。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, @WriteFlags <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>接口的一个核心方法就是 <code>writeToParcel</code>，其实就是调用<code>Parcel</code>提供的一系列方法，将数据序列化到<code>Parcel</code>中。   </p><h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4><p><code>Parcel</code>是一种数据的载体，用于承载Binder相关的通信数据，数据可以是原始类型的，也可以是对象的引用。  </p><p><code>Parcel</code>常用的方法有:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">writeByte(<span class="keyword">byte</span> val) <span class="comment">//写入一个byte</span></span><br><span class="line">readByte()<span class="comment">//读取一个byte</span></span><br><span class="line">writeBoolean(<span class="keyword">boolean</span> val)</span><br><span class="line">readBoolean()</span><br><span class="line">writeInt(<span class="keyword">int</span> val)</span><br><span class="line">readInt()</span><br><span class="line">writeLong(<span class="keyword">long</span> val)</span><br><span class="line">readLong()</span><br><span class="line">writeFloat(<span class="keyword">float</span> val)</span><br><span class="line">readFloat()</span><br><span class="line">writeDouble(<span class="keyword">double</span> val)</span><br><span class="line">readDouble()</span><br><span class="line">writeString(String val)</span><br><span class="line">readString()</span><br></pre></td></tr></table></figure><p>这些方法都是成对匹配使用的，即在数据封装端，调用相应的writexxx方法，在解封端使用readxxx方法。  </p><p>以上列举的操作数据类型是原始数据类型，和String，还可以写入其他类型:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            writeInt(VAL_NULL);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeInt(VAL_STRING);</span><br><span class="line">            writeString((String) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            writeInt(VAL_INTEGER);</span><br><span class="line">            writeInt((Integer) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            writeInt(VAL_MAP);</span><br><span class="line">            writeMap((Map) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Bundle) &#123;</span><br><span class="line">            <span class="comment">// Must be before Parcelable</span></span><br><span class="line">            writeInt(VAL_BUNDLE);</span><br><span class="line">            writeBundle((Bundle) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PersistableBundle) &#123;</span><br><span class="line">            writeInt(VAL_PERSISTABLEBUNDLE);</span><br><span class="line">            writePersistableBundle((PersistableBundle) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Parcelable) &#123;</span><br><span class="line">            <span class="comment">// types will be written.</span></span><br><span class="line">            writeInt(VAL_PARCELABLE);</span><br><span class="line">            writeParcelable((Parcelable) v, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Short) &#123;</span><br><span class="line">            writeInt(VAL_SHORT);</span><br><span class="line">            writeInt(((Short) v).intValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            writeInt(VAL_LONG);</span><br><span class="line">            writeLong((Long) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Float) &#123;</span><br><span class="line">            writeInt(VAL_FLOAT);</span><br><span class="line">            writeFloat((Float) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">            writeInt(VAL_DOUBLE);</span><br><span class="line">            writeDouble((Double) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            writeInt(VAL_BOOLEAN);</span><br><span class="line">            writeInt((Boolean) v ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">            <span class="comment">// Must be after String</span></span><br><span class="line">            writeInt(VAL_CHARSEQUENCE);</span><br><span class="line">            writeCharSequence((CharSequence) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            writeInt(VAL_LIST);</span><br><span class="line">            writeList((List) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> SparseArray) &#123;</span><br><span class="line">            writeInt(VAL_SPARSEARRAY);</span><br><span class="line">            writeSparseArray((SparseArray) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_BOOLEANARRAY);</span><br><span class="line">            writeBooleanArray((<span class="keyword">boolean</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_BYTEARRAY);</span><br><span class="line">            writeByteArray((<span class="keyword">byte</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">            writeInt(VAL_STRINGARRAY);</span><br><span class="line">            writeStringArray((String[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> CharSequence[]) &#123;</span><br><span class="line">            <span class="comment">// Must be after String[] and before Object[]</span></span><br><span class="line">            writeInt(VAL_CHARSEQUENCEARRAY);</span><br><span class="line">            writeCharSequenceArray((CharSequence[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> IBinder) &#123;</span><br><span class="line">            writeInt(VAL_IBINDER);</span><br><span class="line">            writeStrongBinder((IBinder) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Parcelable[]) &#123;</span><br><span class="line">            writeInt(VAL_PARCELABLEARRAY);</span><br><span class="line">            writeParcelableArray((Parcelable[]) v, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_INTARRAY);</span><br><span class="line">            writeIntArray((<span class="keyword">int</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_LONGARRAY);</span><br><span class="line">            writeLongArray((<span class="keyword">long</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Byte) &#123;</span><br><span class="line">            writeInt(VAL_BYTE);</span><br><span class="line">            writeInt((Byte) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Size) &#123;</span><br><span class="line">            writeInt(VAL_SIZE);</span><br><span class="line">            writeSize((Size) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> SizeF) &#123;</span><br><span class="line">            writeInt(VAL_SIZEF);</span><br><span class="line">            writeSizeF((SizeF) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_DOUBLEARRAY);</span><br><span class="line">            writeDoubleArray((<span class="keyword">double</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = v.getClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isArray() &amp;&amp; clazz.getComponentType() == Object.class) &#123;</span><br><span class="line">                writeInt(VAL_OBJECTARRAY);</span><br><span class="line">                writeArray((Object[]) v);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                <span class="comment">// Must be last</span></span><br><span class="line">                writeInt(VAL_SERIALIZABLE);</span><br><span class="line">                writeSerializable((Serializable) v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Parcel: unable to marshal value "</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见<code>Parcel</code>还支持多种 <code>Object</code>类型。</p><p>但是大部分情况下，封装端写入的对象和 解封端获得的对象不是同一个了，而是将对象中的数据复制过去一份，相当于是新 clone 了一个对象。那有没办法使用原来的对象呢？  </p><p>答案是可以的，不过是间接的，这类对象我们称之为<code>Active Objects</code>。Parcel 写入的是他们的特殊标记引用。这类对象常见的有以下两种:  </p><ol><li>Binder。Binder 是Android系统中IPC的核心通信机制，它还是一个对象，Parcel 可以通过<code>writeStrongBinder(IBinder val)</code>写入Binder对象，解封端读取的是原Binder对象的一个特殊代理类(BinderProxy),但是最终的操作还是被原Binder对象响应，所以可以间接的认为将Binder对象传递了过去。  </li><li>FileDescriptor 。FD 是Linux中的文件描述符，可以通过Parcel 的<code>writeFileDescriptor(FileDescriptor val)</code>方法写入</li></ol><p>不管是 Binder 还是 FileDescriptor 接收端的对象仍然会基于和原对象相同的操作，所以可以认为是 <code>Active Object</code>。  </p><h4 id="Parcel-写入数据分析"><a href="#Parcel-写入数据分析" class="headerlink" title="Parcel 写入数据分析"></a>Parcel 写入数据分析</h4><p>我们基于 <code>Parcel</code>写入<code>String</code> 来做一个源码分析  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        mReadWriteHelper.writeString(<span class="keyword">this</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteHelper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReadWriteHelper DEFAULT = <span class="keyword">new</span> ReadWriteHelper();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(Parcel p, String s)</span> </span>&#123;</span><br><span class="line">            nativeWriteString(p.mNativePtr, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">(Parcel p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nativeReadString(p.mNativePtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见 <code>Parcel</code> 有 <code>native</code> 代码的实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Parcel</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">            mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        init(nativePtr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">            mNativePtr = nativePtr;</span><br><span class="line">            mOwnsNativeParcelObject = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNativePtr = nativeCreate();<span class="comment">//调用native代码，获得指针</span></span><br><span class="line">            mOwnsNativeParcelObject = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>nativeCreate()</code>定义在<code>framework/base/cor/jni/android_os_Parcel.cpp</code>文件中  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gParcelMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    &#123;<span class="string">"nativeWriteInt"</span>,            <span class="string">"(II)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeInt&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteString"</span>,         <span class="string">"(ILjava/lang/String;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeString&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteStrongBinder"</span>,   <span class="string">"(ILandroid/os/IBinder;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeStrongBinder&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteFileDescriptor"</span>, <span class="string">"(ILjava/io/FileDescriptor;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeFileDescriptor&#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="string">"nativeReadInt"</span>,             <span class="string">"(I)I"</span>, (<span class="keyword">void</span>*)android_os_Parcel_readInt&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeReadLong"</span>,            <span class="string">"(I)J"</span>, (<span class="keyword">void</span>*)android_os_Parcel_readLong&#125;,</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"nativeCreate"</span>,              <span class="string">"()I"</span>, (<span class="keyword">void</span>*)android_os_Parcel_create&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>android_os_Parcel.cpp</code>中定义了native和java的方法映射。所以native层执行的方法是<code>android_os_Parcel_create()</code>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Java层的<code>mNativePtr</code>变量实际上是native层的一个<code>Parcel(C++)</code>对象  </p><p><code>Parcel.cpp</code>代码位置<code>frameworks/native/libs/binder/Parcel.cpp</code><br>从源码位置上就能看出来，<code>Parcel</code>就是用来辅助Binder通信的。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Parcel::Parcel()</span><br><span class="line">&#123;</span><br><span class="line">    initState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parcel::initState()</span><br><span class="line">&#123;</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="number">0</span>;</span><br><span class="line">    mDataSize = <span class="number">0</span>;</span><br><span class="line">    mDataCapacity = <span class="number">0</span>;</span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    ALOGV(<span class="string">"initState Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</span><br><span class="line">    ALOGV(<span class="string">"initState Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="literal">NULL</span>;</span><br><span class="line">    mObjectsSize = <span class="number">0</span>;</span><br><span class="line">    mObjectsCapacity = <span class="number">0</span>;</span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mHasFds = <span class="literal">false</span>;</span><br><span class="line">    mFdsKnown = <span class="literal">true</span>;</span><br><span class="line">    mAllowFds = <span class="literal">true</span>;</span><br><span class="line">    mOwner = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parcel 对象初始化的过程中只是简单的初始化了各个成员变量，并没有分配内存。Parcel 遵循的是动态扩展的原则，只有在真正需要的时候才会申请内存，避免了资源浪费。  </p><p>Parcel对象初始化的这些变量定义在<code>`frameworks/native/libs/binder/Parcel.h</code>文件中，我们来看看它们的含义  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span>            mError;</span><br><span class="line">  <span class="keyword">uint8_t</span>*            mData;<span class="comment">//Parcel中存储的数据内容，它是一个8位 uint8_t类型的指针</span></span><br><span class="line">  <span class="keyword">size_t</span>              mDataSize;<span class="comment">//Parcel 中已经存储的数据大小</span></span><br><span class="line">  <span class="keyword">size_t</span>              mDataCapacity;<span class="comment">//最大容量</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">size_t</span>      mDataPos;<span class="comment">//当前数据存储到哪了？</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>我们看看 如何往<code>Parcel</code>中写入数据，以 写入String 为例:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">       mReadWriteHelper.writeString(<span class="keyword">this</span>, val);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(Parcel p, String s)</span> </span>&#123;</span><br><span class="line">           nativeWriteString(p.mNativePtr, s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>执行的是<code>android_os_Parcel.cpp</code>中的<code>android_os_Parcel_writeString</code>方法  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeString</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr, jstring val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = NO_MEMORY;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">const</span> jchar* str = env-&gt;GetStringCritical(val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (str) &#123;</span><br><span class="line">                err = parcel-&gt;writeString16(str, env-&gt;GetStringLength(val));</span><br><span class="line">                env-&gt;ReleaseStringCritical(val, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = parcel-&gt;writeString16(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将指针<code>mNativePtr</code>转成Native 层的Parcel对象；然后将Java成的String转成Native层的字符串；调用 Parcel对象的<code>writeString16</code>方法入,这时候已经进入 <code>Parcel.cpp</code>中，我们看看 它的<code>writeString16</code>方法    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeString16(<span class="keyword">const</span> String16&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> writeString16(str.<span class="built_in">string</span>(), str.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> Parcel::writeString16(<span class="keyword">const</span> <span class="keyword">char16_t</span>* str, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> writeInt32(<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> err = writeInt32(len);<span class="comment">//写入数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        len *= <span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>);<span class="comment">//len * 单位大小 得到占用的空间大小</span></span><br><span class="line">        <span class="keyword">uint8_t</span>* data = (<span class="keyword">uint8_t</span>*)writeInplace(len+<span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(data, str, len);</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char16_t</span>*&gt;(data+len) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        err = mError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>writeString16</code>方法首先通过<code>writeInt32</code>写入字符串的长度  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeInt32(<span class="keyword">int32_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAligned(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">Parcel</span>:</span>:writeAligned(T val) &#123;</span><br><span class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) &#123;<span class="comment">//如果容量够</span></span><br><span class="line">restart_write:</span><br><span class="line">        *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;<span class="comment">//保存val</span></span><br><span class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));<span class="comment">//修正mDataPos和mDataSize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(<span class="keyword">sizeof</span>(val));<span class="comment">//数据超过Parcel的存储容量，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入String size 调用的是一个模板类，泛型T是int类型，首先判断是否容量充足，如果充足直接写入，否则扩容。  </p><p>回到 <code>writeString16</code>方法，继续写入一个 String 字符串。<code>len *= sizeof(char16_t);</code>计算一共需要占用多少字节,然后使用<code>writeInplace</code>计算复制数据的目标地址，如果一切顺利，后面会调用<code>memcpy</code>真正的将字符串拷贝进去。  </p><p>我们分析一下<code>writeInplace</code>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* Parcel::writeInplace(<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> padded = PAD_SIZE(len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check for integer overflow</span></span><br><span class="line">    <span class="keyword">if</span> (mDataPos+padded &lt; mDataPos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+padded) &lt;= mDataCapacity) &#123;</span><br><span class="line">restart_write:</span><br><span class="line">        <span class="keyword">uint8_t</span>* <span class="keyword">const</span> data = mData+mDataPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to pad at end?</span></span><br><span class="line">        <span class="keyword">if</span> (padded != len) &#123;<span class="comment">//需要尾部填充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> mask[<span class="number">4</span>] = &#123;</span><br><span class="line">                <span class="number">0x00000000</span>, <span class="number">0xffffff00</span>, <span class="number">0xffff0000</span>, <span class="number">0xff000000</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> mask[<span class="number">4</span>] = &#123;</span><br><span class="line">                <span class="number">0x00000000</span>, <span class="number">0x00ffffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          </span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(data+padded<span class="number">-4</span>) &amp;= mask[padded-len];<span class="comment">//填充尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finishWrite(padded);<span class="comment">//修正mDataPos和mDataSize</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(padded);<span class="comment">//容量不足，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PAD_SIZE(s) (((s)+3)&amp;~3)</span><br></pre></td></tr></table></figure><p><code>PAD_SIZE</code>以4字节对齐，即每一份占4字节。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len =1 padded = 4 </span><br><span class="line">len =4 padded = 4 </span><br><span class="line">len =5 padded = 8</span><br><span class="line">len =8 padded = 8</span><br><span class="line">len =9 padded = 12</span><br></pre></td></tr></table></figure><p>回到<code>writeInplace</code>方法，如果 <code>padded != len</code>说明写入的数据长度不是4字节的整数倍，所以需要在空余的尾部填充一些 <code>mask</code>数据，这里填充的字节序有两种:<code>BIG_ENDIAN</code>和<code>LITTLE_ENDIAN</code>,他们的填充字段不同。</p><p>该方法中同样考虑了 容量不足时使用<code>growData</code>方法扩容。 </p><p>再次回到<code>writeString16</code>方法中   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (data) &#123;</span><br><span class="line">           memcpy(data, str, len);</span><br><span class="line">           *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;</span><br><span class="line">           return NO_ERROR;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>有了拷贝的目标地址，然后系统调用<code>memcpy</code>将 字符串 <code>str</code>拷贝到目标地址中；<br>在最后写入结束标记<code>0</code>。 至此，写入一个String 操作完成。  </p><p>总结一下写入String 操作:  </p><ol><li>Java成的<code>Parcel.writeString</code>最终调用<code>Parcel.cpp</code>中的<code>writeString16</code>方法</li><li>首先写入一个4直接的Int值，表示 String的长度</li><li>通过 <code>writeInplace</code>函数计算 要写入的目标地址，注意，这里以4字节为单位进行分配</li><li>如果空间不足，使用函数<code>growData</code>进行扩容，中间会设计到调用<code>continueWrite</code>函数做老数据拷贝</li><li>获得目标地址后，使用<code>memcpy</code>函数进行拷贝</li><li>最后写入结束标记<code>0</code></li></ol><h4 id="Parcel-读数据分析"><a href="#Parcel-读数据分析" class="headerlink" title="Parcel 读数据分析"></a>Parcel 读数据分析</h4><p>上面分析了往Parcel 中写一个String，这里配对分析一下<code>readString</code><br>readString 也是经过natice 层处理的，最终调用到<code>android_os_Parcel.cpp</code>中  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">android_os_Parcel_readString</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char16_t</span>* str = parcel-&gt;readString16Inplace(&amp;len);</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            <span class="keyword">return</span> env-&gt;NewString(str, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又调用了<code>Parcel.cpp</code>中的<code>readString16Inplace</code>方法  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char16_t</span>* Parcel::readString16Inplace(<span class="keyword">size_t</span>* outLen) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> size = readInt32();<span class="comment">//首先读出String的大小</span></span><br><span class="line">    <span class="comment">// watch for potential int overflow from size+1</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">0</span> &amp;&amp; size &lt; INT32_MAX) &#123;</span><br><span class="line">        *outLen = size;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char16_t</span>* str = (<span class="keyword">const</span> <span class="keyword">char16_t</span>*)readInplace((size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>));<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *outLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 readInt，读出String 的大小；然后通过<code>readInplace</code>获取到字符串的起始地址；<br>最后 new 一个Java层的字符串对象返回。</p><p>这里以 String的写入和读取为例做的分析，其他类型数据的写入和读取也都类似，就不一一分析了。至于 <code>Active Object</code>的写入和读取，在之后的Binder 分析文章中会有具体分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道在 Android上常用的两种对象序列化工具是&lt;code&gt;Serializable&lt;/code&gt;和&lt;code&gt;Parcelable&lt;/code&gt;。尤其我们做和&lt;code&gt;Binder&lt;/code&gt;相关的数据传输时，选择的都是&lt;code&gt;Parcelable&lt;/cod
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://aicodeing.github.io/tags/Binder/"/>
    
      <category term="Parcel" scheme="http://aicodeing.github.io/tags/Parcel/"/>
    
  </entry>
  
  <entry>
    <title>Android-智能指针</title>
    <link href="http://aicodeing.github.io/Android-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://aicodeing.github.io/Android-智能指针/</id>
    <published>2019-03-16T14:12:49.000Z</published>
    <updated>2019-05-29T11:19:08.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针?"></a>什么是智能指针?</h3><p>Android 上层APP 基本都是基于Java 语言进行来发的，对于Java 语言来说是没有<code>指针</code>概念的，因为在 JVM层，Java 就将指针隐藏起来了，基于Java 开发不需要涉及对象的手动内存分配和释放。那Android 为什么搞一个 <code>智能指针</code>呢？ 这主要是因为 Android 的Framework 相当一部分还是 <code>C/C++</code>来实现的，<code>C/C++</code>是有指针概念的，但是对于一个庞大的操作系统而言，智能肯定是满天飞的，这中间很容易就出现指针相关的错误，为了减少在指针方面的关注，Android 封装了自己的<code>智能指针</code>用于管理<code>C/C++</code>层的对象引用问题，期望能像 Java一样，忘记指针的概念。  </p><p>但事实上，<code>智能指针</code>并不是真正的指针，它只是对<code>C++</code>对象自动回收机制的封装。</p><p>我们来看看智能指针如何实现的?  </p><h4 id="常见的指针问题"><a href="#常见的指针问题" class="headerlink" title="常见的指针问题"></a>常见的指针问题</h4><p>在 C/C++项目中，常见的指针问题大致有:  </p><ul><li>指针未初始化</li><li>new 操作和delete 操作未配套操作</li><li>野指针</li></ul><p>Android的智能指针主要也是为了解决这三个问题  </p><p><strong>指针未初始化:</strong> 解决这个问题 只需要在创建智能指针的时候，将 指针置空<br><strong>new 和 delete不配套:</strong> 在C++中，<code>构造函数</code>和<code>析构函数</code>是在对象new出来和delete的时候调用的,可以在这两个地方做相应的处理<br><strong>野指针:</strong> 解决这个问题其实就是让智能指针自动能判断对象是否可以被回收。这也是三个问题中的核心问题。</p><p>智能指针采用的是<code>引用计数器</code>方式来比较一个对象是否需要被回收。  </p><p><em>那么引用计数器是应该智能指针拥有呢还是被对象Object拥有呢？</em>  </p><p>如果计数器由智能指针拥有，假如 智能指针<code>SmartPointer1</code>和智能指针<code>SmartPointer2</code>都引用 object对象，当 <code>SmartPointer1</code>不再引用object时，计数器为0，删除了对象object，但是 <code>SmartPoint2</code>还在引用着object。回收object 肯定是不合理的。所以 引用计数器只能是 object 拥有。</p><h3 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h3><p>智能指针在Android上有三个比较重要的实现，分别是<code>轻量级指针</code>,<code>强指针</code>,<code>弱指针</code>。它们的实现原理都是一致的，即由对象本身来提供引用计数器，但是它不会去维护这个引用计数器的值，而是由智能指针来维护</p><h4 id="轻量级智能指针-LightRefBase"><a href="#轻量级智能指针-LightRefBase" class="headerlink" title="轻量级智能指针 LightRefBase"></a>轻量级智能指针 LightRefBase</h4><p>这里所说的轻量级指针不是说 <code>LightRefBase</code> 是一个指针的定义，它是 配合智能指针的object对象的最简单，最轻量级的实现。  </p><p>源码位置 <code>frameworks/native/include/utils/RefBase.h</code>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LightRefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline LightRefBase() : mCount(0) &#123; &#125; //mCount 就是引用计数器,初始化值为0</span><br><span class="line">    inline void incStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        android_atomic_inc(&amp;mCount);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        <span class="keyword">if</span> (android_atomic_dec(&amp;mCount) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">inline</span> ~LightRefBase() &#123; &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给类有一个成员变量<code>mCount</code>，这就是<code>引用计数器</code>，它的初始化值为<code>0</code>，另外，这个类还提供两个成员函数<code>incStrong</code>和<code>decStrong</code>,分别是用来增加引用和减少引用计数的，这两个函数提供给智能指针来调用，在decStrong函数中，如果当前引用计数值为1，那么当减1后就会变成0，于是就会delete这个对象。</p><p>轻量级智能指针 LightRefBase 是需要和 智能指针搭配使用的，只有继承 <code>LightRefBase</code>的类型对象才能使用智能指针(先不考虑RefBase)。  </p><h4 id="强指针-sp"><a href="#强指针-sp" class="headerlink" title="强指针 sp"></a>强指针 sp</h4><p>前面说的 <code>LightRefBase</code>的计数器是由智能指针来修改的，那就是 <code>sp</code>了。  </p><p>源码定义位置：<code>frameworks/native/include/utils/StrongPointer.h</code>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline sp() : m_ptr(0) &#123; &#125;//首先将引用置空，解决指针为初始化问题</span><br><span class="line"></span><br><span class="line">    sp(T* other);</span><br><span class="line">    sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp(U* other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~sp();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment</span></span><br><span class="line"></span><br><span class="line">    sp&amp; <span class="keyword">operator</span> = (T* other);</span><br><span class="line">    sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;T&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;U&gt;&amp; other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp&amp; <span class="keyword">operator</span> = (U* other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Special optimization for use by ProcessState (and nobody else).</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">force_set</span><span class="params">(T* other)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span>  T&amp;      <span class="keyword">operator</span>* () <span class="keyword">const</span>  &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">    <span class="keyword">inline</span>  T*      <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  T*      <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>         </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Operators</span></span><br><span class="line"></span><br><span class="line">    COMPARE(==)</span><br><span class="line">    COMPARE(!=)</span><br><span class="line">    COMPARE(&gt;)</span><br><span class="line">    COMPARE(&lt;)</span><br><span class="line">    COMPARE(&lt;=)</span><br><span class="line">    COMPARE(&gt;=)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">wp</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>强指针sp 初始化的时候 首先将 引用 <code>m_ptr</code>置空，<code>m_ptr</code>指向的就是<code>LightRefBase</code>,当然也可以是<code>RefBase</code>,只不过 <code>RefBase</code>还支持弱指针访问，比较复杂，后面会再详细介绍。  </p><p>先看看 sp 构造函数做了什么事情  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">: m_ptr(other)</span><br><span class="line">  &#123;</span><br><span class="line">    if (other) other-&gt;incStrong(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>sp的构造函数有多个，这里只分析了其中一个，其他的类似。通过构造方法与引用对象关联时，首先调用了<code>LightRefBase</code>或<code>RefBase</code>的<code>incStrong</code>增加引用数量。  </p><p>sp 还重载了运算符<code>=</code>,当使用 <code>=</code>将一个对象与智能指针sp关联时，会操作object对象的引用数。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> = (T* other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">    m_ptr = other;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用<code>=</code>运算符时，将判断该指针之前是否引用过别的对象，即 <code>m_ptr</code>是否不为空，如果有引用，<code>m_ptr</code>不为空，需要先将原引用对象的引用计数器减小，在将新引用的对象计数器增加，并和 <code>m_ptr</code>关联。  </p><p>sp的析构函数  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行析构函数的时候，将减小引用对象的引用计数器。  </p><p>回顾上面提及的<code>LightRefBase</code>和<code>sp</code>好像无法避免循环引用的问题。而<code>弱指针wp</code>就是专门解决该问题的。  </p><p><code>LightRefBase</code>之所以称之为 <code>轻量级的</code>，是与<code>RefBase</code>相比而言的。<code>RefBase</code>的实现比<code>LightRefBase</code>复杂许多，其内部包含了 弱指针wp的定义和实现。  </p><h4 id="弱指针wp"><a href="#弱指针wp" class="headerlink" title="弱指针wp"></a>弱指针wp</h4><p>如前面所说，弱指针的主要使命就是解决循环引用的问题，我们看看它和 强指针sp的区别  </p><p>弱指针wp源码定义在 <code>frameworks/native/include/utils/RefBase.h</code>中  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class wp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef typename RefBase::weakref_type weakref_type;</span><br><span class="line">    //约定 弱指针执行的对象类型必须是 RefBase 类型，而不能是 LightRefBase</span><br><span class="line">    </span><br><span class="line">    inline wp() : m_ptr(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    wp(T* other);//构造函数</span><br><span class="line">    wp(const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line">    </span><br><span class="line">    wp&amp; operator = (T* other);//运算符重载</span><br><span class="line">    wp&amp; operator = (const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    void set_object_and_refs(T* other, weakref_type* refs);</span><br><span class="line"></span><br><span class="line">    // promotion to sp</span><br><span class="line">    </span><br><span class="line">    sp&lt;T&gt; promote() const; // 将弱指针升级为强指针sp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line">    //以下是重载一些逻辑运算符</span><br><span class="line"></span><br><span class="line">    COMPARE_WEAK(==)</span><br><span class="line">    COMPARE_WEAK(!=)</span><br><span class="line">    COMPARE_WEAK(&gt;)</span><br><span class="line">    COMPARE_WEAK(&lt;)</span><br><span class="line">    COMPARE_WEAK(&lt;=)</span><br><span class="line">    COMPARE_WEAK(&gt;=)</span><br><span class="line"></span><br><span class="line">    inline bool operator == (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line"></span><br><span class="line">    T*              m_ptr; //指向目标对象的指针</span><br><span class="line">    weakref_type*   m_refs;//指向weakref_type类型的弱引用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和 强指针sp相比，wp有以下重要区别:  </p><ul><li>除了指向目标对象的 m_ptr 外，wp另外还有一个 m_refs 指针，类型为 weakref_type</li><li>没有重载 -&gt;, * 等运算符</li><li>有一个 promote()方法用来将wp提升为sp</li><li>弱指针的目标对象类型不是<code>LightRefBase</code>，而是 <code>RefBase</code></li></ul><p>惯例，我们看看 wp的构造函数实现:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(T* other)</span><br><span class="line">    : m_ptr(other)</span><br><span class="line">&#123;</span><br><span class="line">    if (other) m_refs = other-&gt;createWeak(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出和 sp的构造方法不同，没有直接调用 目标对象的 <code>incStrong</code>方法，而是调用了<code>createWeak</code>方法。可见wp并没有直接增加目标对象的引用计数器，因为 <code>createWeak</code>方法是 <code>RefBase</code>中定义的，我们稍后会详细分析 <code>RefBase</code>  </p><p>析构函数:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_ptr) m_refs-&gt;decWeak(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数也没有直接操作 引用计数器。</p><p>我们再看看运算符<code>=</code>的重载  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;&amp; wp&lt;T&gt;::operator = (T* other)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_type* newRefs =</span><br><span class="line">        other ? other-&gt;createWeak(this) : 0;</span><br><span class="line">    if (m_ptr) m_refs-&gt;decWeak(this);</span><br><span class="line">    m_ptr = other;</span><br><span class="line">    m_refs = newRefs;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，运算符<code>=</code>同样也没有直接操作引用计数器，而是操作 <code>weakref_type</code></p><p>综上，wp主要操作的是 <code>weakref_type</code>。并不直接影响引用计数器，所以称之为弱指针，不会改变引用关系。</p><h4 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h4><p>前面多处提到<code>RefBase</code>，我们可以认为 <code>RefBase</code>是既支持强指针sp的也支持弱指针wp的对象类型，如果你定义的对象需要用到弱指针，请务必继承<code>RefBase</code>,而如果只使用强指针，你可以选择轻量级的<code>LightRefBase</code>也可以选择适应大多数情况的<code>RefBase</code></p><p>即<code>RefBase</code>不仅支持强指针还支持弱指针，它的源码定义位置: <code>frameworks/native/include/utils/RefBase.h</code><br>源码实现位置: <code>frameworks/native/libs/utils/RefBase.cpp</code>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//增加强引用计数器，强指针sp专用</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//减少强引用计数器，强指针sp专用</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//嵌套在 RefBase 内部，wp 中会操作该类型对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//增加弱引用计数器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//减少弱引用计数器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 用于创建一个weakref_type类型的对象，来处理弱引用关系</span></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();<span class="comment">//RefBase的构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase(); <span class="comment">//RefBase的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="comment">// 这些 Flag 参数 用来标记object的生命周期的，在 extendObjectLifetime 方法使用</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_impl</span>;</span></span><br><span class="line">    </span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;<span class="comment">//真实的处理引用关系的成员变量，不同于LightRefBase 的 Int类型的 mCount</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过分析 <code>RefBase</code>以及 <code>weakref_type</code> 的定义,发现 <code>RefBase</code>和<code>LightRefBase</code>的区别，虽然 <code>RefBase</code>和<code>LightRefBase</code>都提供了<code>incStrong</code>和<code>decStrong</code>成员函数来操作它的引用计数器,但 <code>RefBase</code>它不像<code>LightRefBase</code>类一样直接提供一个整型值（mutable volatile int32_t mCount）来维护对象的引用计数，前面我们说过，复杂的引用计数技术同时支持强引用计数和弱引用计数，在<code>RefBase</code>类中，这两种计数功能是通过其成员变量<code>mRefs</code>来提供的。  </p><p><code>mRefs</code>是<code>weakref_impl</code> 类型的,在<code>RefBase.h</code>文件中只定义了<code>weakref_impl</code>,具体实现在 <code>frameworks/native/libs/utils/RefBase.cpp</code> 中，在 RefBase.cpp 文件中还具体实现了<code>incStrong</code>,<code>decStrong</code>等方法，让我们一起来看看。   </p><p>首先我们分段分析一下 <code>mRefs</code>的<code>weakref_impl</code>类型实现。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span>:</span>:weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;<span class="comment">//继承 weakref_type</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;<span class="comment">//强引用计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;<span class="comment">//弱引用计数器</span></span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS <span class="comment">//宏DEBUG_REFS来区分DEBUG环境和正式环境</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// DEBUG环境下</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">        , mStrongRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mWeakRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)</span><br><span class="line">        , mRetain(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~weakref_impl()<span class="comment">//weakref_impl析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    ... 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//增加强引用计数器，这里使用了 mStrongRefs指针</span></span><br><span class="line">        addRef(&amp;mStrongRefs, id, mStrong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        addRef(&amp;mWeakRefs, id, mWeak);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ref_entry</span> //结构体 <span class="title">ref_entry</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ref_entry* next;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_REFS_CALLSTACK_ENABLED</span></span><br><span class="line">        CallStack <span class="built_in">stack</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">int32_t</span> ref;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">...<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       ...<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> Mutex mMutex;</span><br><span class="line">    ref_entry* mStrongRefs;<span class="comment">//用来做强引用记录</span></span><br><span class="line">    ref_entry* mWeakRefs; <span class="comment">//弱引用记录</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过查看源码实现，我们知道 <code>RefBase</code>不同于<code>LightRefBase</code>,它使用结构体<code>ref_entry</code>来记录引用关系。成员变量<code>mStrong</code>做强引用计数器，<code>mWeak</code>做弱引用计数器。  </p><p>回到 前面 wp 构造函数和 <code>=</code>运算符重载中，都调用了<code>RefBase.createWeak()</code>方法用来生成一个 <code>weakref_type</code> 实例，其实就是 <code>weakref_impl</code>。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::weakref_type* RefBase::createWeak(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">    mRefs-&gt;incWeak(id);</span><br><span class="line">    return mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RefBase.h</code>定义中，<code>mRefs</code>定义为 <code>weakref_impl</code> 类型,所以这里调用的是<code>weakref_impl中的incWeak()</code>方法  </p><p>mRefs 是在 RefBase对象初始化的时候就在构造方法中完成了赋值  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RefBase::RefBase()</span><br><span class="line">    : mRefs(new weakref_impl(this))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>mRefs</code>就是一个<code>weakref_impl</code> 实例。  当弱指针wp需要第一次初始化弱引用时，会直接返回 <code>mRefs</code>对象，并且 操作<code>mRefs</code>对象执行<code>incWeak()</code>方法，增加一次弱引用计数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::weakref_type::incWeak(const void* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;addWeakRef(id);</span><br><span class="line">    const int32_t c = android_atomic_inc(&amp;impl-&gt;mWeak);</span><br><span class="line">    ALOG_ASSERT(c &gt;= 0, &quot;incWeak called on %p after last weak ref&quot;, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，在<code>incWeak</code>方法中，调用了<code>weakref_impl</code>的<code>addWeakRef</code>，而 <code>addWeakRef</code>最终通过<code>addRef</code>实现:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void addRef(ref_entry** refs, const void* id, int32_t mRef)</span><br><span class="line">    &#123;</span><br><span class="line">        if (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">            ref_entry* ref = new ref_entry;</span><br><span class="line">            // Reference count at the time of the snapshot, but before the</span><br><span class="line">            // update.  Positive value means we increment, negative--we</span><br><span class="line">            // decrement the reference count.</span><br><span class="line">            ref-&gt;ref = mRef;</span><br><span class="line">            ref-&gt;id = id;</span><br><span class="line">#if DEBUG_REFS_CALLSTACK_ENABLED</span><br><span class="line">            ref-&gt;stack.update(2);</span><br><span class="line">#endif</span><br><span class="line">            ref-&gt;next = *refs;</span><br><span class="line">            *refs = ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实就是新创建一个ref_entry，把 弱引用指针 wp本身 包装在 一个 ref_entry 中，添加到单链表的ref_entry 数据结构中，建立弱引用链表。<br>将wp添加到弱引用链表之后，<code>incWeak</code>方法还通过<code>android_atomic_inc</code>增加了弱引用计数器<code>mWeak</code>的值。  </p><p>到目前为止，wp如何实现弱引用计数已经分析完成，总结一下:  </p><ol><li>wp 通过构造方法或重载运算符= 会调用 RefBase的createWeak方法，来创建一个weakref_type 也就是weakref_impl实例</li><li>weakref_impl 在RefBase对象构造的时候就已经创建好了，将 weakref_impl 对象返回给 wp</li><li>触发weakref_impl的incWeak 方法，将wp指针添加到弱引用链表中，并使用Android的原子操作方法，增加弱引用计数器 mWeak的值。</li></ol><p>前面说了，RefBase 不仅支持wp还像 LightRefBase 一样支持 强指针sp。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);<span class="comment">//增加弱引用计数器</span></span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_inc(&amp;refs-&gt;mStrong);<span class="comment">//增加强引用计数器，返回的是增加之前的值</span></span><br><span class="line">... 省略<span class="built_in">log</span></span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;<span class="comment">//判断是不是第一次被引用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是第一次被引用，需要调整一下 mStrong的值</span></span><br><span class="line">    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();<span class="comment">//是第一次被引用时，会回调 RefBase的onFirstRef()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码看出，RefBase的强引用增加引用时，会同时增加弱引用计数器。还会判断是否是第一次被引用。如果是第一次被引用需要修改强引用计数器<code>weakref_impl</code>中<code>mStrong</code>的值；<br>因为<code>weakref_impl</code>初始化的时候，<code>mStrong</code>被赋值为<code>INITIAL_STRONG_VALUE</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define INITIAL_STRONG_VALUE (1&lt;&lt;28)</span><br></pre></td></tr></table></figure><p><code>android_atomic_inc</code>方法是在 原 mStrong 的基础上加一，需要再减去 原始值<code>INITIAL_STRONG_VALUE</code>。  </p><p>下面我们在分析一下 RefBase对象什么时候被释放  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line">    ... <span class="comment">//省略 log</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;<span class="comment">//当引用数字当前是1时，会回调 RefBase的onLastStrongRef 方法</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//判断当前引用输入强引用关系时，会释放 对象</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);<span class="comment">//正常执行减小弱引用计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先减少强引用计数器mStrong,如果减少到0了(c ==1 ，因为c 返回的是上一次计数器的值)就执行 RefBase对象的 onLastStrongRef 方法，并且，如果当前引用类型是强引用，就释放引用的对象。  </p><p>因为<code>incStrong</code>中同步增加了弱引用计数器，同样，为了对称，<code>decStrong</code>时也应该调用<code>decWeak</code>。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;removeWeakRef(id);<span class="comment">//将弱引用指针wp从 弱引用链表中移除</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);<span class="comment">//减小弱引用计数器</span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decWeak called on %p too many times"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//该引用类型是强引用类型</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">//该对象从没有被强引用指针引用过，如果 弱引用都没有了，当然释放对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 最后一个强引用也消失的时候，这里释放 weakref_impl 对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//该引用类型是弱引用</span></span><br><span class="line">        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_&#123;WEAK|FOREVER&#125;</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//最后一个弱引用消失时，释放对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将弱引用指针wp从弱引用链表中移除，减小 <code>mWeak</code> 计数器; 如果当时是最后一个弱引用执行dec操作，会根据 <code>LIFETIME</code> 做不同的处理，具体看上述源码注释。 </p><p>前面多次提到，前引用增加时会同步的增加弱引用计数器，但是弱引用增加时肯定不会增加强引用计数器，所以弱引用计数器的值一定会大于强引用计数器，让程序走到这里的时候，弱引用计数器一定为0，而强引用计数器值有两种可能，一种就是  <code>INITIAL_STRONG_VALUE</code>即从来没有强引用指针引用，这种情况当然要释放对象；第二种就是在有强引用的情况下，强引用的<code>decStrong</code> 方法会释放<code>RefBase</code>对象，在这里只需要释放<code>weakref_impl</code>对象就行了，不需要再重复释放 <code>RefBase</code>对象。</p><p>总结:  </p><ol><li>Android中的智能指针分为<code>强指针sp</code>和<code>弱指针wp</code></li><li>有一个配合sp使用的<code>LightRefBase</code>，我们称之为<code>轻量级指针</code></li><li>通常和智能指针搭配使用的对象必须是 <code>RefBase</code> 类型，如果不需要 <code>弱指针wp</code>，可以使用轻量级的 <code>LightRefBase</code> 实现轻量级指针</li><li>对于 <code>RefBase</code> 对象而言，增加强引用也会同步的增加一个弱引用，反之不会。</li><li>弱指针要想访问对象，必须升级为强指针，通过弱指针wp的<code>promote</code>方法，最终调用<code>weakref_impl</code>的<code>attemptIncStrong</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是智能指针&quot;&gt;&lt;a href=&quot;#什么是智能指针&quot; class=&quot;headerlink&quot; title=&quot;什么是智能指针?&quot;&gt;&lt;/a&gt;什么是智能指针?&lt;/h3&gt;&lt;p&gt;Android 上层APP 基本都是基于Java 语言进行来发的，对于Java 语言来说是没有&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://aicodeing.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android进程间通信-Binder之初印象</title>
    <link href="http://aicodeing.github.io/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-Binder/"/>
    <id>http://aicodeing.github.io/Android进程间通信-Binder/</id>
    <published>2019-03-16T05:26:34.000Z</published>
    <updated>2019-05-29T11:19:08.288Z</updated>
    
    <content type="html"><![CDATA[<p>说到<code>Android</code>中进程间通信，应用最广泛的非<code>Binder</code>莫属。<br>在同一个进程空间中，内存虚地址的映射规则完全一致，他们在一个 虚地址空间中，所以两个函数互相调用很简单。但在两个不同的进程中，如我们的应用程序App和Framework中的<code>ActivityManagerService</code>进行函数调用，因为不在一个虚地址空间，所以没法直接通过内存地址访问到彼此的函数或变量。<br>如下图:  </p><p><img src="/img/binder/binder_mem_barrier.jpg" alt="">  </p><p>既然无法<code>直接</code>访问到对方进程的内存空间，那只能通过<code>间接</code>方式了，binder的职责就是帮助进程间接访问对方进程空间。  </p><p><img src="/img/binder/binder_desc.jpg" alt=""></p><p><code>Binder</code>是Android中使用最广泛的IPC机制，Binder 通信的组成元素有:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Binder驱动</span><br><span class="line">2. ServiceManager</span><br><span class="line">3. Binder Client</span><br><span class="line">4. Binder Server</span><br></pre></td></tr></table></figure><p>Binder 通信可以类比我们常见的网络通信<br>Binder 驱动相当于 网络请求中的路由器<br>ServiceManager 相当于网络请求中的DNS解析服务器<br>Binder Client相当于网络请求的客户端<br>Binder Service 相当于 处理网络请求的服务器</p><p>本篇文章主要目的是给出Binder 通信的整体印象，后续文章中会详细分析Binder 通信中各个组成元素如何实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到&lt;code&gt;Android&lt;/code&gt;中进程间通信，应用最广泛的非&lt;code&gt;Binder&lt;/code&gt;莫属。&lt;br&gt;在同一个进程空间中，内存虚地址的映射规则完全一致，他们在一个 虚地址空间中，所以两个函数互相调用很简单。但在两个不同的进程中，如我们的应用程序App和
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://aicodeing.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Linux-mmap</title>
    <link href="http://aicodeing.github.io/IPC-mmap/"/>
    <id>http://aicodeing.github.io/IPC-mmap/</id>
    <published>2019-03-03T15:09:56.000Z</published>
    <updated>2019-05-29T11:19:08.289Z</updated>
    
    <content type="html"><![CDATA[<p>在文章<a href="/Linux-SharedMemory/">Linux-共享内存(Shared Memory)</a>中介绍了通过<br><code>shmget</code>和<code>shmat</code> 实现开辟一块共享内存，两个或多个进程共享这一块内存区域；今天介绍一个类似的概念，<code>mmap</code>函数。  </p><p><code>mmap</code>函数 全名可以认为是<code>Memory Map</code>,可以将某个设备或者文件映射到应用进程的内存空间中，这样，访问这块内存就相当于对设备或文件进行读写，而不需要再通过 <code>read</code>和<code>write</code>了，所以由此可知，<code>mmap</code>也是支持进程间通信的，即通过映射同一块物理内存来共享内存。  虽然 <code>mmap</code>可以实现进程间通信，但是 <code>mmap</code>最出名的还是文件映射，即将一个物理硬盘上的文件映射到内存中，避免系统调用<code>read</code>和<code>write</code>。</p><p>为了便于理解 为何 避免了系统调用<code>read</code>和<code>write</code>就提升了效率，我们先看看普通的读写文件的原理。  </p><p>要读一个普通文件时，首先 进程调用<code>read</code>或是<code>write</code>后会陷入内核态，之后内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。  </p><p>Linux的内存映射函数<code>mmap</code>, 它把文件内容映射到一段内存上(准确说是虚拟内存上), 通过对这段内存的读取和修改, 实现对文件的读取和修改,<code>mmap()</code>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。</p><p>从前面的描述，不难发现 <strong><code>mmap</code>在最初并没有立马在物理内存上开辟空间，而 <code>共享内存shmget</code>和<code>shmat</code>正好相反，他们一开始就开辟了一份物理内存，而且这块是没有OOM的</strong></p><p><strong>区别:</strong><br><code>mmap</code>只是映射到虚地址空间上，并没有发生实际的copy，但访问这个文件的时候，内存发生了缺页中断，才会 copy 到 主存中，由于是虚地址空间，所以可操作的文件数据可以很多，大于物理主存，而且由于操作的可以是一个磁盘文件，所以读写速度肯定慢一些。<br><code>shmget</code>需要开劈一块实实在在的物理内存区域，受物理内存大小的影响，所以不能很大，不过由于操作的一直是内存，所以读写速度比较快。</p><p>假如我们想 进程A和进程B 都能读取一个硬盘上的文件，使用 <code>mmap</code>再合适不过了。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br></pre></td></tr></table></figure><p>这是 <code>mmap</code>函数的定义，先看看参数的意思:  </p><p><strong>addr：</strong> 指出文件或设备应该被映射到进程空间的哪个其实地址。这个参数如果为空,则由内核驱动自行决定被映射的地址。  </p><p><strong>length:</strong> 被映射到进程空间中内存块的大小<br><strong>prot</strong> 指被映射内存的访问权限  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROT_READ：内存页可读</span><br><span class="line">PROT_WRITE：内存页可写</span><br><span class="line">PROT_EXEC：内存页可执行</span><br><span class="line">PROT_SEM：内存页可用于atomic操作</span><br><span class="line">PROT_NONE：内存页不可访问</span><br></pre></td></tr></table></figure><p><strong>flags</strong> 指定程序对内存块的修改带来的影响</p><p><strong>fd</strong> 被映射到进程空间的文件的描述符<br><strong>offset</strong> 指定了从文件的哪一部分开始映射，一般为0</p><p><strong>返回值</strong> 成功时为0，否则错误码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在文章&lt;a href=&quot;/Linux-SharedMemory/&quot;&gt;Linux-共享内存(Shared Memory)&lt;/a&gt;中介绍了通过&lt;br&gt;&lt;code&gt;shmget&lt;/code&gt;和&lt;code&gt;shmat&lt;/code&gt; 实现开辟一块共享内存，两个或多个进程共享这一块内存
      
    
    </summary>
    
      <category term="Linux" scheme="http://aicodeing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://aicodeing.github.io/tags/Linux/"/>
    
      <category term="IPC" scheme="http://aicodeing.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Java-Stack Impl</title>
    <link href="http://aicodeing.github.io/Java-Stack-Impl/"/>
    <id>http://aicodeing.github.io/Java-Stack-Impl/</id>
    <published>2019-02-26T14:35:37.000Z</published>
    <updated>2019-05-29T11:19:08.291Z</updated>
    
    <content type="html"><![CDATA[<p>前几天给一个亲戚学生讲了下 计算机中栈的相关知识，记得在 <code>JDK</code>中也有 <code>Stack</code>的实现<code>java.util.Stack</code>它继承于 <code>Vector</code>类，是线程安全的。通过翻看源码发现，它是基于 <code>线性表</code>来实现的<code>Stack</code>, 而<code>Stack</code>最为我们熟知的还是使用<code>单链表</code>来实现。  </p><h3 id="基于-单链表实现-Stack"><a href="#基于-单链表实现-Stack" class="headerlink" title="基于 单链表实现 Stack"></a>基于 单链表实现 Stack</h3><p>下面我们来基于<code>单链表</code>来实现一个<code>Stack</code>  </p><p>先定义 <code>Stack</code>需要的必要方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然基于单链表来实现，就需要定义一个链表的结构  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        E value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整的 <code>StackWithLinkList</code>实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithLinkList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        E value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackWithLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头插法 实现 入栈操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        node.value = item;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            res = first.value;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素,不执行出栈操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很轻松的就基于 <code>单链表</code>实现了一个<code>栈</code>, 但在实现的过程中有一些小小的不爽，我们都知道，计算单链表中有多少个元素，就需要遍历一遍 链表，时间复杂度是<code>O(n)</code>，为了实现复杂度<code>O(1)</code>，我们只需加上计数器即可，其实 <code>JDK</code>中的<code>LinkedList</code>这种链表结构也是使用了计数器来实现<code>O(1)</code>复杂度的<code>size</code>计算。  </p><p>现在只需要在类中增加一个成员变量,并且在需要计数的地方，修改 计数器  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        node.value = item;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            res = first.value;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>JDK</code>中集合都采用了 <code>迭代器设计模式</code> 有一个 <code>iterator()</code>方法来隔离集合的遍历功能。我希望 <code>Stack</code>也拥有这个功能，于是乎开始动手  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; cursor = head.next;</span><br><span class="line">        Node&lt;E&gt; cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            E res = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res = cursor.value;</span><br><span class="line">                cur = cursor;</span><br><span class="line">                cursor = cursor.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从head 开始查找</span></span><br><span class="line">                Node tmp = head;</span><br><span class="line">                <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur == tmp.next) &#123;</span><br><span class="line">                        tmp.next = cur.next;</span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = tmp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用 <code>单链表</code>的特性，写出一个 <code>Iterator</code>还是比较顺畅的。<br>现在可以很Happy的添加<code>iterator()</code>方法啦  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="基于-线性表-实现-Stack"><a href="#基于-线性表-实现-Stack" class="headerlink" title="基于 线性表 实现 Stack"></a>基于 线性表 实现 Stack</h3><p>前面说到<code>JDK</code>是利用<code>线性表</code>实现的<code>Stack</code>,但是 <code>java.util.Stack</code>不能满足我们的要求，我首先查看了<code>JDK</code>中<code>java.util.Stack</code>的实现，发现它没有实现 <code>Iterator</code>,但可以使用父类<code>Vector</code>的<code>iterator()</code>方法，但不幸的是，它还是顺序的，没有实现<code>Stack</code>的<code>先进后出</code>。如果能实现一个 带反转功能的 <code>Iterator</code>就能完美解决问题啦。</p><p>那下面我们来实现一个基于<code>线性表</code>的<code>Stack</code><br>我们利用 <code>JDK</code>中已经完善的<code>ArrayList</code>来实现<code>Stack</code>,避免做太多与主题无关的实现。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E obj;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line">        obj = peek();</span><br><span class="line">        list.remove(len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line">        <span class="keyword">return</span> list.get(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要反转 iterator</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseJavaListIterator&lt;&gt;(list);</span><br><span class="line">        <span class="comment">//顺序 iterator</span></span><br><span class="line"><span class="comment">//        return new JavaListIterator&lt;&gt;(list);</span></span><br><span class="line"><span class="comment">//使用 ArrayList中自带的 iterator</span></span><br><span class="line"><span class="comment">//        return list.iterator();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>线性表</code>的<code>顺序性</code>和<code>连续性</code>，实现 <code>Stack</code>比较高效，直观。  为了避免 像<code>java.util.Stack</code>没有<code>Iterator</code>的尴尬，我们自己实现一个 具有反转功能的<code>Iterator</code>。  </p><p>为了同时兼容顺序的<code>Iterator</code>,首先写一个适配 <code>线性表</code>的 <code>Iterator</code>,以后可以扩展非 <code>List</code>实现的线性表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayLikeIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    ArrayLikeIterator() &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否反转遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bumpIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 &#123;<span class="doctag">@link</span> #isReverse()&#125;为 true， 需要重写该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 线性表实现的<code>Stack</code>使用的是 <code>java.util.List</code>,所有 继承<code>ArrayLikeIterator</code> 实现一个<code>JavaListIterator</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayLikeIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaListIterator</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.length = list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reviseIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isReverse()) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">indexInArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; length &amp;&amp; index &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">     * (In other words, returns &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #next&#125; would</span></span><br><span class="line"><span class="comment">     * return an element rather than throwing an exception.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexInArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next element in the iteration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="keyword">this</span>.bumpIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.remove(lastIndex());</span><br><span class="line">        resetLength();</span><br><span class="line">        reviseIndex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的<code>JavaListIterator</code> 其实还是<code>顺序迭代</code>的，为了实现我们带<strong>反转功能</strong>的<code>Iterator</code>，我们还得实现一个<code>ReverseJavaListIterator</code>，原理很简单，就是倒序遍历 <code>List</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseJavaListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">JavaListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReverseJavaListIterator</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(list);</span><br><span class="line">        <span class="keyword">this</span>.index = list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">indexInArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bumpIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-Stack"><a href="#测试-Stack" class="headerlink" title="测试 Stack"></a>测试 Stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stack&lt;Integer&gt; stack = new StackWithLinkList&lt;&gt;();</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> StackWithList&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"size="</span> + stack.size());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="number">2</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                System.out.println(<span class="string">"remove "</span> + next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---- print all ----"</span>);</span><br><span class="line">        System.out.println(<span class="string">"size="</span> + stack.size());</span><br><span class="line">        Iterator&lt;Integer&gt; iterator1 = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator1.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size=4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">remove 2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">---- print all ----</span><br><span class="line">size=3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>至此，我们基于 <code>单链表</code>和<code>线性表</code>的两种<code>Stack</code>实现方案测试通过。<br>其实还有很多需要完善的地方，比如多线程冲突修改问题，我们可以模仿 <code>JDK</code>,每次增删修改元素都使用<code>modCount</code>来记录，如果 <code>modCount != expectedModCount</code> 我们也可以抛出<code>ConcurrentModificationException</code>异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天给一个亲戚学生讲了下 计算机中栈的相关知识，记得在 &lt;code&gt;JDK&lt;/code&gt;中也有 &lt;code&gt;Stack&lt;/code&gt;的实现&lt;code&gt;java.util.Stack&lt;/code&gt;它继承于 &lt;code&gt;Vector&lt;/code&gt;类，是线程安全的。通过翻看源码
      
    
    </summary>
    
      <category term="Java" scheme="http://aicodeing.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://aicodeing.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android-Dex File</title>
    <link href="http://aicodeing.github.io/Android-Dex-File/"/>
    <id>http://aicodeing.github.io/Android-Dex-File/</id>
    <published>2019-02-25T06:35:48.000Z</published>
    <updated>2019-05-29T11:19:08.287Z</updated>
    
    <content type="html"><![CDATA[<p>文章<a href="/Android-Dalvik-And-ART/">Android-Dalvik And ART</a>中介绍了，<code>ART</code>和<code>Dalvik</code>两种虚拟机，这次介绍以下 他们的可执行文件 <code>.dex</code>。</p><h3 id="Dex-文件的生成"><a href="#Dex-文件的生成" class="headerlink" title="Dex 文件的生成"></a>Dex 文件的生成</h3><p><code>Android</code>开发，通常是使用 <code>Java</code>语言进行开发 (即使是 <code>Kotlin</code>最终也是编译成 Java 字节码)。而     <code>Java</code>文件的编译产物就是 <code>.class</code>字节码文件，而 Android的<code>Dalvik</code>虚拟机或 <code>ART</code>是不能直接运行 <code>.class</code> 文件的，需要将 <code>.class</code>文件转成 <code>.dex</code>文件。目前 Android 官方提供两种方式，一种是 <code>dx</code>工具，另一种是<code>d8</code>工具。<br>这两种编译工具在 Android SDK Platform 的 build-tools目录；<br>如: <code>your_sdk_path/build-tools/28.0.3</code>, <code>28.0.3</code>是 version，如果你有其他 version的编译工具，替换 version 即可。  在 该目录下，存在 <code>dx</code>和 <code>d8</code>两个可执行文件。    </p><h4 id="生成-class-文件"><a href="#生成-class-文件" class="headerlink" title="生成 class 文件"></a>生成 class 文件</h4><p>例如 我编写了一个Hi.java 文件  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String text = <span class="string">"Hi Class"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"main --&gt;"</span>);</span><br><span class="line">Hi hi = <span class="keyword">new</span> Hi();</span><br><span class="line">hi.print(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">System.out.println(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 <code>javac</code>命令把 <code>Hi.java</code> 文件编译换成 <code>Java</code> 字节码 <code>.class</code> 文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ javac Hi.java</span><br></pre></td></tr></table></figure><p>在当前目录生成文件 <code>Hi.class</code>，由于 class文件是 Java虚拟机的可执行文件，所以可以直接使用 <code>java</code> 命令执行  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ java Hi</span><br><span class="line">main --&gt;</span><br><span class="line">Hi Class</span><br></pre></td></tr></table></figure><h4 id="生成-dex-文件"><a href="#生成-dex-文件" class="headerlink" title="生成 dex 文件"></a>生成 dex 文件</h4><p>有了 <code>.class</code>文件之后，利用 <code>dx</code>或 <code>d8</code>工具生成 <code>.dex</code>文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dx --dex  --output=Hi.dex Hi.class</span><br></pre></td></tr></table></figure><p>生成 <code>Hi.dex</code>文件</p><p>或 使用 <code>d8</code>编译器:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ d8 Hi.class</span><br></pre></td></tr></table></figure><p>在当前目录生成了 <code>classes.dex</code>文件</p><p>这个 <code>.dex</code>文件就可以在Android 运行时环境直接执行。  </p><h3 id="Dex-文件"><a href="#Dex-文件" class="headerlink" title="Dex 文件"></a>Dex 文件</h3><p>现在分析一下 <code>Dex</code>的格式, <code>Dex</code>文件的定义在 <code>dalvik/libdex/DexFile.h</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure representing a DEX file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Code should regard DexFile as opaque, using the API calls provided here</span></span><br><span class="line"><span class="comment"> * to access specific structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* directly-mapped "opt" header */</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointers to directly-mapped structs and arrays in base DEX */</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader*    pHeader;</span><br><span class="line">    <span class="keyword">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="keyword">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="keyword">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="keyword">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="keyword">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">    <span class="keyword">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">    <span class="keyword">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These are mapped out of the "auxillary" section, and may not be</span></span><br><span class="line"><span class="comment">     * included in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>*         pRegisterMapPool;       <span class="comment">// RegisterMapClassPool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* points to start of DEX file data */</span></span><br><span class="line">    <span class="keyword">const</span> u1*           baseAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* track memory overhead for auxillary structures */</span></span><br><span class="line">    <span class="keyword">int</span>                 overhead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* additional app-specific data structures associated with the DEX */</span></span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图形化表示:  </p><p><img src="/img/dex/dex_struct.jpg" alt=""></p><p>在介绍之前，先铺垫一些符号的定义  </p><table><thead><tr><th>Name</th><th>Desc</th></tr></thead><tbody><tr><td>byte</td><td>8位的有符号数</td></tr><tr><td>ubyte</td><td>8位的无符号数</td></tr><tr><td>short</td><td>16位的有符号数</td></tr><tr><td>ushort</td><td>16位的无符号数</td></tr><tr><td>int</td><td>32位的有符号数</td></tr><tr><td>uint</td><td>32位的无符号数</td></tr><tr><td>long</td><td>64位的有符号数</td></tr><tr><td>ulong</td><td>64位的无符号数</td></tr><tr><td>sleb128</td><td>有符号的 LEB128格式,可变长度</td></tr><tr><td>uleb128</td><td>无符号的 LEB128格式，可变长度</td></tr><tr><td>uleb128p1</td><td>无符号的 LEB128格式 +1，可变长的</td></tr></tbody></table><p>什么是 <code>LEB128</code> 呢？ LEB128是小端数据格式，它用于任意有符号或无符号整数量的可变长度编码。在 dex 文件中，<code>LEB128</code>仅用于编码32位数量。<br>每个LEB128编码值由一到五个字节组成，它们一起代表一个32位值。除了最后一个字节之外，每个字节都有一个符号位，位于每个字节的最高位，其余的7位是 有效数据。这样的一个字节或多个字节就形成了 <code>LEB128数值</code>。  </p><p>对于一个LEB128的有符号数据(<code>sleb128</code>)，最后一个字节的最高位被拓展成为这个LEB128数值的最终有符号信息，1表示负数，0表示正数。对于一个无符号的LEB128数值(<code>uleb128</code>)，最后一个字节的最高位，无论是1还是0，始终看做0，以此表示无符号。</p><p><code>uleb128p1</code> 是 <code>uleb128</code>的变种，规则是：uleb128p1 + 1 = uleb128</p><p>既然是 小端数据格式，以 2字节举例: </p><p><img src="/img/dex/leb128_art.jpg" alt=""></p><p>回到Dex 文件的布局</p><h4 id="DexHeader"><a href="#DexHeader" class="headerlink" title="DexHeader"></a>DexHeader</h4><p>在 <code>DexFile</code> 中 第一块数据结构就是 <code>DexHeader</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped "header_item" struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* includes version number */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section */</span></span><br><span class="line">    u4  endianTag;</span><br><span class="line">    u4  linkSize;</span><br><span class="line">    u4  linkOff;</span><br><span class="line">    u4  mapOff;</span><br><span class="line">    u4  stringIdsSize;</span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>magic[8]</code></strong> 存储8字节的magic，用来标记 这是一个 Dex 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubyte[8] DEX_FILE_MAGIC = &#123; 0x64 0x65 0x78 0x0a 0x30 0x33 0x38 0x00 &#125;</span><br><span class="line">                        = &quot;dex\n038\0&quot;</span><br></pre></td></tr></table></figure><p><code>038</code>就是 Dex的版本号  添加的 <code>\n</code>和<code>\0</code>就是来区分 字符串 dex 和版本号的,<code>038</code>版本是Android 8.0 开始支持的。</p><p><strong>checksum</strong> 用于校验Dex 文件的，参与计算的数据是除了 magic 和checksum 两个字段外的所有数据  </p><p><strong>signature</strong> 除了 magic和 checksum 和 signature 外的部分的 SHA-1签名，用于唯一标识文件</p><p><strong>file_size</strong> 整个文件的大小</p><p><strong>header_size</strong> Header 部分的大小</p><p><strong>endian_tag</strong> 字节序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint ENDIAN_CONSTANT = 0x12345678; //大端序</span><br><span class="line">uint REVERSE_ENDIAN_CONSTANT = 0x78563412;//小端序，如果是小断序，需要反转成正常的大端序</span><br></pre></td></tr></table></figure><p><strong>link_size</strong> 链接部分的大小，如果此文件未静态链接，则为0</p><p><strong>link_off</strong> 从文件的开头到链接部分的偏移量，或者如果link_size == 0则为0.偏移量（如果非零）应该是link_data部分的偏移量</p><p><strong>map_off</strong> 从文件的开头到 map item 的偏移量。偏移量必须为非零，应该是数据部分的偏移量，data 应采用下面“map_list”指定的格式。</p><p><strong>string_ids_size</strong> 字符串标识符列表中的字符串数<br><strong>string_ids_off</strong> 从文件的开头到字符串标识符列表的偏移量，如果string_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是string_ids部分的开头。</p><p><strong>type_ids_size</strong> 类型标识符列表中的元素数，最多为65535</p><p><strong>type_ids_off</strong> 从文件开头到类型标识符列表的偏移量，如果type_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是type_ids部分的开头。</p><p><strong>proto_ids_size</strong> 原型标识符列表中的元素数，最多为65535<br><strong>proto_ids_off</strong> 从文件的开头到原型标识符列表的偏移量，如果proto_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是proto_ids部分的开头。</p><p>类似的 <code>field_ids_size</code>,<code>method_ids_size</code>,<code>class_defs_size</code>,<code>data_size</code> 分别对应着Dex File 不同的区域的大小。相应的<code>*_off</code>对应着从文件头到各自区域的偏移量</p><p>_提一句，Android上常见的 方法数 超过 65535 问题就是因为 <code>method_ids_size</code>使用无符号int来标识，而无符号int的最大范围是 65535。所以就限制了一个 Dex 文件中最多只能索引 65535 个方法。所以 后期的版本，Google 采用了分割 Dex 的方式解决这个问题。_</p><h4 id="DexStringId-Section"><a href="#DexStringId-Section" class="headerlink" title="DexStringId Section"></a>DexStringId Section</h4><p>该区域存储 字符串标识符列表。存储着使用的所有字符串的标识符，如代码引用的常量对象。</p><h4 id="DexTypeId-Section"><a href="#DexTypeId-Section" class="headerlink" title="DexTypeId Section"></a>DexTypeId Section</h4><p>存储着 类型标识符列表。<br>这些是此文件引用的所有类型（类，数组或基本类型）的标识符，无论是否在文件中定义。<br>此列表必须按字符串索引排序，并且不得包含任何重复的条目</p><h4 id="DexFieldId-Section"><a href="#DexFieldId-Section" class="headerlink" title="DexFieldId Section"></a>DexFieldId Section</h4><p>存储字段标识符列表。<br>这些是此文件引用的所有字段的标识符，无论是否在文件中定义。<br>必须对此列表进行排序，其中定义类型（通过type_id索引）是主要顺序，字段名称（通过string_id索引）是中间顺序，类型（通过type_id索引）是次要顺序。<br>该列表不得包含任何重复的条目。</p><h4 id="DexMethodId-Section"><a href="#DexMethodId-Section" class="headerlink" title="DexMethodId Section"></a>DexMethodId Section</h4><p>方法标识符列表。<br>这些是此文件引用的所有方法的标识符，无论是否在文件中定义。<br>必须对此列表进行排序，其中定义类型（通过type_id索引）是主要顺序，方法名称（通过string_id索引）是中间顺序，方法原型（通过proto_id索引）是次要顺序。<br>该列表不得包含任何重复的条目。</p><h4 id="DexProtoId-Section"><a href="#DexProtoId-Section" class="headerlink" title="DexProtoId Section"></a>DexProtoId Section</h4><p>方法原型标识符列表。<br>这些是此文件引用的所有原型的标识符。<br>此列表必须按返回类型（按type_id索引）主要顺序排序，然后按参数列表排序（词典排序，按type_id索引排序的各个参数）。<br>该列表不得包含任何重复的条目。</p><p>proto 的意思是 method prototype 代表 java 语言里的一个 method 的原型 。proto_ids 里的元素为 proto_id_item，结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Direct-mapped &quot;proto_id_item&quot;.</span><br><span class="line"> */</span><br><span class="line">struct DexProtoId &#123;</span><br><span class="line">    u4  shortyIdx;          /* index into stringIds for shorty descriptor */</span><br><span class="line">    u4  returnTypeIdx;      /* index into typeIds list for return type */</span><br><span class="line">    u4  parametersOff;      /* file offset to type_list for parameter types */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>包含 方法名称，方法的返回值，参数。</p><h4 id="DexClassDef-Section"><a href="#DexClassDef-Section" class="headerlink" title="DexClassDef Section"></a>DexClassDef Section</h4><p>类定义列表。<br>必须对类进行排序，使得给定类的超类和实现的接口在引用类之前出现在列表中。</p><h4 id="Data-Section"><a href="#Data-Section" class="headerlink" title="Data Section"></a>Data Section</h4><p>数据区，包含上面列出的表的所有支持数据。</p><h4 id="Link-Data"><a href="#Link-Data" class="headerlink" title="Link Data"></a>Link Data</h4><p>静态链接文件中使用的数据。</p><h3 id="分析-Hi-dex"><a href="#分析-Hi-dex" class="headerlink" title="分析 Hi.dex"></a>分析 Hi.dex</h3><p>使用编辑器打开 <code>Hi.dex</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">6465 780a 3033 3500 *(magic) 4e7d 2ba4 *(checksum) b499 ca35</span><br><span class="line">ee34 b9d6 94de 96e8 a865 9759 ae06 7dee *(signature)</span><br><span class="line">bc03 0000 *(file_size) 7000 0000 *(header_size) 7856 3412 *(endian_tag) 0000 0000 *(link_size)</span><br><span class="line">0000 0000 *(link_off) 1003 0000 *(map_off) 1300 0000 *(string_ids_size) 7000 0000 *(string_ids_off)</span><br><span class="line">0700 0000 *(type_ids_size) bc00 0000 *(type_ids_off) 0300 0000 d800 0000</span><br><span class="line">0200 0000 fc00 0000 0600 0000 0c01 0000</span><br><span class="line">0100 0000 3c01 0000 6002 0000 5c01 0000</span><br><span class="line">0602 0000 1002 0000 1802 0000 2202 0000</span><br><span class="line">2b02 0000 3102 0000 4802 0000 5c02 0000</span><br><span class="line">7002 0000 8402 0000 8702 0000 8b02 0000</span><br><span class="line">a002 0000 a602 0000 b002 0000 b502 0000</span><br><span class="line">bc02 0000 c502 0000 cb02 0000 0400 0000</span><br><span class="line">0500 0000 0600 0000 0700 0000 0800 0000</span><br><span class="line">0900 0000 0b00 0000 0900 0000 0500 0000</span><br><span class="line">0000 0000 0a00 0000 0500 0000 f801 0000</span><br><span class="line">0a00 0000 0500 0000 0002 0000 0000 0300</span><br><span class="line">1100 0000 0400 0100 0e00 0000 0000 0000</span><br><span class="line">0000 0000 0000 0000 0100 0000 0000 0200</span><br><span class="line">0c00 0000 0000 0100 0f00 0000 0100 0100</span><br><span class="line">1000 0000 0200 0000 0100 0000 0000 0000</span><br><span class="line">0100 0000 0200 0000 0000 0000 0300 0000</span><br><span class="line">0000 0000 f202 0000 0000 0000 0100 0000</span><br><span class="line">0000 0000 ec01 0000 0500 0000 1a00 0200</span><br><span class="line">6900 0000 0e00 0000 0100 0100 0100 0000</span><br><span class="line">e001 0000 0400 0000 7010 0500 0000 0e00</span><br><span class="line">0200 0100 0200 0000 e401 0000 1200 0000</span><br><span class="line">6201 0100 1a00 0d00 6e20 0400 0100 2201</span><br><span class="line">0000 7010 0100 0100 6200 0000 6e20 0300</span><br><span class="line">0100 0e00 0300 0200 0200 0000 f001 0000</span><br><span class="line">0600 0000 6200 0100 6e20 0400 2000 0e00</span><br><span class="line">0100 0e00 0601 000e 785a 5a00 0300 0e00</span><br><span class="line">0c01 000e 5a00 0000 0100 0000 0300 0000</span><br><span class="line">0100 0000 0600 083c 636c 696e 6974 3e00</span><br><span class="line">063c 696e 6974 3e00 0848 6920 436c 6173</span><br><span class="line">7300 0748 692e 6a61 7661 0004 4c48 693b</span><br><span class="line">0015 4c6a 6176 612f 696f 2f50 7269 6e74</span><br><span class="line">5374 7265 616d 3b00 124c 6a61 7661 2f6c</span><br><span class="line">616e 672f 4f62 6a65 6374 3b00 124c 6a61</span><br><span class="line">7661 2f6c 616e 672f 5374 7269 6e67 3b00</span><br><span class="line">124c 6a61 7661 2f6c 616e 672f 5379 7374</span><br><span class="line">656d 3b00 0156 0002 564c 0013 5b4c 6a61</span><br><span class="line">7661 2f6c 616e 672f 5374 7269 6e67 3b00</span><br><span class="line">046d 6169 6e00 086d 6169 6e20 2d2d 3e00</span><br><span class="line">036f 7574 0005 7072 696e 7400 0770 7269</span><br><span class="line">6e74 6c6e 0004 7465 7874 0025 7e7e 4438</span><br><span class="line">7b22 6d69 6e2d 6170 6922 3a31 2c22 7665</span><br><span class="line">7273 696f 6e22 3a22 7631 2e30 2e33 3522</span><br><span class="line">7d00 0100 0301 000a 0088 8004 dc02 0181</span><br><span class="line">8004 f802 0109 9003 0301 c403 0000 0000</span><br><span class="line">0e00 0000 0000 0000 0100 0000 0000 0000</span><br><span class="line">0100 0000 1300 0000 7000 0000 0200 0000</span><br><span class="line">0700 0000 bc00 0000 0300 0000 0300 0000</span><br><span class="line">d800 0000 0400 0000 0200 0000 fc00 0000</span><br><span class="line">0500 0000 0600 0000 0c01 0000 0600 0000</span><br><span class="line">0100 0000 3c01 0000 0120 0000 0400 0000</span><br><span class="line">5c01 0000 0320 0000 0400 0000 e001 0000</span><br><span class="line">0110 0000 0200 0000 f801 0000 0220 0000</span><br><span class="line">1300 0000 0602 0000 0020 0000 0100 0000</span><br><span class="line">f202 0000 0310 0000 0100 0000 0c03 0000</span><br><span class="line">0010 0000 0100 0000 1003 0000</span><br></pre></td></tr></table></figure><p><code>6465 780a 3033 3500</code> 对应的 <code>0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00</code><br> = <code>&quot;dex\n035\0&quot;</code> 说明 我使用 的 <code>dx</code> 编译器 使用的Dex 版本是 <code>035</code></p><p>在 以上数据中，我使用*(name)做了部分分割，只有明确 Dex 文件的结构，读懂 Dex 文件也不是那么的难了，有了 这个基础之后，以后就可以明白 各种热修复框架的实现思路了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章&lt;a href=&quot;/Android-Dalvik-And-ART/&quot;&gt;Android-Dalvik And ART&lt;/a&gt;中介绍了，&lt;code&gt;ART&lt;/code&gt;和&lt;code&gt;Dalvik&lt;/code&gt;两种虚拟机，这次介绍以下 他们的可执行文件 &lt;code&gt;.dex&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="Dalvik" scheme="http://aicodeing.github.io/tags/Dalvik/"/>
    
      <category term="Dex" scheme="http://aicodeing.github.io/tags/Dex/"/>
    
  </entry>
  
  <entry>
    <title>Android-Dalvik And ART</title>
    <link href="http://aicodeing.github.io/Android-Dalvik-And-ART/"/>
    <id>http://aicodeing.github.io/Android-Dalvik-And-ART/</id>
    <published>2019-02-25T04:01:56.000Z</published>
    <updated>2019-05-29T11:19:08.287Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉 <code>Android</code>的都知道， <code>Android</code> 应用程序的开发 通常采用 <code>Java</code>语言进行开发，不同于 <code>Java</code> 的是，<code>Java</code> 环境编译后的生成的是 <code>.class</code>文件，而 Android 的 可执行文件是 <code>.dex</code>文件(Dalvik Executable)，它是 <code>.class</code>文件经过 工具<code>dx</code>处理后的文件格式，可被 <code>Dalvik</code>虚拟机直接运行(目前 都转为使用更先进的<code>d8</code>编译器来处理 <code>.class</code>文件来生成 <code>.dex</code>文件)。执行这些 <code>dex</code>文件的 运行环境就是 <code>Dalvik</code>，后来Google 推出了更先进的 <code>ART</code>。  </p><p><code>ART</code>和<code>Dalvik</code>是服务于Android应用和Android系统服务的.<code>Dalvik</code>在Android项目一开始的时候就被引入，而<code>ART</code>在<code>Android4.4</code>的时候被引入，并对开发人员可见，在<code>Android 5.0</code>的时候，<code>ART</code>虚拟机这个是成为默认的虚拟机。 <code>ART</code>的推出就是为了替代<code>Dalvik</code>虚拟机来获得更好的性能的。<code>ART</code>和 <code>Dalvik</code>都支持运行 <code>dex</code>字节码，因此为 <code>Dalvik</code>开发的应用程序，也可以直接被 <code>ART</code>虚拟机运行(当然有一些Dalvik的技术特性不被支持了，比如 显示的调用<code>System.gc()</code>，具体可参考<a href="https://developer.android.com/guide/practices/verifying-apps-art.html" target="_blank" rel="noopener">Verifying App Behavior on the Android Runtime (ART)</a>)。  </p><h3 id="ART-的新特性"><a href="#ART-的新特性" class="headerlink" title="ART 的新特性"></a>ART 的新特性</h3><h4 id="AOT编译-–-Ahead-of-time-AOT-compilation"><a href="#AOT编译-–-Ahead-of-time-AOT-compilation" class="headerlink" title="AOT编译 – Ahead-of-time (AOT) compilation"></a>AOT编译 – Ahead-of-time (AOT) compilation</h4><p>ART引入了提前（AOT）编译，可以提高应用程序性能。 ART还具有比Dalvik更严格的安装时间验证。<br>在安装App时，ART使用设备上的<code>dex2oat</code>工具编译应用程序。此实用程序接受<code>DEX</code>文件作为输入，并为目标设备生成已编译的应用程序可执行文件<code>.oat</code>,由于<code>Dalvik</code>虚拟机使用了这么多年，整个系统中可能很多地方硬编码使用了<code>.odex</code>文件，为了无缝的替换<code>Dalvik</code>虚拟机，通过<code>dex2oat</code>生成的 <code>.oat</code>文件在有些地方可能会命名为<code>.odex</code>。<br>例如/data/app/{pkg}/oat/{cpuType}下,在我的手机上是<code>/data/app/{pkg}-xxx/oat/arm64/</code>，目录下的文件是以 <code>.odex</code>结尾。<br>虽然名字是<code>.odex</code>,但是不同于通过<code>dex2opt</code>生成的<code>.odex</code>文件。<code>dex2oat</code>输出的<code>.odex</code>文件其实就是 <code>.oat</code>文件，是 elf文件格式，里面包含着本地机器码。<br><mark>由于是针对 当前设备的，所以生成的可执行文件不能被别的机器使用。</mark>  </p><p>随便说一下，<code>/data/app/{pkg}/oat/{cpuType}</code> 目录下 可能还包含<code>.art</code>和 <code>.vdex</code>文件。 <code>.vdex</code> 这是<code>Android8</code>引入的，它存储是 app 安装时执行 <code>dex2oat</code>经过验证后的dex文件，以后可以使用<code>.vdex</code>文件，避免再次验证Dex文件的合法性。<br><code>.art</code>文件 主要存储apk 启动的热点函数相关地址的记录，方便寻址相关；该文件不会在程序安装时就生成，而是运行了一段时间后，收集到了足够过的JIT热点方法信息，会再次进行<code>dex2oat</code>，将热点方法编译成<code>native code</code>,这就是<code>.art</code>文件的作用。</p><h4 id="改进GC机制"><a href="#改进GC机制" class="headerlink" title="改进GC机制"></a>改进GC机制</h4><p>参考之前的<a href="/JVM-垃圾收集器/">JVM-垃圾收集器</a>一文，JVM 的垃圾收集器往 并发收集方向前进，同样，为了尽量减少GC对 用户进程的卡顿影响，改进的GC机制也采用了并行收集和并发处理。  </p><p><code>ART</code>虚拟机 默认使用的垃圾收集器是 <code>CMS</code>收集器，我们知道 <code>CMS</code>收集器采用的是<code>标记-清除</code>算法，没有<code>内存-整理</code>，所以 当 Android 应用程序进入后台后 缓存状态时，虚拟机会执行 <code>堆内存压缩整理</code>，减少内存碎片的产生。</p><p>除了垃圾收集器的升级换代，针对内存的分配方面，<code>ART</code>也引入了全新的 基于 位图的内存分配器，称为RosAlloc（插槽分配器)。这个新的分配器具有分片锁定，针对小内存分配，增加了 <code>Thread Local</code>的 buffers，提高 小内存的分配性能。</p><h4 id="开发和调试改进"><a href="#开发和调试改进" class="headerlink" title="开发和调试改进"></a>开发和调试改进</h4><p>ART提供了许多功能来改进应用程序开发和调试。比如:  </p><ul><li>支持 <code>采样分析</code></li><li>增加更多的 虚拟机调试功能，比如可以通过<code>ART</code>知道 一个给定的 Class 有多少个实例，已经对象的引用状态</li><li>改进了异常和崩溃报告中的诊断细节</li></ul><h4 id="ART的JIT编译器"><a href="#ART的JIT编译器" class="headerlink" title="ART的JIT编译器"></a>ART的JIT编译器</h4><p>我们知道 在 <code>Android 2.2</code> 的时候，为了提升 <code>Dalvik</code>的性能，引入了<code>JIT（Just-In-Time ）</code>技术。这是一种在 运行时 编译 频繁使用的 Class，成为 <code>native code</code> 机器码，提升 效率，免得在程序运行期间 每次都重新翻译成 机器码的尴尬。但是这个性能提升也不是绝对的，比如 Class 中的大部分代码执行较少，那么JIT编译花费的时间不一定少于执行dex的时间。所以 <code>JIT</code>不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码。而且，<code>JIT</code>将 dex 字节码编译成native code 是发生在程序运行期间的，而且生成的 <code>native code</code> 也不是一劳永逸的，下次运行，还是需要重新执行<code>JIT</code> 过程。</p><p>使用过早期Nexus5 搭配 Android5.0的人可能知道，安装一个App，简直是龟速，其实就是安装的时候如果全量编译成机器码很耗时，为了照顾安装效率，就取消了全量编译，这时候再引入 <code>JIT</code> 就很有意义了，针对比较热门的代码，使用<code>JIT</code>编译成 native code，<br>所以在 <code>ART</code> 中实现了 <code>JIT</code>编译器是很有必要的，在Android7.0中重新引入了<code>ART</code>下的<code>JIT</code>技术。  </p><p>以下是 <code>JIT</code>在 <code>ART</code>系统中的结构示意图</p><p><img src="/img/art/art-jit-arch.png" alt=""></p><p>可以看出，如果 <code>ART</code> 虚拟机 面对 非 <code>oat</code>可执行文件时，还是有必要的。</p><p>以下是 <code>JIT</code>的工作流程示意图:  </p><p><img src="/img/art/jit-workflow.png" alt=""></p><p><code>JIT</code>是运行时编译，是动态编译，<code>AOT</code>可以被认为是静态编译，二者配合和互补，在效率做平衡。</p><p>当然也可以不适用 <code>JIT</code>，可以通过以下命令禁止: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.usejit false</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure><p><a href="https://source.android.com/devices/tech/dalvik" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;熟悉 &lt;code&gt;Android&lt;/code&gt;的都知道， &lt;code&gt;Android&lt;/code&gt; 应用程序的开发 通常采用 &lt;code&gt;Java&lt;/code&gt;语言进行开发，不同于 &lt;code&gt;Java&lt;/code&gt; 的是，&lt;code&gt;Java&lt;/code&gt; 环境编译后的生
      
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="Dalvik" scheme="http://aicodeing.github.io/tags/Dalvik/"/>
    
      <category term="ART" scheme="http://aicodeing.github.io/tags/ART/"/>
    
  </entry>
  
  <entry>
    <title>Linux-共享内存(Shared Memory)</title>
    <link href="http://aicodeing.github.io/Linux-SharedMemory/"/>
    <id>http://aicodeing.github.io/Linux-SharedMemory/</id>
    <published>2019-02-24T04:00:49.000Z</published>
    <updated>2019-05-29T11:19:08.293Z</updated>
    
    <content type="html"><![CDATA[<p>之前<a href="/Linux-信号机制/">Linux-信号机制</a>这篇文章介绍了 <code>Linux</code>系统中的一个进程间通信方式- <code>信号机制</code>。这次我们来介绍以下 另一种进程间通信方式-<code>共享内存</code>。  </p><p>共享内存的原理是: <strong>两个进程可以直接访问同一块内存区域。</strong> 由于两个进程交互的数据在同一块内存区域，避免了 copy 操作，所以速度是比较快的。  </p><p>我们知道之所以划分进程这一概念，就是为了各个进程运行在各自独立的内存空间之中，避免了进程的非法访问和数据破坏。所以，共享内存肯定不是简单的，两个进程直接分配同一块内存区域。 它所占用的空间既不属于进程A 也不属于进程B，而是属于系统内核。 需要使用到 内存映射，将块所属内核的内存区域映射到两个进程之中。  如下图:  </p><p><img src="/img/share_mem/share_mem.jpg" alt=""></p><p>实现共享内存比较简单，只需要厦门几步:  </p><ol><li>创建内存共享区</li><li>映射内存共享区到进程空间</li><li>访问共享内存</li><li>对共享内存进行读写操作，也即进行进程间通信</li><li>撤销共享内存的进程映射</li><li>删除共享内存区域，回收内存</li></ol><h4 id="1-创建内存共享区"><a href="#1-创建内存共享区" class="headerlink" title="1. 创建内存共享区"></a>1. 创建内存共享区</h4><p>进程A 通过操作系统提供的API 从内存中申请一块共享区域，在Linux 环境中，可以通过 <code>shmget</code>函数来创建或获取共享内存区域  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * key：SHM 标识</span><br><span class="line"> * size：SHM 大小</span><br><span class="line"> * shmflg：创建或得到的属性，例如 IPC_CREAT</span><br><span class="line"> * return：成功返回 shmid，失败返回 -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br></pre></td></tr></table></figure><p><strong>参数 <code>key</code></strong>: 创建的内存区域会和给定的 <code>key</code>进行绑定，另外一个进程B 可以通过传入相同的 <code>key</code>来获取进程A创建的共享内存区域。在 以下两种key 的取值情况下，会创建一个新的内存共享区，否则就是返回已有的内存共享区  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. key 值为 `IPC_PRIVATE`  </span><br><span class="line">2. key不为 `IPC_PRIVATE` ，但是 另一个参数`shmflg `指定了 `IPC_CREATE`标记</span><br></pre></td></tr></table></figure><p><strong>参数 <code>size</code></strong>: 指定申请的共享内存的大小，以字节为单位， <mark>注意:</mark>Linux系统下，分配的内存大小都是页的整数倍</p><p><strong>参数shmflg</strong>: 有以下几种取值   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IPC_CREATE：申请新建区域</span><br><span class="line">IPC_EXCL：和 IPC_CREATE共同使用，如果指定的区域已经存在，则返回错误。</span><br><span class="line">mode_flags：同 open 函数的 mode 参数，用来指定 文件的权限</span><br><span class="line">SHM_HUGETLB：使用&quot;huge pages&quot;机制来申请</span><br><span class="line">SHM_NORESERVE: 此区域不保留 swap 空间</span><br></pre></td></tr></table></figure><p>对于 进程A要创建一个共享内存区域，参数 shmflg 设置为 <code>IPC_CREATE</code>即可。</p><p><strong>返回值</strong>: 是内存共享区域的id值，用于唯一标识该区域。进程需要映射该区域时 需要使用 此 id 值。</p><h4 id="2-映射内存共享区到进程空间"><a href="#2-映射内存共享区到进程空间" class="headerlink" title="2.映射内存共享区到进程空间"></a>2.映射内存共享区到进程空间</h4><p>将进程A申请创建的共享内存映射到进程A的进程空间中，需要使用 <code>shmat</code>函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmid：SHM ID</span><br><span class="line"> * shmaddr：SHM 内存地址</span><br><span class="line"> * shmflg：SHM 权限</span><br><span class="line"> * return：成功返回 SHM 的地址，失败返回 (void *) -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br></pre></td></tr></table></figure><p><strong>参数 shmid</strong>: 就是 共享内存区域的id值，由<code>shmget</code>函数返回的。  </p><p><strong>参数 shmaddr</strong>: 将内存共享区域映射到指定的地址，可以为 <code>0</code>,此时系统将自动分配地址  </p><p><strong>参数shmflg</strong>: 和 <code>shmget</code>方法中的 参数<code>shmflg</code> 一样。</p><p><strong>返回值</strong>: 如果成功执行后，返回该内存区域的其实地址</p><h4 id="3-访问共享内存"><a href="#3-访问共享内存" class="headerlink" title="3.访问共享内存"></a>3.访问共享内存</h4><p>经过前面 2 步，进程A 成功创建了 共享内存，并将共享内存区域映射到了 进程A的进程空间之中，那么现在 就该进程B 访问 共享内存区域了。进程B 就是利用 进程A 创建 内存空间时绑定的<code>key</code>,通过函数<code>shmget</code>来 获取 内存共享区域，然后再使用 <code>shmat</code>函数将共享内存区域也映射到进程B的空间中。</p><h4 id="4-进行进程间通信"><a href="#4-进行进程间通信" class="headerlink" title="4.进行进程间通信"></a>4.进行进程间通信</h4><p>这一步就是进程A或进程B 往 共享内存区域写入自己的信息，实现数据交换或者说实现通信。<mark>注意</mark>: 如果涉及到进程A和进程B 写入数据同步问题，还需要 进程A和进程B协议处理，因为 共享内存没有同步机制。往共享内存区域 copy 数据可以使用 函数<code>memcpy</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * dest: 指向用于存储复制内容的目标地址</span><br><span class="line"> * src: 指向要复制的数据源</span><br><span class="line"> * count: 要被复制的字节数</span><br><span class="line"> * return：返回一个指向目标存储区 dest 的指针</span><br><span class="line"> */</span><br><span class="line">void *memcpy(void *dest, const void *src, size_t count)</span><br></pre></td></tr></table></figure><h4 id="5-撤销内存映射"><a href="#5-撤销内存映射" class="headerlink" title="5.撤销内存映射"></a>5.撤销内存映射</h4><p>Linux中 使用 函数<code>shmdt</code>来解除当前进程与共享内存区域的映射关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmaddr：已经映射的 SHM 地址</span><br><span class="line"> * return：成功返回 0，失败返回 -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure><h4 id="6-删除共享内存区"><a href="#6-删除共享内存区" class="headerlink" title="6.删除共享内存区"></a>6.删除共享内存区</h4><p>经过第5步骤取消了 进程A和进程B 对共享内存的映射关系，如果不需要再次使用的话就可以释放掉 这块共享内存区域了，在Linux 系统中，可以通过 函数<code>shmctl</code>来实现。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmid：SHM ID</span><br><span class="line"> * cmd: 控制命令</span><br><span class="line"> * buf: 共享内存区域需要更新的数据，或需要写出的数据</span><br><span class="line"> * return：成功返回 0，否则 失败</span><br><span class="line"> */</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br></pre></td></tr></table></figure><p><strong>参数 cmd</strong>: 释放掉共享内存区域时需要执行的命令，可选值如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPC_STAT：状态查询，结果存入 参数buf</span><br><span class="line">IPC_SET: 在权限允许的情况下，将共享内存状态更新为 buf 中的数据</span><br><span class="line">IPC_RMID: 删除共享内存段</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>write_shm.c</code> </p><p>进程 A 创建 共享内存区域 并写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">// 1. 创建 SHM</span><br><span class="line">int shm_id = shmget(13, 2048, IPC_CREAT | 0666);</span><br><span class="line">if (shm_id != -1) &#123;</span><br><span class="line">// 2. 映射 SHM</span><br><span class="line">void* shm = shmat(shm_id, NULL, 0);</span><br><span class="line">if (shm != (void*)-1) &#123;</span><br><span class="line">// 3. 写 SHM</span><br><span class="line">char str[] = &quot;share memory&quot;;</span><br><span class="line">memcpy(shm, str, strlen(str) + 1);</span><br><span class="line">// 4. 关闭 SHM</span><br><span class="line">shmdt(shm);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perror(&quot;shmat:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perror(&quot;shmget:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程B 从共享内存中读取数据  </p><p><code>read_shm.c</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">// 1. 获取 SHM</span><br><span class="line">int shm_id = shmget(13, 2048, IPC_CREAT | 0666);</span><br><span class="line"></span><br><span class="line">if (shm_id != -1) &#123;</span><br><span class="line">// 2. 映射 SHM</span><br><span class="line">void* shm = shmat(shm_id, NULL, 0);</span><br><span class="line">if (shm != (void*)-1) &#123;</span><br><span class="line">// 3. 读取 SHM</span><br><span class="line">char str[50] = &#123; 0 &#125;;</span><br><span class="line">memcpy(str, shm, strlen(&quot;share memory&quot;));</span><br><span class="line">printf(&quot;shm = %s\n&quot;, (char *)shm);</span><br><span class="line">// 4. 关闭 SHM</span><br><span class="line">shmdt(shm);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perror(&quot;shmat:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perror(&quot;shmget:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (0 == shmctl(shm_id, IPC_RMID))</span><br><span class="line">printf(&quot;delete shm success.\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>gcc</code> 命令将 文件 <code>write_shm.c</code> 和 <code>read_shm.c</code> 编译成可执行文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc write_shm.c -o write_shm</span><br><span class="line">gcc read_shm.c -o read_shm</span><br></pre></td></tr></table></figure><p>先运行 <code>write_shm</code> 在运行 <code>read_shm</code>, <code>read_shm</code>执行后会输出 结果<br><code>share memory</code>。 这就意味着 我们成功的通过 共享内存实现了进程A 和进程B的通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前&lt;a href=&quot;/Linux-信号机制/&quot;&gt;Linux-信号机制&lt;/a&gt;这篇文章介绍了 &lt;code&gt;Linux&lt;/code&gt;系统中的一个进程间通信方式- &lt;code&gt;信号机制&lt;/code&gt;。这次我们来介绍以下 另一种进程间通信方式-&lt;code&gt;共享内存&lt;/code&gt;。
      
    
    </summary>
    
      <category term="Linux" scheme="http://aicodeing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://aicodeing.github.io/tags/Linux/"/>
    
      <category term="IPC" scheme="http://aicodeing.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾收集器</title>
    <link href="http://aicodeing.github.io/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://aicodeing.github.io/JVM-垃圾收集器/</id>
    <published>2019-02-18T06:29:52.000Z</published>
    <updated>2019-05-29T11:19:08.290Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇文章 <a href="/JVM-垃圾回收算法/">JVM-垃圾回收算法</a> 介绍了内存回收的 各种实现方案，这篇文章继续介绍一下 基于这些算法的 <strong>垃圾收集器的具体实现</strong> 。  </p><p>Java 虚拟机规范对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商，不同的版本的虚拟机所提供的垃圾收集器可能都不相同。目前商用的垃圾收集器大致如下图所示：  </p><p><img src="/img/jvm_gc/gc-garbage_collector.jpg" alt=""></p><p>在不同的 内存划分区域，使用不同的垃圾回收器 搭配使用。  </p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><code>Serial 收集器</code>是 <code>新生代</code> 内存区域，使用 <code>复制算法</code> 的最基本，最悠久的收集器。这个收集器是 <code>单线程</code>的收集器，它只会使用一个收集线程去完成垃圾收集工作，它在进行垃圾收集时，必须暂停其他工作线程，直到 GC 过程完成后，才重新恢复 工作线程。因此，这个收集器工作时，就会 产生 <code>Stop The World</code>的情况。  </p><p>对应的 <code>老年代</code>内存区域的回收算法 是 <code>Serial Old</code>收集器。它们工作的过程如下:  </p><p><img src="/img/jvm_gc/gc_serial.jpg" alt=""></p><p>可以看出，不管是 新生代还是老年代，用户线程和 GC 线程不能同时工作。  </p><p>竟然 <code>Serial收集器</code>是这么的低效率，那为什么还存在呢？ 其实在 特殊的场景下，该收集器还是有自己的优点的，比如在 Client 模式下，<code>Serial收集器</code>就是默认的新生代收集器。它简单，高效，对于单个Cpu和小内存的环境来说，<code>Serial收集器</code>由于没有线程交互的开销，可以获得最高的单线程收集效率。所以<code>Serial收集器</code>对于运行Client模式下的虚拟机来说是一个很好的选择。  </p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><code>ParNew收集器</code>其实就是 <code>Serial收集器</code>的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为和 <code>Serial收集器</code>完全一致。它的工作过程如下:  </p><p><img src="/img/jvm_gc/gc_parnew.jpg" alt=""></p><p>由于 <code>ParNew收集器</code>和 <code>Serial收集器</code>几乎一样，所以 他们两个都可以和 老年代的<code>Serial Old收集器</code>搭配使用。 </p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p><code>Parallel Scavenge收集器</code>也是作用在 <code>新生代</code>的 一款收集器,它也是使用 <code>复制算法</code>，并且和 <code>ParNew收集器</code>一样，也是并行的多线程收集器。看上去和 <code>ParNew收集器</code>没有什么不一样？  </p><p><code>Parallel Scavenge收集器</code>的特定是它与 其他收集器的关注点不同，<code>ParNew收集器</code>以及后面会讲的 老年代的 <code>CMS收集器</code>关注点都是 <strong>尽可能的缩短垃圾收集时用户线程的停顿时间</strong> 。而 <code>Parallel Scavenge收集器</code>的目标是达到一个可控制的<code>吞吐量</code>. 也就是CPU运行用户代码的时间与CPU总耗时的比值，即：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 用户代码运行时间 / (用户代码运行时间+GC时间)</span><br></pre></td></tr></table></figure><p>停顿时间越短就越适合需要与用户交互的程序，可以提升用户的体验，例如 Client模式下。  </p><p>而高吞吐量则可以高效的利用CPU时间尽快完成运算任务，主要适合在 后台运算，而不需要太多的交互。一般 Server 程序需要一个比较高的吞吐量。  </p><p><code>Parallel Scavenge收集器</code>有两个重要的可配置参数 <code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>。   </p><p><code>-XX:MaxGCPauseMillis</code>参数控制最大垃圾收集停顿时间，允许的值是一个大于0的毫秒数，收集器尽可能的保证内存回收花费的时间不超过设定的值。但 它和参数<code>-XX:GCTimeRatio</code>是互斥的。如果  <code>-XX:MaxGCPauseMillis</code>调小些，为了尽快完成回收，会把新生代区域的大小设定的比较小，就会导致 新生代会频繁的触发 GC。   </p><p><code>-XX:GCTimeRatio</code>参数设置 吞吐量的大小，它的值应当在 0 到100 之间，取整数。<br>如果要提高吞吐量，势必会 减少 GC的次数，那么 新生代的大小会大一些，并且每次GC的时间比较长。  </p><p>由于<code>Parallel Scavenge收集器</code>比较重视 提高吞吐量，所以 它也常被称为<code>吞吐量优先收集器</code>。一般不建议直接设置 参数 <code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>。建议使用<code>-XX:+UseAdaptiveSizePolicy</code>该参数的开启，虚拟机会根据当前系统的运行情况动态调整 GC 停顿时间和 吞吐量，也成为<code>GC自适应调整策略</code>。</p><p><strong>上面介绍的是 新生代的 垃圾收集器, 后面会谈下 老年代的收集器</strong></p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>刚才谈到 新生代的 收集器 <code>Serial收集器</code>的时候 提到了与之搭配的 老年代 收集器是 <code>Serial Old收集器</code>。它不同于<code>Serial收集器</code>使用的 <code>复制算法</code>，<code>Serial Old收集器</code>采用的是 <code>标记-整理</code>算法，它也是推荐在 Client模式下使用的。<br>在 Server 模式下，它也有特定的作用，比如和 新生代的 <code>Parallel Scavenge收集器</code>搭配使用；还有就是 当做 后面会讲到的 <code>CMS收集器</code>的 候补收集器。</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>同 <code>Serial Old收集器</code>是 <code>Serial收集器</code>在 老年代的 对应方案，<code>Parallel Old 收集器</code>是前面提到的<code>Parallel Scavenge收集器</code>在老年代的收集器版本。</p><p>它使用的也是多线程工作 和 <code>标记-整理</code>算法。<br>它与 <code>Parallel Scavenge收集器</code> 搭配使用的过程如下:  </p><p><img src="/img/jvm_gc/gc_parallel.jpg" alt=""></p><p>从图中可以看出，不管是老年代还是新生代，都使用并行GC线程进行收集。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>前面提到的 不管是 <code>Serial</code>收集器 还是 <code>Parall</code>收集器，他们虽然有的可以有多个GC线程进行回收，但都无法与用户线程<code>并发执行</code>。也就是说 GC过程中 <code>Stop The World</code> 还是一个上帝准则。  </p><p><code>CMS收集器</code>全称(Concurrent Mark Sweep) 作用于<code>老年代</code>内存区域，是第一款真正意义上的<code>并发收集器</code>，它实现了让用户线程与垃圾收集线程同时(几乎)工作。但 它只能和新生代中的 <code>Serial收集器</code>或 <code>ParNew收集器</code>搭配使用。</p><p><code>CMS收集器</code>是一种以获取最短回收停顿时间为目标的收集器。从名字中可以看出，它采用的是 <code>标记-清除</code>算法，它的整个GC 过程分为 4个步骤:</p><ul><li>初始化标记 (CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ul><p>其中第一步和第三步，任然需要<code>Stop The Work</code> 无法做到 完全并发。</p><p><mark>初始化标记</mark>: 仅仅是标记一下 GC Roots 能直接关联到的对象，所以速度很快。  </p><p><mark>并发标记</mark>: 就是进行 <code>GC Roots Tracing</code> 的过程(简历引用链),这部分是很耗时的。不过采用了并发操作，可以和用户线程同时运行，所以能大大提升 用户的卡顿情况。   </p><p><mark>重新标记</mark>:重新标记 是因为在 并发标记的过程中，由于用户线程在并发执行，可能导致一些对象的引用关系发生了变化，这个阶段就是 修正 标记结果。由于需要避免对象引用的再次改变，所以，这个步骤是 需要 <code>Stop The World</code>的，这里的耗时比 <code>初始化标记</code>耗时长，但远比 <code>并发标记</code>时间短。  </p><p><mark>并发清除</mark>:这个阶段就是 清除 无用的对象。由于这个过程是并发执行的，用户在这个过程中可能也改变了引用关系，所以 <code>CMS收集器</code>无法处理类似的 浮动垃圾,需要等到下一次GC 过程再处理。  </p><p><code>CMS收集器</code>的过程如下:  </p><p><img src="/img/jvm_gc/gc_cms.jpg" alt=""></p><p><strong>缺点:</strong>   </p><p><strong>内存使用率降低</strong><br>由于GC过程中，用户线程在并发执行，那就还需要预留足够的内存空间给用户线程使用，因此 <code>CMS 收集器</code>不能像其他收集器一样，等到 老年代 几乎被填满后再进行收集，需要预留一部分空间提供给并发的用户线程,所以 内存的利用率会稍微低一些，在 <code>JDK1.5</code>中默认设置下，CMS收集器 当 老年代使用了 68% 的空间就会触发GC。在后来的 <code>JDK1.6</code>中，CMS的<br>这个阈值提升到了 92%。要是在 CMS 运行期间，预留的内存无法满足程序使用了，就会触发 <code>Concurrent Mode Failure</code>的失败，这时候启用前面提到的备用方案<code>Serial Old收集器</code>。这样的话，停顿的时间就更长了，所以还是降低一下内存的使用了，来提升性能，也就是 <strong>空间换时间啦</strong> 。</p><p><strong>CPU吞吐量降低</strong><br>在 CMS收集器 并发阶段，虽然不会导致用户线程停顿，但是会因为 占用了一部分线程从而导致用户线程变慢，总吞吐量会有所降低。CMS模式的回收线程数是 <code>(CPU数+3)/4</code>,也就是说 当 CPU个数在4个以上时，并发回收线程会占用不少于 25%的CPU资源，并且随着CPU数量的增加而降低，如果 CPU的数量不足 4个，CMS 对用户程序的影响可能变得更大。</p><p>还有一个缺点: <code>CMS收集器</code> 采用的是 <code>标记-清除</code>算法，而非<code>标记-整理</code>算法，所以垃圾收集结束后，会产生内存碎片。碎片过多的时候，将会影响大对象的内存分配，这时候不得不进行一次 <code>Full GC</code>。为了解决这个问题 CMS 提供了一个参数 <code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，这个开关参数模式是开的。用于当 CMS 收集器 顶不住要进行 <code>FullGC</code>时 开启内存碎片的整理过程。而内存整理的过程是无法并发的，所以也会导致卡顿时间变长。</p><h2 id="最前沿的垃圾收集器"><a href="#最前沿的垃圾收集器" class="headerlink" title="最前沿的垃圾收集器"></a>最前沿的垃圾收集器</h2><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1(Garbage-First)收集器</code>是当今收集器技术发展的最前沿成果之一，在 <code>JDK1.7</code> 才正式商用。 这是一款面向 <code>Server 端</code>的垃圾收集器。它的目的是希望未来能替换 <code>CMS收集器</code>。<br>G1 收集器的特点:</p><ul><li>并行与并发:<code>G1</code> 能充分利用多CPU，多核心来缩短 <code>Stop The World</code>的时间</li><li>分代收集:<code>G1</code> 可以不需要其他收集器配合就能独立管理整个 GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活一段时间的老对象。</li><li>空间整合: 与 <code>CMS</code> 采用的<code>标记-清除</code>算法不同，G1 整体来看采用的是 <code>标记-整理</code>算法，从局部(两个<code>Region</code>之间)上来看是基于 <code>复制</code>算法来实现的，G1 运行期间，不会产生内存碎片。</li><li>可预测的停顿:与其他收集器相比，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为<code>M</code>毫秒的时间片段内，消耗在垃圾收集上的时间不得超过<code>N</code>毫秒。</li></ul><p>在 G1 之前的其他收集器进行回收的范围是整个新生代或老年代，而 G1 不是这样。它将堆内存划分为多个 大小相等的<code>独立Region</code>,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一些<code>Region</code>，这些<code>Region</code>可以不连续。</p><p>G1 收集器能建立可预测的停顿时间模型，是因为它可以进行有计划地避免整个Java堆中进行全区域的垃圾收集。 <strong>G1跟踪每个<code>Region</code> 回收所获得空间的大小，已经回收所需要的时间</strong> 。它在后台维护一个 <strong>优先级列表</strong> ，每次根据允许的收集时间， <strong>优先回收价值最大的Region。</strong> 这样有优先级的回收，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。  </p><p>G1 收集器的过程步骤大致划分为:  </p><ul><li>初始化标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><mark>初始化标记</mark>:与<code>CMS收集器</code>一样 需要 <code>Stop The World</code>，仅仅标记一下与 <code>GC Roots对象</code>直接关联的对象。 不同之处是，需要修改 <code>TAMS(Next Top at Mark Start)</code>的值，让下一阶段用户程序并发运行时，能在正确可用的 <code>Region</code>中创建新对象。</p><p><mark>并发标记</mark>:也是 从 <code>GC Roots</code> 开始对堆中的对象进行 引用链分析，该阶段可以与用户线程并发执行。</p><p><mark>最终标记</mark>:是为了修正 用户程序 并发期间，导致的对象引用变化，虚拟机将这段时间对象的变化记录在线程 <code>Remembered Set Logs</code> 里面，最终标记需要把 <code>Remembered Set Logs</code>的数据合并到 <code>Remembered Set</code>中。这个阶段也需要 <code>Stop The World</code>。<br>什么是 <code>Remembered Set</code>呢？有什么用？<br>我们前面说了，G1 把 堆内存分成大小相等的 <code>Region</code>，按照 <code>Region</code>的回收优先级来觉得回收哪些 Region，避免了全堆回收，但有可能出现 优先级 高的 Region 中对象引用了 其他Region中的对象。虚拟机都是通过<code>Remembered Set</code>来避免全堆扫描的。G1中 每一个Region都有一个与之对应的 <code>Remembered Set</code>，虚拟机发现程序对引用类型的数据进行操作时，会产生一个 <code>Write Barrier</code> 暂时中断写操作，检测 <code>Reference</code>引用的对象是否处于不同的Region之中，如果是，便通过<code>CardTable</code> 把相关引用信息记录到被引用对象所属的Region的<code>Remembered Set</code> 之中。当进行内存回收时，在GC 根节点的枚举范围中加入 <code>Remembered Set</code> 即可保证不对全堆扫描，也不会遗漏。  </p><p><mark>筛选回收</mark>:这个阶段首先会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p><p>一下是 G1的运行示意图:  </p><p><img src="/img/jvm_gc/gc_g1.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前 收集器种类比较多，适用场景也各不相同，所以，我们可以根据不同的使用场景来选择。虽然最新的 G1 收集器 比较先进，但目前使用范围并不是最广泛的，它的JDK9中才正式成为默认的垃圾收集器。</p><p><em>参考:</em> <a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">深入理解Java虚拟机</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一篇文章 &lt;a href=&quot;/JVM-垃圾回收算法/&quot;&gt;JVM-垃圾回收算法&lt;/a&gt; 介绍了内存回收的 各种实现方案，这篇文章继续介绍一下 基于这些算法的 &lt;strong&gt;垃圾收集器的具体实现&lt;/strong&gt; 。  &lt;/p&gt;
&lt;p&gt;Java 虚拟机规范对垃圾收集器应该
      
    
    </summary>
    
      <category term="JVM" scheme="http://aicodeing.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://aicodeing.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="http://aicodeing.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC Roots的枚举</title>
    <link href="http://aicodeing.github.io/JVM-GC%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://aicodeing.github.io/JVM-GC的实现/</id>
    <published>2019-02-18T02:14:22.000Z</published>
    <updated>2019-05-29T11:19:08.289Z</updated>
    
    <content type="html"><![CDATA[<p>在 前面一篇文章 <a href="/JVM-垃圾回收算法/">JVM-垃圾回收算法</a> 介绍了，目前的垃圾回收算法 都是用 <strong><code>可达性分析算法</code></strong> 来进行标记; 可达性分析从 <code>GC Roots</code> 对象节点查找引用链，而 <code>GC Roots</code> 对象 主要包含以下几种:  </p><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态变量引用的对象</li><li>方法区中常量引用的对象</li><li>Native方法栈中JNI引用的对象</li></ul><p>换句话说，    GC Roots     对象主要是全局性的引用(如，常量或 <code>static</code> 属性)和 执行栈帧中的 <code>Local 变量</code>。然而，这些地方是很庞大的，如果 全部枚举出 这些符合条件的<code>GC Roots</code> 对象节点，需要耗费很多的时间，这样势必导致用户线程卡顿时间较长，影响体验。  </p><p><code>GC Roots</code> 的枚举是GC 开始的第一步，在枚举 根节点的过程中，就会 <code>Stop the world</code> 。那么我们的目的就是尽量减少 用户线程的 <code>Stop</code> 时间</p><h2 id="枚举GC-Roots-对象"><a href="#枚举GC-Roots-对象" class="headerlink" title="枚举GC Roots 对象"></a>枚举GC Roots 对象</h2><p>既然枚举 <code>GC Roots</code> 对象比较 耗时，那有没有更好的办法呢？  </p><p>其实虚拟机在执行的过程中是肯定知道 哪些地方存放着对象引用的。在 <code>HotSpot</code> 的实现中，使用一组称为 <code>OopMap</code>的数据结构来达到这个目的的。当类加载完成的时候，<code>HotSpot</code> 就能计算出 <code>GC Roots</code> 引用,然后保存到 <code>OopMap</code> 数据结构中。当GC在扫描的时候，就可以直接使用这些信息了。</p><p><strong>问题:</strong><br>在 <code>OopMap</code>的协助下，虚拟机可以快速准确的完成 <code>GC Roots</code> 的枚举，能导致 引用关系变化的指令很多，如果为每一条指令都生成对应的<code>OopMap</code>，那就会需要大量的额外空间，这样GC的空间成本就会变得很高。  </p><h2 id="Safe-Point"><a href="#Safe-Point" class="headerlink" title="Safe Point"></a>Safe Point</h2><p>目前 的 HotSpot 其实只是在 <code>特定的指令位置</code>记录 引用信息，这个特定的位置就成为 <strong><code>安全点</code></strong>，即程序执行时并非在所有的地方都能停顿下来开始GC的，只有在 到达 <code>安全点</code> 时 才能暂停，等待 GC 线程的执行。安全点我们称为 <code>SafePoint</code>,它的选定 既不能太少 导致 GC 线程等待的时间太长，也不能太多，导致频繁的检测 GC 状态，增大运行时的负荷。  </p><p><code>SafePoint</code> 的选定基本上是以程序 <strong>是否具有让程序长时间执行的特征</strong> 为标准进行选定的。<code>长时间执行</code> 的最明显的特征就是 指令序列复用，例如 方法调用，循环跳转，异常跳转等。所以 具有这些功能 的指令才会产生 <code>SafePoint</code>。  </p><h3 id="SafePoint-的同步"><a href="#SafePoint-的同步" class="headerlink" title="SafePoint 的同步"></a>SafePoint 的同步</h3><p>当发生GC的时候，如何让 所有的线程跑到最近的 <code>SafePoint</code> 呢? </p><ul><li>抢先式中断</li><li>主动式中断</li></ul><p><mark>抢先式中断</mark> 不需要线程的执行代码主动去配合GC，在 GC 发生的时候，首先把所有线程全部中断，如果发现 线程中断的地方不在 <code>SafePoint</code>，就恢复该线程，让其跑到最近的 <code>SafePoint</code>上 再 停止。</p><p>抢先式 中断的一个问题就是 GC 过程需要干预用户线程的执行，目前虚拟机很少使用这种方式。</p><p><mark>主动式中断</mark> 不直接对线程进行操作，仅仅是简单的设置一个标志，各线程执行时主动去轮询这个标志，发现中断标志为 true 时 就自动中断挂起。所以 <strong>轮询标志的位置 和 安全点 是重合的</strong> 。由于创建对象需要分配内存时，由于容易引起GC，所以在 <strong>分配内存的指令地方</strong> ，也会设置中断标志。</p><h2 id="Safe-Region"><a href="#Safe-Region" class="headerlink" title="Safe Region"></a>Safe Region</h2><p>在用户线程执行的时候，肯定会进入 <code>SafePoint</code>，但如果用户现在目前在 <code>sleep</code> 就没法在 GC的时候跑到 安全点。对于这种情况，引入了 <code>Safe Region</code> 来解决。  </p><p><code>Safe Region</code> 是指 在一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方都可以开始GC，并且 GC 也是安全的。在线程执行到 <code>Safe Region</code> 的时候，首先标识自己已经进入了 <code>Safe Region</code>， 当这段时间<code>JVM</code> 要发起GC时，就不需要管 线程的状态了。只有在线程执行要离开 <code>Safe Region</code> 的时候，线程才需要检查自己是否已经完成了GC 过程。如果完成了，就继续执行，如果没有完成，就等待，直到收到 可以离开 <code>Safe Region</code>的信号为止。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>GC Roots</code> 对象节点的枚举是 GC 过程的第一步，为了尽快实现对 <code>GC Roots</code> 节点的枚举，引入了 <code>OopMap</code> 数据结构来存储 <code>GC Roots</code> 引用信息。为了减少不必要的 <code>Oop Map</code> 开销，使用了 <code>Safe Point</code>概念，为了解决 <code>SafePoint</code>的缺点，又引入了 <code>Safe Region</code> 概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 前面一篇文章 &lt;a href=&quot;/JVM-垃圾回收算法/&quot;&gt;JVM-垃圾回收算法&lt;/a&gt; 介绍了，目前的垃圾回收算法 都是用 &lt;strong&gt;&lt;code&gt;可达性分析算法&lt;/code&gt;&lt;/strong&gt; 来进行标记; 可达性分析从 &lt;code&gt;GC Roots&lt;/code
      
    
    </summary>
    
      <category term="JVM" scheme="http://aicodeing.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://aicodeing.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="http://aicodeing.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM-垃圾回收算法</title>
    <link href="http://aicodeing.github.io/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://aicodeing.github.io/JVM-垃圾回收算法/</id>
    <published>2019-02-14T10:18:05.000Z</published>
    <updated>2019-05-29T11:19:08.290Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收是Java 语言的一个重要特征，在Java 内存堆里面存放着JAVA 世界中几乎所有的对象实例，垃圾收集器在对堆内存就行回收前，第一件事就是要确定对象该不该被回收。那么垃圾收集器是如何判断一个对象是否需要被回收呢？  </p><h2 id="垃圾回收-标记算法"><a href="#垃圾回收-标记算法" class="headerlink" title="垃圾回收-标记算法"></a>垃圾回收-标记算法</h2><p>如何判断是否需要被回收呢？ 有几类算法:  </p><h4 id="1-引用计数器算法"><a href="#1-引用计数器算法" class="headerlink" title="1.引用计数器算法"></a>1.引用计数器算法</h4><p>大家最常提到的就是 给每个对象添加一个引用计数器，当增加一个引用的时候，计数器 <code>+1</code>，如果引用失效后，计数器 <code>-1</code>。<br>这种 计数方法看似效率很高，但是也有很严重的问题，所以目前 没有一个JVM 使用该算法。<br>主要原因就是 它 无法解决<strong><code>循环引用</code></strong>的问题。</p><h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h4><p>可达性分析就是通过定义一系列的 <code>GC Roots</code>对象，作为起始点，从这些起始节点往下搜索，而搜索经过的路径成为<code>引用链(Reference Chain)</code>，当一个对象到 <code>GC Roots</code> 没有任何引用链相连接，也就是从 <code>GC Roots 对象</code> 到这个对象不可达时，就说明该对象是不可用的，需要被回收。  </p><p>那么，哪些对象可以作为 <code>GC Roots 对象</code>呢？ 一般包括以下几种:</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态变量引用的对象</li><li>方法区中常量引用的对象</li><li>Native方法栈中JNI引用的对象</li></ul><p>为什么是这些对象呢？通过同性不难发现，他们的存活时间比较久，或者局部存活较久。</p><p>不管是通过 计数器算法还是可达性分析算法，来决定一个对象是否存活，都是针对的 <code>强引用类型</code>, <code>Java</code> 中还有其他引用类型，某些引用对象，即使通过垃圾回收算法判断不需要回收，但也有可能被GC回收。  </p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>Java 虚拟机中引用类型分为 <code>强引用(Strong Reference)</code>,<code>软引用 Soft Reference</code>,<code>弱引用 Weak Reference</code>,<code>虚引用Phantom Reference</code>。这四种引用类型的强度依次递减。  </p><ul><li><strong>强引用</strong>，就是写代码中常用的 如 <code>Object o = new Object()</code>类型的引用。只有引用还存在，垃圾回收器就永远不会回收被引用的对象。  </li><li><strong>软引用</strong>，是用来描述对象有用，但是也并不是必须的，在适当的时候，可以被回收，一般是在内存不足的时候，会触发 软引用对象的回收，但有<strong>一个特殊的就是 <code>Android 平台</code> 上，只要<code>GC</code> 经过，就会回收掉 软引用，并不会等到内存不足时</strong>。</li><li><strong>弱引用</strong>，也是来描述它是非必需的，但是它比 软引用更弱，被 弱引用引用的对象只能生存到下次GC发生之前。无论当前内存是否充足，都会回收掉弱引用关联的对象，它的声明周期是，从弱引用对象的建立，到 GC 来临之间的时间。</li><li><strong>虚引用</strong>，它也成为 <strong>幽灵引用</strong> ，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间带来影响，我们也无法通过虚引用来获取一个对象实例。那么虚引用的使用场景是什么呢？唯一的使用场景就是在对象被回收时，收到一个系统通知。</li></ul><p><strong>问题：如果一个对象在 回收算法中被认为是需要回收的对象,是否意味着一定会被回收呢？</strong></p><p>如果一个对象在经过<code>可达性分析算法</code>分析后发现没有与 <code>GC Roots</code>相连的引用链，那么它将会被标记并且进行一次 <mark>筛选</mark>。怎么筛选呢？ 其实就是筛选 有没有必要执行对象的 <code>finalize()</code>方法。当对象没有覆盖 <code>finalize()</code>方法，或者 <code>finalize()</code>方法已经在之前被 虚拟机调用过了，那这个对象就认为没有必要执行 <code>finalize()</code>,那这个对象就可以直接被回收了。<br>如果 通过 <code>筛选</code>，需要执行<code>finalize()</code>方法呢？其实虚拟机会把该对象放置在一个 队列之中，并且稍后会由虚拟机创建一个优先级很低的 <code>Finalizer 线程</code>去<code>执行</code>它。但这个执行并不会承诺一定等待<code>finalize()</code>方法执行完毕，因为如果在 <code>finalize()</code>方法中做耗时的操作将会影响队列中其他 对象的<code>finalize()</code>方法执行。但是我们可以在 <code>finalize()</code>方法中把 对象本身与 <code>GC Roots</code>关联上，这样在 GC 做第二次标记的时候，该对象将从 <code>即将回收</code>的集合中移除。如果没有做上述的关联操作，这个对象就会被立刻回收掉了。</p><p>我们知道，<code>JVM</code> 将内存 划分为几大块:<code>堆内存</code>,<code>方法区</code>,<code>虚拟机栈</code>,<code>Native栈</code>,<code>程序计数器</code>，那么刚才所说的 回收都只是在 <code>堆内存</code>这个分区上;  </p><p><strong>问题: 方法区也被称为永久代，这个区域是否存在垃圾回收机制呢？</strong>  </p><p>其实 Java 虚拟机规范中确实不要钱虚拟机在方法区进行回收，由于方法区的对象生命周期很长，而且 在 堆内存进行垃圾回收就能回收 大部分空间，那的确就没有必要在方法区进行垃圾回收了，但在 方法区 也是可以做垃圾回收的，一般回收的内容是: <code>废弃的常量</code>，和<code>无用的类</code>。  </p><p><strong>回收废弃的常量</strong> 和回收 <code>Java 堆</code>中的对象差不多，比如回收 常量池中的字符串 <code>“abc”</code>，如果当前系统中没有任何<code>String</code>对象引用常量池中的 <code>&quot;abc&quot;</code> 常量，也没有其他地方应用了这个字面量，如果需要执行方法区的垃圾回收的话，就可以把 <code>“abc”</code> 常量从常量池中清理掉。因为在 编译期就知道 常量池中的常量有没有被引用，所以 判断 一个常量字符串有没有被应用，也很容易。  </p><p><strong>回收类呢？</strong> 判断一个类 有用无用，分几个方面:</p><ul><li>该类所有的实例都已经被回收，在Java的堆内存中不存在该类的任何实例</li><li>加载该类的<code>ClassLoader</code>已经被回收或不存在</li><li>该类对应的 <code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类。</li></ul><p>只有满足 以上条件，就可以回收 方法区 中的类。</p><p>__刚谈了 <code>堆内存</code>和 <code>方法区</code>中对象 <mark>是否需要回收的问题，那么下面我们谈一下 如何回收的。</mark></p><h2 id="垃圾回收-回收算法"><a href="#垃圾回收-回收算法" class="headerlink" title="垃圾回收-回收算法"></a>垃圾回收-回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h3><p>这是最基础的收集算法，它分为 <code>标记</code>和<code>清除</code>两部分。在前面已经谈过 <code>标记</code>算法了。<br>这种最基础的 <code>标记-清除</code>算法，通过 标记 来确定，对象是否需要被回收，通过清除 来将对象占用的内存回收，那么显而易见，这个最基础的算法有两个很严重的问题:  </p><ul><li>效率低，标记过程是一个比较耗时的过程，同样沿着标记链，清除对应的内存区域，效率也不高</li><li>空间碎片化，直接清除对象占用的内存，会导致 产生大量的不连续的内存碎片，当碎片化很严重的时候，如果需要再分配大块内存，由于没有大块的内存可分配了，还是会触发 <code>GC</code>，但是同样无法解决问题.  </li></ul><p><img src="/img/jvm_gc/gc-mem_mark_sweep.jpg" alt="">  </p><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><p>该算法是 <code>标记-清除</code>算法的改进版, 它将内存按容量划分成大小相等的两块内存，每次只使用其中的一块。当一块内存用完了，就将还存活的对象复制到 另一块内存上，然后把之前的一块内存全部清理掉。这样每次都是对整个半区的内存进行回收，避免了内存的碎片化，而且新内存的申请，可以顺序分配，该实现方式简单，高效。<br>但很容易也发现，这种 算法的缺点是 ：<code>太浪费</code>,只能使用内存的<code>50%</code>。</p><h3 id="3-改进版的复制算法"><a href="#3-改进版的复制算法" class="headerlink" title="3.改进版的复制算法"></a>3.改进版的复制算法</h3><p>据调查，目前的商业虚拟机都是采用 这种算法来回收<code>新生代内存区</code>,IBM 研究表明，新生代中的对象 98% 都是 <code>&#39;朝生夕死&#39;</code>，所以并不需要按 <code>1:1</code>来划分内存空间。而是将内存分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，当回收时，将 <code>Eden</code> 和 <code>Survivor</code> 区(我们称为 <strong>Survivor From</strong>)中还存活的对象一次性复制到另一块 Survivor 空间(称为 <strong>Survivor To</strong>)上，最后清理掉 <code>Eden 和 Survivor From 空间</code>。 <code>HotSpot</code> 虚拟机默认 <code>Eden 和 Survivor</code> 的大小比例是 <code>8:1</code> 。改进后的这种复制算法，空间利用率达到了90%，只有10%的内存会被浪费掉。  </p><p>很明显，只要采用 类似的<code>复制算法</code>,就会有一个问题，如果 内存中存活的对象 很多呢，而不是 IBM 研究的 98%的可以释放呢？由于 <code>Survivor To</code> 的空间较小，不足以 存放 所有存活的对象。这样就无法达到回收效果。这就需要依赖其他内存，比如 存放在 老年代。(老年代的任务就是存放 <strong>大内存对象</strong>,<em><em>一般是超过 Survivor 的大小</em></em>, <strong>对象的年龄达到了老年标准的对象,也即声明周期长的对象</strong>, <strong>Survivor To 存储不下的对象</strong>)  </p><p><strong>一直在介绍的是 新生代 的回收算法，那么老年代肯定也需要做垃圾回收的。</strong></p><p>简单说明一下，老年代 由于对象声明周期比较长，比较问题，所以 触发GC的次数不会很频繁，老年代的 GC我们成为 <code>MajorGC</code>，新生代的GC 我们称为 <code>MinorGC</code>。在进行<code>MajorGC</code> 前 一般都会进行一次<code>MinorGC</code>，使得新生代的对象晋升到老年代，在 老年代空间不够的时候，才触发MajorGC。  </p><p>前面提到 目前的商业 虚拟机 新生代的 <code>MinorGC</code> 采用的都是 复制算法，而 老年代的 <code>MajorGC</code> 采用的是 容易产生 内存碎片的<code>标记-清除</code>算法。<code>MajorGC</code>的耗时比较长，因为为了解决 碎片化内存问题，每次 <code>标记-清除</code>后，都会进行<code>合并整理</code>内存。</p><p>如果老年代 也装不下了，就会抛出 <code>OOM</code> 异常了。</p><h3 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4.标记-整理算法"></a>4.标记-整理算法</h3><p>在刚才介绍 老年代 <code>MajorGC</code>时 提到了，<code>MajorGC</code> 采用的的 <code>标记-清除</code> + <code>内存的合并整理</code>。这其实就是 <code>标记-整理</code>算法。<br>标记-整理 算法就是在 标记-清除后，让所有存活的内存对象都向一端移动，然后直接清理掉端边界 以外的内存，标记-整理算法 如图:  </p><p><img src="/img/jvm_gc/gc-mem-arrange.jpg" alt=""> </p><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>通过前面的分析，我们发现没有一种算法是完美无缺的，我们只需要利用各种算法的优缺点，分情况使用，最大化各种算法的优点。<br>所以目前的商业虚拟机的垃圾回收算法 综合来说就是 <strong><code>分代收集算法</code></strong>。这种算法不是新的收集算法思路，而是综合各种算法的优点，根据对象存活周期的不同，将内存划分成几块，不同的块 使用不同的回收算法。</p><p>目前 商业虚拟机一般的做法是把内存划分为新生代，老年代:</p><ul><li>新生代 使用 <code>标记-复制算法</code></li><li>老年代使用 <code>标记-整理算法</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;垃圾回收是Java 语言的一个重要特征，在Java 内存堆里面存放着JAVA 世界中几乎所有的对象实例，垃圾收集器在对堆内存就行回收前，第一件事就是要确定对象该不该被回收。那么垃圾收集器是如何判断一个对象是否需要被回收呢？  &lt;/p&gt;
&lt;h2 id=&quot;垃圾回收-标记算法&quot;&gt;
      
    
    </summary>
    
      <category term="JVM" scheme="http://aicodeing.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://aicodeing.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="http://aicodeing.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Linux-信号机制</title>
    <link href="http://aicodeing.github.io/Linux-%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6/"/>
    <id>http://aicodeing.github.io/Linux-信号机制/</id>
    <published>2019-02-12T02:27:38.000Z</published>
    <updated>2019-05-29T11:19:08.296Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux</code>系统中 <code>信号机制</code>是进程间通信的其中一种方法，全称为<code>软中断信号</code>，也被称为<code>软中断</code>。不过 信号本质上是在软件层面上对硬件中断机制的一种模拟。<br>与Linux 系统中其他进程间通信方式(pipe，Shared Memory，Android系统的Binder)相比，信号所能传递的信息比较少，也比较粗糙，只是一个数字。但它也有自己的优点，由于传递的信息量少，所以更便于管理和使用，可以用于系统管理相关的任务，例如通知进程的终结，中止，恢复。  </p><p>每一个信号用一个证书常量宏来表示，以 <code>SIG</code>来开头,一下是常见的信号量。  </p><h2 id="常见的信号量类型"><a href="#常见的信号量类型" class="headerlink" title="常见的信号量类型"></a>常见的信号量类型</h2><table><thead><tr><th>信号量</th><th>Value</th><th>Desc</th><th>demo</th></tr></thead><tbody><tr><td>SIGABRT</td><td>6</td><td>进程发生错误或者调用了abort()</td><td>如在C库函数strlen，如果发生异常会调用abort()</td></tr><tr><td>SIGBUS</td><td>7</td><td>不存在的物理地址，硬件错误</td><td>例如系统错误或硬件出错</td></tr><tr><td>SIGFPE</td><td>8</td><td>浮点数运算错误</td><td>如除0操作，余0，整数溢出等</td></tr><tr><td>SIGILL</td><td>4</td><td>非法指令</td><td>损坏的可执行文件或者代码区损坏</td></tr><tr><td>SIGSEGV</td><td>11</td><td>段地址错误</td><td>空指针，访问不存在的地址空间，访问内核区，对只读空间进行写操作，栈溢出，数组越界，野指针</td></tr><tr><td>SIGPIPE</td><td>13</td><td>管道错误，往没有reader的管道中写操作</td><td>Linux 中的Socket，如果连接中断了，还继续写的情况下就会触发signal(SIGPIPE,SIG_IGN);</td></tr><tr><td>SIGHUP</td><td>1</td><td>终端挂起或控制进程终止。</td><td>当用户退出Shell时，由该进程启动的所有进程都会收到这个信号，默认动作为终止进程</td></tr><tr><td>SIGINT</td><td>2</td><td>键盘中断</td><td>当用户按下<ctrl+c>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</ctrl+c></td></tr><tr><td>SIGQUIT</td><td>3</td><td>键盘退出键被按下</td><td>当用户按下<ctrl+d>或<ctrl+\>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为退出程序。</ctrl+\></ctrl+d></td></tr><tr><td>SIGKILL</td><td>9</td><td>无条件终止进程.进程接收到该信号会立即终止，不进行清理和暂存工作。该信号不能被忽略、处理和阻塞，它向系统管理员提供了可以杀死任何进程的方法。</td><td>系统管理员无条件杀死任何进行</td></tr><tr><td>SIGALRM</td><td>14</td><td>定时器超时，默认动作为终止进程</td><td>–</td></tr><tr><td>SIGTERM</td><td>15</td><td>程序结束信号，可以由 kill 命令产生。与SIGKILL不同的是，SIGTERM 信号可以被阻塞和终止，以便程序在退出前可以保存工作或清理临时文件等</td><td>–</td></tr></tbody></table><p>还可以通过<code>kill -l</code> 命令查看系统支持的所有信号: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -l</span></span><br><span class="line">1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line">5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line">9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU</span><br><span class="line">25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH</span><br><span class="line">29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p><strong>注意:不同的Linux发行版支持的信号可能不同。</strong>  </p><p>每一种信号都会有一个默认的动作，默认动作就是脚本或程序接收到该信号后所作出的默认操作。常见的默认动作有终止进程，退出程序，忽略信号，重启进程等等。</p><h2 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h2><p>可以从两个不同的分类角度对信号进行分类：（1）可靠性方面：可靠信号与不可靠信号；（2）与时间的关系上：实时信号与非实时信号。 </p><h4 id="不可靠信号与可靠信号"><a href="#不可靠信号与可靠信号" class="headerlink" title="不可靠信号与可靠信号"></a>不可靠信号与可靠信号</h4><h4 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h4><p>Linux信号机制基本上是从Unix系统中继承过来的。早期Unix系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做”不可靠信号”，信号值小于SIGRTMIN(Red hat 7.2中，SIGRTMIN=32，SIGRTMAX=63)的信号都是不可靠信号。这就是”不可靠信号”的来源。<br>它的主要问题是:  </p><ul><li>进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用signal()，重新安装该信号。  </li><li>信号可能丢失</li></ul><p>早期unix下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。</p><p>Linux支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，Linux下的不可靠信号问题主要指的是<mark>信号可能丢失</mark>。  </p><h4 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h4><p>随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种Unix版本分别在这方面进行了研究，力图实现”可靠信号”。  </p><p>由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。  </p><p>同时，信号的发送和安装也出现了新版本：<code>信号发送函数sigqueue()</code>及<code>信号安装函数sigaction()</code>。</p><p>信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数<code>sigation（）</code>以及信号发送函数<code>sigqueue()</code>的同时，仍然支持早期的<code>signal（）信号安装函数</code>，支持<code>信号发送函数kill()</code>。</p><p><strong><mark>注意:</mark></strong>:<br>不要有这样的误解：由<code>sigqueue()</code>发送、<code>sigaction</code>安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号（信号值位于<code>SIGRTMIN及SIGRTMAX</code>之间）；不可靠信号是信号值小于<code>SIGRTMIN</code>的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。<br>目前linux中的signal()是通过sigation()函数实现的，因此，即使通过signal（）安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由signal()安装的实时信号支持排队，同样不会丢失。  </p><p>对于目前linux的两个信号安装函数:<code>signal()及sigaction()</code>来说，它们都不能把<code>SIGRTMIN</code>以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对<code>SIGRTMIN</code>以后的信号都支持排队。这两个函数的最大区别在于，经过<code>sigaction</code>安装的信号都能传递信息给信号处理函数（对所有信号这一点都成立），而经过<code>signal</code>安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p><h4 id="实时信号与非实时信号"><a href="#实时信号与非实时信号" class="headerlink" title="实时信号与非实时信号"></a>实时信号与非实时信号</h4><p>早期Unix系统只定义了32种信号，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的<code>CTRL ^C</code>时，会产生<code>SIGINT</code>信号，对该信号的默认反应就是进程终止。之后的信号 都表示 实时信号，等同于前面阐述的<code>可靠信号</code>。这保证了发送的多个实时信号都被接收。实时信号是<code>POSIX标准</code>的一部分，可用于应用进程。</p><p><strong>非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。</strong></p><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><h4 id="信号的接收"><a href="#信号的接收" class="headerlink" title="信号的接收"></a>信号的接收</h4><p>信号的接收工作是由内核来实现的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。<br><mark>这个时候</mark>，虽然进程进入了内核态，但信号还没有被处理，可能在排队。</p><h4 id="信号的检测"><a href="#信号的检测" class="headerlink" title="信号的检测"></a>信号的检测</h4><p>进程陷入内核态后，有两种场景会对信号进行检测： </p><ul><li>进程从内核态返回到用户态前进行信号检测</li><li>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</li></ul><p>当发现有新信号时，便会进入下一步，信号的处理。  </p><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p><code>信号处理函数</code>是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。  </p><p>接下来进程返回到用户态中，执行相应的<code>信号处理函数</code>。  </p><p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。  </p><p><mark>注意: 如果自定义信号处理函数，需要提前注册 信号处理函数</mark>  </p><h2 id="信号处理函数注册"><a href="#信号处理函数注册" class="headerlink" title="信号处理函数注册"></a>信号处理函数注册</h2><p>如果进程处理某一个信号，那么久需要在进程中注册(安装)该信号。 信号安装主要用来确定信号值及进程针对该信号值的动作之间的映射关系。即进程要处理哪个信号，该信号传递给进程时，进程执行的操作。</p><p>Linux 主要有两个函数实现信号的注册安装: <code>signal()</code>.<code>sigaction()</code>其中前者 在可靠信号系统调用的基础上实现，是库函数。它只有<code>两个参数</code>，不支持信号传递信息，主要是用于<code>前32种非实时信号的安装</code>; 而<code>sigaction()</code>是较新的函数（由两个系统调用实现：<code>sys_signal</code>以及<code>sys_rt_sigaction</code>），有三个参数，支持信号传递信息，主要用来与 <code>sigqueue() 系统调用</code>配合使用，当然，<code>sigaction()</code>同样支持非实时信号的安装。<code>sigaction()优于signal()</code>主要体现在支持信号带有参数。  </p><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">void (*signal(int signum, void (*handler))(int)))(int);</span><br></pre></td></tr></table></figure><p><code>第一个参数</code>指定信号的值，<code>第二个参数</code>指定针对前面信号值的处理，可以忽略该信号（参数设为<code>SIG_IGN</code>）; 可以采用<code>系统默认方式</code>处理信号(参数设为<code>SIG_DFL</code>)；也可以自己实现处理方式(<code>参数指定一个函数地址</code>)。<br>如果signal()调用成功，返回最后一次为安装信号signum而调用signal()时的handler值；失败则返回SIG_ERR。  </p><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure><p><code>sigaction函数</code>用于改变进程接收到特定信号后的行为。<br>该函数的<code>第一个参数</code>为信号的值，可以为除<code>SIGKILL及SIGSTOP</code>外的任何一个特定有效的信号（<strong>为这两个信号定义自己的处理函数，将导致信号安装错误</strong>）。<br><code>第二个参数</code>是指向结构    <code>sigaction</code>的一个实例的指针，在<code>结构sigaction</code>的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理；<br><code>第三个参数oldact</code>指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。  </p><p>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。  </p><p><code>sigaction</code>结构定义:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">         union&#123;</span><br><span class="line">           __sighandler_t _sa_handler;</span><br><span class="line">           void (*_sa_sigaction)(int,struct siginfo *, void *)；</span><br><span class="line">           &#125;_u</span><br><span class="line">                    sigset_t sa_mask；</span><br><span class="line">                   unsigned long sa_flags； </span><br><span class="line">                 void (*sa_restorer)(void)；</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>其中，sa_restorer，已过时，POSIX不支持它，不应再被使用。</p><p>联合数据结构中的两个元素 <strong><code>_sa_handler</code></strong> 以及 <strong><code>*_sa_sigaction</code></strong> 指定信号关联函数，即用户指定的信号处理函数。除了可以是用户自定义的处理函数外，还可以为<code>SIG_DFL</code>(采用缺省的处理方式)，也可以为<code>SIG_IGN</code>（忽略信号）。   </p><p>由 <strong><code>_sa_handler</code></strong> 指定的处理函数只有一个参数,即信号值，所以信号不能传递除信号值之外的任何信息； 由<strong><code>_sa_sigaction</code></strong>是指定的信号处理函数带有三个参数，是为实时信号而设的（当然同样支持非实时信号），它指定一个3参数信号处理函数。<br>第一个参数为信号值，第三个参数没有使用（posix没有规范使用该参数的标准），第二个参数是指向siginfo_t结构的指针，结构中包含信号携带的数据值，参数所指向的结构如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">siginfo_t &#123;</span><br><span class="line">                 int      si_signo;  /* 信号值，对所有信号有意义*/</span><br><span class="line">                 int      si_errno;  /* errno值，对所有信号有意义*/</span><br><span class="line">                 int      si_code;   /* 信号产生的原因，对所有信号有意义*/</span><br><span class="line">       union&#123;          /* 联合数据结构，不同成员适应不同信号 */  </span><br><span class="line">         //确保分配足够大的存储空间</span><br><span class="line">         int _pad[SI_PAD_SIZE];</span><br><span class="line">         //对SIGKILL有意义的结构</span><br><span class="line">         struct&#123;</span><br><span class="line">             ...</span><br><span class="line">             &#125;...</span><br><span class="line">           ... ...</span><br><span class="line">           ... ...          </span><br><span class="line">         //对SIGILL, SIGFPE, SIGSEGV, SIGBUS有意义的结构</span><br><span class="line">             struct&#123;</span><br><span class="line">             ...</span><br><span class="line">             &#125;...</span><br><span class="line">           ... ...</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><mark>注：</mark>为了更便于阅读，在说明问题时常把该结构表示为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">siginfo_t &#123;</span><br><span class="line">int      si_signo;  /* 信号值，对所有信号有意义*/</span><br><span class="line">int      si_errno;  /* errno值，对所有信号有意义*/</span><br><span class="line">int      si_code;   /* 信号产生的原因，对所有信号有意义*/</span><br><span class="line">pid_t    si_pid;    /* 发送信号的进程ID,对kill(2),实时信号以及SIGCHLD有意义 */</span><br><span class="line">uid_t    si_uid;    /* 发送信号进程的真实用户ID，对kill(2),实时信号以及SIGCHLD有意义 */</span><br><span class="line">int      si_status; /* 退出状态，对SIGCHLD有意义*/</span><br><span class="line">clock_t  si_utime;  /* 用户消耗的时间，对SIGCHLD有意义 */</span><br><span class="line">clock_t  si_stime;  /* 内核消耗的时间，对SIGCHLD有意义 */</span><br><span class="line">sigval_t si_value;  /* 信号值，对所有实时有意义，是一个联合数据结构，</span><br><span class="line">                          /*可以为一个整数（由si_int标示，也可以为一个指针，由si_ptr标示）*/</span><br><span class="line">     </span><br><span class="line">void *   si_addr;   /* 触发fault的内存地址，对SIGILL,SIGFPE,SIGSEGV,SIGBUS 信号有意义*/</span><br><span class="line">int      si_band;   /* 对SIGPOLL信号有意义 */</span><br><span class="line">int      si_fd;     /* 对SIGPOLL信号有意义 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>siginfo_t</code>结构中的联合数据成员确保该结构适应所有的信号，比如对于实时信号来说，则实际采用下面的结构形式: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">int si_signo;</span><br><span class="line">int si_errno;           </span><br><span class="line">int si_code;            </span><br><span class="line">union sigval si_value;</span><br><span class="line">&#125; siginfo_t;</span><br></pre></td></tr></table></figure><p>sigval 也是一个联合数据结构:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union sigval &#123;</span><br><span class="line">    int sival_int;      </span><br><span class="line">    void *sival_ptr;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>采用联合数据结构，说明<code>siginfo_t</code>结构中的si_value要么持有一个4字节的整数值，要么持有一个指针，这就构成了与信号相关的数据。  </p><p>在后面 分析 <code>sigqueue发送信号</code> sigqueue的第三个参数就是<code>sigval</code>联合数据结构,当调用sigqueue时，该数据结构中的数据就将拷贝到信号处理函数的第二个参数中。这样，在发送信号同时，就可以让信号传递一些附加信息。信号可以传递信息对程序开发是非常有意义的。</p><p>信号参数的传递过程 如下: </p><p>调用 sigqueue(pid_t pid, int sig, const union sigval val)<br>—&gt;  信号进入队列, 进程进入内核态<br>—&gt; 内核接收到 信号之后 ,准备数据，把携带的<code>sigvall</code>结构类型的参数 拷贝到 安装信号时 结构体<code>sigaction</code>中的 <code>si_value</code> 。<br>—&gt; 使进程进入用户态，拷贝数据到用户态，执行信号处理程序<br>—&gt; sigaction 中定义的 handler(int,struct siginfo <em>, void </em>）</p><p><strong>这就成功的把参数传递到了 信号处理程序。</strong><br><img src="/img/sig/sig_install.gif" alt="">  </p><h2 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h2><p>发送信号的主要函数有:<code>kill()</code>、<code>raise()</code>、 <code>sigqueue()</code>、<code>alarm()</code>、<code>setitimer()</code> 以及 <code>abort()</code>  </p><h4 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int kill(pid_t pid,int signo)</span><br></pre></td></tr></table></figure><p>参数 pid:  </p><table><thead><tr><th>pid的值</th><th>信号的接收进程</th></tr></thead><tbody><tr><td>pid&gt;0</td><td>进程ID为pid的进程接收</td></tr><tr><td>pid=0</td><td>同一个进程组的所有进程</td></tr><tr><td>pid&lt;0 但 pid!=-1</td><td>进程组ID为 -pid的所有进程</td></tr><tr><td>pid=-1</td><td>除发送进程自身外，所有进程ID大于1的进程</td></tr></tbody></table><p>参数 signo:  </p><p><code>sinno</code>是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在。以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。</p><p><code>Kill()</code>最常用于pid&gt;0时的信号发送，调用成功返回 0； 否则，返回 -1。 注：对于<code>pid&lt;0</code>时的情况，对于哪些进程将接受信号，各种版本说法不一，其实很简单，参阅内核源码<code>kernal/signal.c</code>即可，上表中的规则是参考<code>red hat 7.2</code>。  </p><h4 id="raise"><a href="#raise" class="headerlink" title="raise()"></a>raise()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int raise(int signo)</span><br></pre></td></tr></table></figure><p>向进程本身发送信号，参数为即将发送的信号值。调用成功返回 0；否则，返回 -1。  </p><h4 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue()"></a>sigqueue()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int sigqueue(pid_t pid, int sig, const union sigval val)</span><br></pre></td></tr></table></figure><p>调用成功返回 0；否则，返回 -1。<br><code>sigqueue()</code>是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数<code>sigaction()</code>配合使用。  </p><p><code>sigqueue</code>的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构<code>union sigval</code>，指定了信号传递的参数，即通常所说的<code>4字节值</code>。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef union sigval &#123;</span><br><span class="line">    int  sival_int;</span><br><span class="line">    void *sival_ptr;</span><br><span class="line">&#125;sigval_t;</span><br></pre></td></tr></table></figure><p>如前面分析，该数据结构 最后会被传递到 信号处理程序<code>handler</code>的第二个参数(<code>struct siginfo *</code>)中。</p><p><code>sigqueue()</code>比<code>kill()</code>传递了更多的附加信息，但<code>sigqueue()</code>只能向一个进程发送信号，而不能发送信号给一个进程组。如果<code>signo=0</code>，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。  </p><p>在调用<code>sigqueue</code>时，<code>sigval_t</code>指定的信息会拷贝到<code>3参数信号处理函数</code>（3参数信号处理函数指的是信号处理函数由<code>sigaction</code>安装，并设定了<code>sa_sigaction</code>指针)的<code>siginfo_t</code>结构中，这样信号处理函数就可以处理这些信息了。</p><p><strong>注：</strong> <code>sigqueue（）</code>发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数； <code>sigqueue（）</code>发送非实时信号时，仍然不支持排队，即在信号处理函数执行过程中到来的所有相同信号，都被合并为一个信号。  </p><h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm()"></a>alarm()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; </span><br><span class="line">unsigned int alarm(unsigned int seconds)</span><br></pre></td></tr></table></figure><p>专门为SIGALRM信号而设，在指定的时间seconds秒后，将向进程本身发送SIGALRM信号，又称为闹钟时间。进程调用alarm后，任何以前的alarm()调用都将无效。如果参数seconds为零，那么进程内将不再包含任何闹钟时间。<br>返回值，如果调用alarm（）前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</p><h4 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/time.h&gt; </span><br><span class="line">int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue));</span><br></pre></td></tr></table></figure><p>setitimer()比alarm功能强大，支持3种类型的定时器:  </p><ul><li>ITIMER_REAL：    设定绝对时间；经过指定的时间后，内核将发送SIGALRM信号给本进程;</li><li>ITIMER_VIRTUAL 设定程序执行时间；经过指定的时间后，内核将发送SIGVTALRM信号给本进程;</li><li>ITIMER_PROF 设定进程执行以及内核因本进程而消耗的时间和，经过指定的时间后，内核将发送ITIMER_VIRTUAL信号给本进程;</li></ul><p>setitimer()第一个参数which指定定时器类型（上面三种之一）；第二个参数是结构itimerval的一个实例，结构itimerval形式见附录1。第三个参数可不做处理。  </p><p>setitimer()调用成功返回0，否则返回-1。  </p><h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line">void abort(void);</span><br></pre></td></tr></table></figure><p>向进程发送SIGABORT信号，默认情况下进程会异常退出，当然可定义自己的信号处理函数。即使SIGABORT被进程设置为阻塞信号，调用abort()后，SIGABORT仍然能被进程接收。<br>该函数无返回值。</p><h2 id="信号机制的系统调用"><a href="#信号机制的系统调用" class="headerlink" title="信号机制的系统调用"></a>信号机制的系统调用</h2><p>信号处理函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换。</p><p><img src="/img/sig/sig_interrupt.jpg" alt=""></p><p>学习参考:<br><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">IBM-Linux信号上</a><br><a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android平台Native代码的崩溃捕获机制及实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;系统中 &lt;code&gt;信号机制&lt;/code&gt;是进程间通信的其中一种方法，全称为&lt;code&gt;软中断信号&lt;/code&gt;，也被称为&lt;code&gt;软中断&lt;/code&gt;。不过 信号本质上是在软件层面上对硬件中断机制的一种模拟。&lt;br&gt;与Linux 系统
      
    
    </summary>
    
      <category term="Linux" scheme="http://aicodeing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://aicodeing.github.io/tags/Linux/"/>
    
      <category term="IPC" scheme="http://aicodeing.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Linux inode理解</title>
    <link href="http://aicodeing.github.io/Linux-inode%E7%90%86%E8%A7%A3/"/>
    <id>http://aicodeing.github.io/Linux-inode理解/</id>
    <published>2019-01-15T08:50:05.000Z</published>
    <updated>2019-05-29T11:19:08.296Z</updated>
    
    <content type="html"><![CDATA[<p><code>inode</code>在<code>Linux</code> 文件系统中具有灵魂级作用，我们就谈一下对<code>inode</code>的理解。<br>首先了解一下<code>Linux</code>的文件系统。 </p><h3 id="EXT4-文件系统"><a href="#EXT4-文件系统" class="headerlink" title="EXT4 文件系统"></a>EXT4 文件系统</h3><p>Linux 基于ext4 文件系统，简单来说 它将存储划分成一组组大小相同的逻辑块，这样做的好处是减少了文件管理的开销，按照 <strong>整数个</strong> <code>基础逻辑块</code>来分配存储大小方便高效，而且利于提高大文件的传输效率，一个文件所占用的块可以是连续的，也可以是非连续的。而为了标记这些逻辑块的引用，文件系统中还引入了 <code>inode</code>。<br><code>inode</code>是linux 文件系统中的数据索引标记符。 如下图:<br> <img src="/img/inode/inode_1.jpg" alt=""></p><p> <code>Linux</code>的文件系统被分为了两部分，一部分是 <code>inode</code>区，一部分是 <code>block</code>区，一个<code>inode</code> 的默认大小为 128Byte，当然，不同的Linux 发行版本可能大小定义不同，inode的大小在文件系统被格式化之后就无法更改了，格式化前可以指定inode大小。<code>inode</code>用来记录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件的权限(r,w,x)</span><br><span class="line">文件的所有者和属组</span><br><span class="line">文件的大小</span><br><span class="line">文件的状态改变时间（ctime）</span><br><span class="line">文件的最近一次读取时间（atime）</span><br><span class="line">文件的最近一次修改时间（mtime</span><br><span class="line">文件的数据真正保存的 block 编号。</span><br></pre></td></tr></table></figure><p>每个文件需要占用一个 <code>inode</code>。而<code>inode</code> 中是不记录文件的名称的，文件名称记录在文件所在目录的<code>block</code>块中。<br> <code>block</code>块的大小可以是1KB、2KB、4KB，一般默认往往是4KB，包含了连续8个扇区，每个扇区存储512个字节。</p><p><code>inode</code>就告诉了文件位于哪个“块”，于是系统就会从这个“block块”开始读取内容。如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p><h3 id="查看文件的inode"><a href="#查看文件的inode" class="headerlink" title="查看文件的inode"></a>查看文件的inode</h3><p>我们可以使用 <code>stat</code> 命令来查看文件的 <code>inode</code> 信息</p><p>在 test 目录下创建一个 <code>src.txt</code> 文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  test touch src.txt</span><br><span class="line">➜  test ll -l</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r--  1 wangwei  staff     0B  1 15 17:51 src.txt</span><br><span class="line">➜  test stat -x src.txt</span><br><span class="line">  File: "src.txt"</span><br><span class="line">  Size: 4            FileType: Regular File</span><br><span class="line">  Mode: (0644/-rw-r--r--)         Uid: (  502/ wangwei)  Gid: (   20/   staff)</span><br><span class="line">Device: 1,4   Inode: 8625061903    Links: 2</span><br><span class="line">Access: Tue Jan 15 18:36:36 2019</span><br><span class="line">Modify: Tue Jan 15 18:34:09 2019</span><br><span class="line">Change: Tue Jan 15 18:37:29 2019</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p>通过 <code>stat -x file</code>命令(Mac Os 下) 可以得到 文件的 详细信息，<code>Inode: 8625061903</code> 指明 该文件的 <code>inode</code>号是 <code>8625061903</code>  </p><p>通过<code>stat -s file</code>命令:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  test stat -s src.txt</span><br><span class="line">st_dev=16777220 st_ino=8625061903 st_mode=0100644 st_nlink=2 st_uid=502 st_gid=20 st_rdev=0 st_size=4 st_atime=1547548596 st_mtime=1547548449 st_ctime=1547548649 st_birthtime=1547545866 st_blksize=4096 st_blocks=8 st_flags=0</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p>可以得到更多信息，如果了解更多请访问 <a href="&#39;https://linux.die.net/man/2/stat&#39;">linux-stat</a>   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st_dev: 文件所在的 device ID</span><br><span class="line">st_ino: 文件的 inode 号</span><br><span class="line">st_mode: 文件的类型，如 常规文件，文件夹，字符设备文件，块文件 等等</span><br><span class="line">st_nlink：文件的硬链接个数，如果为0 就可以被删除了</span><br><span class="line">st_rdev: 设备号的意思，只有字符特殊设备和块特殊设备才会有st_rdev值。此值包含实际设备的设备号</span><br><span class="line">st_size: 文件占用的字节大小 ,单位字节</span><br><span class="line">st_blksize: 每个 block 的大小，一般情况下是4KB</span><br><span class="line">st_blocks: number of 512B blocks allocated, 以 512B 为单位分配给文件的个数,用 st_size/512B 就得到 st_blocks，</span><br><span class="line">当 st_size 小于一个 block的大小，即文件大小小于默认的4KB时 实际还是分配一个 block，st_blocks = 1个blocksize/512B,</span><br><span class="line">在该例子中，src.txt 大小是4B ，但是需要占用一个 block 也就是 4KB的实际存储空间，计算得到的st_blocks = 8</span><br></pre></td></tr></table></figure><p>还可以使用命令<code>ll -i</code> 查看文件的 inode  </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ➜  test ll -i</span><br><span class="line">total 0</span><br><span class="line">8625061903 -rw-r--r--  1 wangwei  staff     0B  1 15 17:51 src.txt</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p> <code>8625061903</code> 就是 文件 <code>src.txt</code>的 inode编码,而权限后面的 <code>1</code>是该文件的链接数，也即是 <code>硬链接数</code>。  </p><h3 id="inode的使用"><a href="#inode的使用" class="headerlink" title="inode的使用"></a>inode的使用</h3><p>一个文件在创建的时候就会分配一个 inode节点，以一个简单的例子来说明，如何访问一个文件?<br>要打开一个文件，需要要找到这个文件占用的 block 块。首先会找到文件所在的目录，在linux文件系统中，目录也是一个文件，<strong>目录文件的内容就是该目录下的文件名与 inode的映射表，即一个个的目录项</strong>。当访问一个文件的时候首先查询到上一级目录，在 Linux 文件系统中 每一个目录中都有 <code>.</code>和<code>../</code>两个目录   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  test ll -ai</span><br><span class="line">total 16</span><br><span class="line">8625052613 drwxr-xr-x   4 wangwei  staff   128B  1 15 17:51 .</span><br><span class="line">   8475120 drwxr-xr-x+ 85 wangwei  staff   2.7K  1 15 18:13 ..</span><br><span class="line">8625053037 -rw-r--r--@  1 wangwei  staff   6.0K  1 15 15:39 .DS_Store</span><br><span class="line">8625061903 -rw-r--r--   1 wangwei  staff     0B  1 15 17:51 src.txt</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p> <strong><code>.</code></strong> 目录代表当前目录的 <strong>硬连接</strong> ；<strong><code>..</code></strong> 代表着上级目录的 <strong>硬链接</strong><br> 示例中的 8625052613 就是当前test 目录的inode编号，8475120 是上级目录的编号。因此也说明了，任何一个目录的硬链接总数，总是等于 2 加上它的子目录和子文件总数,即使是一个空文件夹，它的硬链接数也是2。  </p><p>文件系统根据 父目录的目录项找到 需要打开文件的inode 节点，通过读 inode 节点找到需要打开的 block，载入 block块中的数据，即完成了打开文件的操作，当然通过 inode 做了权限判断，如果无权访问该文件，不需要访问 block块，通过目录项找到 inode 节点就能读出权限信息。  </p><h3 id="inode的链接数"><a href="#inode的链接数" class="headerlink" title="inode的链接数"></a>inode的链接数</h3><p>通过 <code>ll -i</code>命令可以查看文件的 inode 信息，inode 信息中有一个 <strong>链接数</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ➜  test ll -i</span><br><span class="line">total 0</span><br><span class="line">8625061903 -rw-r--r--  1 wangwei  staff     0B  1 15 17:51 src.txt</span><br></pre></td></tr></table></figure><p> <code>-rw-r--r--</code> 后面的 <strong>1</strong> 表示 src.txt 文件当前有一个引用，当 链接数变成0 则释放 inode，释放block 块的数据内容。 </p><p> 对 inode 链接数 的影响 来自 前面多次提到的 <strong>硬链接</strong> </p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>我们常见的软连接 通过 <code>ln</code>命令生成。同样，硬链接也是通过<code>ln</code>命令生成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  test ll -i</span><br><span class="line">total 0</span><br><span class="line">8625061903 -rw-r--r--  1 wangwei  staff     0B  1 15 17:51 src.txt</span><br><span class="line">➜  test ln src.txt hard.txt</span><br><span class="line">➜  test ll -i</span><br><span class="line">total 0</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     0B  1 15 17:51 hard.txt</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     0B  1 15 17:51 src.txt</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p> 示例中 创建了一个硬链接 <code>hard.txt</code>， 这个文件 的 <code>inode</code> 和 <code>src.txt</code> 是一样的，说明在目录项中 这两个文件名都指向 同一个<code>inode</code>，<code>inode</code> 指向一个 <code>block</code>，这就说明 这两个文件共用一个 <code>block 块</code>，不管修改哪个文件，另一个文件也会被修改。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ➜  test echo 111 &gt; src.txt</span><br><span class="line">➜  test cat src.txt</span><br><span class="line">111</span><br><span class="line">➜  test cat hard.txt</span><br><span class="line">111</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p> 示例中我们向 <strong><code>src.txt</code></strong> 文件写入了 <strong><code>111</code></strong> 字符，查看发现 <code>hard.txt</code> 也做了同样的修改。</p><p>那么两个文件指向同一个<code>block</code>，那占用的空间肯定也就是一份了，有意思的事情来了  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  test ll -h</span><br><span class="line">total 8 // 8个 以512B为单位的存储占用 即 8*512B = 4KB</span><br><span class="line">-rw-r--r--  1 wangwei  staff     4B  1 15 18:34 src.txt</span><br><span class="line">➜  test ln src.txt hard.txt</span><br><span class="line">➜  test ll -h</span><br><span class="line">total 16 // 16个 以512B为单位的存储占用 即 16*512B = 8KB</span><br><span class="line">-rw-r--r--  2 wangwei  staff     4B  1 15 18:34 hard.txt</span><br><span class="line">-rw-r--r--  2 wangwei  staff     4B  1 15 18:34 src.txt</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p><strong>查看存储占用，发现 硬链接 导致了 存储的翻倍了。这个不符合原理啊!!!</strong><br>其实这是这个<strong><code>ll –h</code></strong> 或者 <strong><code>ls –h</code></strong> 命令进行统计文件总大小的时候并不是从磁盘进行统计的，而是根据文件属性中的大小叠加得来的。而硬链接的文件属性中的大小就是就是inode号对应的数据块的大小，所以total中进行统计就把各个文件属性中的大小加起来作为总和，这种统计是不标准，也不具有代表性的，正真的查看某个文件夹占用磁盘空间大小命令是：du –h   这个命令是从磁盘上进行统计，不会被文件的属性中大小影响，所以更准确。</p><p>所以得出结论: <strong>硬链接并不占用磁盘空间！</strong>  </p><p>那么我们常见的软连接呢?</p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><p>软连接的创建方式和 硬链接的创建方式类似，都是使用 <code>ln</code> 命令，只是需要加上 <code>-s</code> 标记要创建软连接。软连接就相当于<code>windows系统</code> 上的快捷方式，只是指向一个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  test ll -i</span><br><span class="line">total 16</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     4B  1 15 18:34 hard.txt</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     4B  1 15 18:34 src.txt</span><br><span class="line">➜  test ln -s src.txt soft.txt</span><br><span class="line">➜  test ll -i</span><br><span class="line">total 16</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     4B  1 15 18:34 hard.txt</span><br><span class="line">8625064180 lrwxr-xr-x  1 wangwei  staff     7B  1 15 18:48 soft.txt -&gt; src.txt</span><br><span class="line">8625061903 -rw-r--r--  2 wangwei  staff     4B  1 15 18:34 src.txt</span><br><span class="line">➜  test</span><br></pre></td></tr></table></figure><p>创建一个 软连接， <code>soft.txt</code> 发现它的<code>inode</code>是全新的。</p><p><strong>软链接</strong> 和 <strong>硬链接</strong> 在原理上最主要的不同在于: <strong>硬链接不会建立自己的 inode 索引和 block（数据块），而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</strong></p><p>既然软连接分配了新的<code>inode</code>，也就是占用了新的<code>block</code>，那肯定会占用存储空间，由于软连接的<code>block</code> 存储的是 真正文件的路径和<code>inode号</code>，所以占用的空间是极小的。</p><p><strong>此外，硬链接是共享 <code>inode</code>的，而 <code>inode</code> 是同一个文件系统上的唯一标记，所以 硬链接是不能跨文件系统的，而软连接是新的<code>inode</code>，所以是可以跨文件系统的。</strong></p><h3 id="文件操作对-inode-的影响"><a href="#文件操作对-inode-的影响" class="headerlink" title="文件操作对 inode 的影响"></a>文件操作对 <code>inode</code> 的影响</h3><h4 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a><code>cp</code> 命令</h4><p><code>cp</code> 命令是拷贝一个新文件，分配新的<code>inode</code>，必然导致分配新的<code>block</code>。所以会占用一份新的存储空间。<code>cp</code>命令执行的内部操作如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.分配一个未被使用的 inode 号，在 inode 表中新添一个项目</span><br><span class="line">2.在目录中新建一个目录项，并指向步骤 1 中的 inode</span><br><span class="line">3.把数据拷贝到新block中</span><br></pre></td></tr></table></figure><h4 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a><code>rm</code> 命令</h4><p><code>rm</code> 会删除指定的文件，所做的操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.减少待删除文件名所对应的 inode 的链接数量，如果链接数变为0，则释放 inode。同时block块标记为可用状态。</span><br><span class="line">2.删除文件目录中的对应目录项。</span><br></pre></td></tr></table></figure><h4 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a><code>mv</code> 命令</h4><p>如果 源文件和目标文件在 <strong><code>同一个文件系统</code></strong> 中，会复用<code>inode</code> 内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在目标文件的目录中新建目录项</span><br><span class="line">2.删除源文件的目录中的目录项</span><br><span class="line">3.目标文件名会指向源文件名的 inode。因此该操作对 inode 没有影响（除了时间戳），对数据的位置也没有影响，不移动任何数据。</span><br></pre></td></tr></table></figure><p>所以在同一文件系统下，移动命令不会涉及到数据真正移动。</p><p>如果在 <strong><code>不同的文件系统</code></strong> 中，其实就是相当于 拷贝一份新数据到 目标目标，然后删除 源文件。<br>这个过程会设计到 源文件 <code>inode</code> 的释放和 新 <code>inode</code> 的生成，还有数据拷贝，执行了<code>IO</code> 操作。</p><h3 id="inode-的场景利用"><a href="#inode-的场景利用" class="headerlink" title="inode 的场景利用"></a>inode 的场景利用</h3><p><code>inode</code> 中携带者文件的很多信息，我们可以通过充分利用 <code>inode</code> 的特性实现高效的文件访问操作，如果 文件权限的修改，文件的极速扫描，快速查找大文件，删除顽固文件，通过<code>inode</code>号来识别文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;inode&lt;/code&gt;在&lt;code&gt;Linux&lt;/code&gt; 文件系统中具有灵魂级作用，我们就谈一下对&lt;code&gt;inode&lt;/code&gt;的理解。&lt;br&gt;首先了解一下&lt;code&gt;Linux&lt;/code&gt;的文件系统。 &lt;/p&gt;
&lt;h3 id=&quot;EXT4-文件系统
      
    
    </summary>
    
      <category term="Linux" scheme="http://aicodeing.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://aicodeing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在GoogleCloud上搭建SS代理服务</title>
    <link href="http://aicodeing.github.io/ss-work-in-googlecloud/"/>
    <id>http://aicodeing.github.io/ss-work-in-googlecloud/</id>
    <published>2018-10-26T06:11:54.000Z</published>
    <updated>2019-05-29T11:19:08.298Z</updated>
    
    <content type="html"><![CDATA[<p>GoogleCloud 目前有免费300$方案，该教程利用<code>GoogleCloud</code> 平台搭建 <code>Shadowsocks</code>服务。</p><h4 id="1-注册GoogleCloud账户并登陆"><a href="#1-注册GoogleCloud账户并登陆" class="headerlink" title="1. 注册GoogleCloud账户并登陆"></a>1. 注册GoogleCloud账户并登陆</h4><p>登陆地址 <a href="https://console.cloud.google.com" target="_blank" rel="noopener">https://console.cloud.google.com</a></p><p>账户建立过程忽略。</p><h4 id="2-配置项目"><a href="#2-配置项目" class="headerlink" title="2. 配置项目"></a>2. 配置项目</h4><p>进入 GoogleCloud 的后台。再开始搭建 <code>SS</code>服务之前需要先有一个<code>项目</code>如果已经有项目，直接选择，如果没有，按照下图新创建一个项目.</p><p>点击 顶部的 <code>Select a project</code><br><img src="/img/ss_server/step_1.jpg" alt=""><br><img src="/img/ss_server/step_2.jpg" alt=""><br><img src="/img/ss_server/step_3.jpg" alt="">  </p><p>项目创建完成之后，选择刚才创建的项目 然后 通过菜单栏选择 <code>Compute Engine</code>，然后进入到创建虚拟机实例 步骤。</p><h4 id="3-创建VM实例"><a href="#3-创建VM实例" class="headerlink" title="3. 创建VM实例"></a>3. 创建VM实例</h4><p><img src="/img/ss_server/step_4.jpg" alt=""><br><img src="/img/ss_server/step_5.jpg" alt=""> </p><p>创建虚拟机实例需要注意几个配置，具体看下图 红线部分</p><p> <img src="/img/ss_server/step_6_create_vm.jpg" alt=""> </p><p> <strong><code>vm</code>的名字:</strong> 可以随便起一个。</p><p> <strong>区域选择:</strong> 根据需求选择，一般原则是选择比较近的，例如 图示中选择的新加坡节点。</p><p> <strong>机器类型:</strong> 这个看需求，不过一般情况下 最低配置就能满足。</p><p> <strong>操作系统:</strong> 根据自己的情况，比如我习惯 Ubuntu 系统，就选择了 Ubuntu 18.0.4LTS</p><p> 剩下的默认配置就行。</p><p> <img src="/img/ss_server/step_6_vm_created.jpg" alt=""> </p><p> <code>VM</code>创建完成之后，然后先搁置起来，先去配置一些网络设置。</p><h4 id="4-网络设置"><a href="#4-网络设置" class="headerlink" title="4.网络设置"></a>4.网络设置</h4><h5 id="创建防火墙规则"><a href="#创建防火墙规则" class="headerlink" title="创建防火墙规则"></a>创建防火墙规则</h5><p>从左侧导航菜单选择 <code>VPC网络</code>-&gt;<code>防火墙规则</code></p><p><img src="/img/ss_server/step_7_create_fire_wall.jpg" alt=""></p><p><img src="/img/ss_server/step_7_begin_create_fire_rules.jpg" alt=""></p><p><img src="/img/ss_server/step_7_fire_rules_created.jpg" alt=""></p><p><strong>防火墙名字:</strong> 这个随便起，见名之意即可</p><p><strong>流量方向:</strong> 选择入站</p><p><strong>目标:</strong> 选择 <code>网络中的所有实例</code></p><p><strong>来源IP地址范围:</strong> <code>0.0.0.0/0</code></p><p><strong>协议和端口:</strong> 全部允许</p><p>然后点击创建按钮完成防火墙配置。</p><h5 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h5><p>从左侧导航菜单选择<code>VPC网络</code>-&gt; <code>外部IP地址</code></p><p><img src="/img/ss_server/step_8_ip.jpg" alt=""></p><p><img src="/img/ss_server/step_8_begin_static_ip.jpg" alt=""></p><p><img src="/img/ss_server/step_8_static_ip_ok.jpg" alt=""></p><p>静态IP 名称: 随便起一个，图例中是 <code>proxy-ip</code></p><p>区域选择: 一定要选择你创建<code>VM</code>时 选择的区域和 <code>vm实例</code></p><h4 id="5-登陆-VM-实例，安装-SS-服务"><a href="#5-登陆-VM-实例，安装-SS-服务" class="headerlink" title="5. 登陆 VM 实例，安装 SS 服务"></a>5. 登陆 VM 实例，安装 SS 服务</h4><p>进入 <code>VM</code> 实例 页面，通过 <code>SSH</code> 登陆 服务器</p><p><img src="/img/ss_server/step_9_ssh_vm.jpg" alt=""></p><p><img src="/img/ss_server/step_9_link_vm.jpg" alt=""></p><p><img src="/img/ss_server/step_9_login_vm_ok.jpg" alt=""></p><p>如图所示，成功登陆服务器。</p><p>由于 <code>SS 服务</code> 需要在 <code>root</code> 用户下登陆，下面我们修改一下 服务器的<code>root</code> 密码</p><p><img src="/img/ss_server/step_10_reset_root_pwd.jpg" alt=""></p><p>输入命令:</p><p><code>sudo passwd root</code>  </p><p>然后设置 新的<code>root</code> 密码。<br>设置完之后 输入 命令:</p><p><code>su</code></p><p>然后输入密码进入 <code>root</code> 用户下</p><p><img src="/img/ss_server/step_10_enter_root.jpg" alt=""></p><p>以上步骤完成之后就开始我们的安装 操作了，执行如下命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure><p>然后会让你配置一些信息，如图：</p><p><img src="/img/ss_server/step_10_finish_ss_config.jpg" alt=""></p><p>设置的密码即为你 <code>Shadowsocks</code>软件上需要填写的密码</p><p>端口号对应 你 <code>Shadowsocks</code>软件上需要填写的端口号</p><p>加密方式我们选择默认 <code>aes-256-cfb</code>即可。</p><p>一切配置完成之后，点击回车按钮，会自动安装服务，待服务安装完毕，会出现如下界面：</p><p><img src="/img/ss_server/step_10_review_ss_config.jpg" alt=""></p><p>这些就是你在 <code>SS</code>软件上需要填写的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GoogleCloud 目前有免费300$方案，该教程利用&lt;code&gt;GoogleCloud&lt;/code&gt; 平台搭建 &lt;code&gt;Shadowsocks&lt;/code&gt;服务。&lt;/p&gt;
&lt;h4 id=&quot;1-注册GoogleCloud账户并登陆&quot;&gt;&lt;a href=&quot;#1-注册Go
      
    
    </summary>
    
      <category term="Tools" scheme="http://aicodeing.github.io/categories/Tools/"/>
    
    
      <category term="SS" scheme="http://aicodeing.github.io/tags/SS/"/>
    
      <category term="Proxy" scheme="http://aicodeing.github.io/tags/Proxy/"/>
    
      <category term="GoogleCloud" scheme="http://aicodeing.github.io/tags/GoogleCloud/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks自定义PAC规则</title>
    <link href="http://aicodeing.github.io/Shadowsocks%E8%87%AA%E5%AE%9A%E4%B9%89PAC%E8%A7%84%E5%88%99/"/>
    <id>http://aicodeing.github.io/Shadowsocks自定义PAC规则/</id>
    <published>2018-10-17T03:14:28.000Z</published>
    <updated>2019-05-29T11:19:08.297Z</updated>
    
    <content type="html"><![CDATA[<p>科学上网，SS是一大利器。它的实现原理 就是墙外一台服务器，墙内一台服务器(也就是我们的客户端)，两台服务器之间加密通讯，防火墙因为无法判定用户访问的网站是否在防火墙列表，所以放行,这样就可以通过墙外服务器做代理啦。但我们知道，任何网站都通过墙外服务器是<code>不明智的</code>，例如我们访问<code>baidu.com</code>，百度在国内架设了很多服务器，一般都是就近访问的，如果也通过代理到国外绕一圈，得不偿失。所以就需要一个忽略列表，或者一个需要走代理的列表，而PAC 规则就是来实现这个的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>PAC的配置规则语法和GFWlist 相同，即<a href="https://adblockplus.org/en/filter-cheatsheet" target="_blank" rel="noopener">adblock</a>   </p><p>下面我引用 <code>adblock</code>的示例来做说明。</p><h4 id="1-匹配地址中的一部分内容-通配符匹配"><a href="#1-匹配地址中的一部分内容-通配符匹配" class="headerlink" title="1. 匹配地址中的一部分内容(通配符匹配)"></a>1. 匹配地址中的一部分内容(通配符匹配)</h4><p>比如我们想匹配以下地址:</p><ul><li><a href="http://example.com/banner/foo/img" target="_blank" rel="noopener">http://example.com/banner/foo/img</a></li></ul><ul><li><a href="http://example.com/banner/foo/bar/img?param" target="_blank" rel="noopener">http://example.com/banner/foo/bar/img?param</a></li></ul><ul><li><a href="http://example.com/banner//img/foo" target="_blank" rel="noopener">http://example.com/banner//img/foo</a></li></ul><p>但是不想匹配这些地址:</p><ul><li><a href="http://example.com/banner/img" target="_blank" rel="noopener">http://example.com/banner/img</a></li><li><a href="http://example.com/banner/foo/imgraph" target="_blank" rel="noopener">http://example.com/banner/foo/imgraph</a></li><li><a href="http://example.com/banner/foo/img.gif" target="_blank" rel="noopener">http://example.com/banner/foo/img.gif</a></li></ul><p>那么我们可以写这样的匹配规则:  </p><p><strong><code>/banner/*/img^</code></strong>  </p><p>通配符<code>*</code> 表明中间可以是任意路径或字符，但是必须要有,如果没有，就必须出现两个<code>/</code> 如<code>http://example.com/banner//img/foo</code>  </p><p>符合 <code>^</code>  表明 地址必须在这里结束，或者后面跟着的是 <code>/</code>，或是参数字符，例如<code>?</code>。  </p><h4 id="2-匹配绝对地址"><a href="#2-匹配绝对地址" class="headerlink" title="2. 匹配绝对地址"></a>2. 匹配绝对地址</h4><p>比如我就像匹配地址:  </p><ul><li><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li></ul><p>那么匹配规则可以这样:  </p><p><strong><code>|http://www.baidu.com|</code></strong>  </p><p>在该规则下 以下地址就无法匹配:  </p><ul><li><a href="http://www.baidu.com/logo.jpg" target="_blank" rel="noopener">http://www.baidu.com/logo.jpg</a></li></ul><h4 id="3-匹配开头或结尾"><a href="#3-匹配开头或结尾" class="headerlink" title="3. 匹配开头或结尾"></a>3. 匹配开头或结尾</h4><p>比如我想匹配以 <code>http://example.com</code> 开头的网址,例如:  </p><ul><li><a href="http://example.com/index.html" target="_blank" rel="noopener">http://example.com/index.html</a></li><li><a href="http://example.com/us/index.html" target="_blank" rel="noopener">http://example.com/us/index.html</a></li></ul><p>那么匹配规则为:   </p><p><strong><code>|http://example.com</code></strong>  </p><p>如果匹配以 <code>example.com</code>结尾的网址,例如:  </p><ul><li><a href="http://sandbox.example.com" target="_blank" rel="noopener">http://sandbox.example.com</a></li><li><a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></li><li><a href="http://www.beta.example.com" target="_blank" rel="noopener">http://www.beta.example.com</a></li></ul><p>那么匹配规则为:<br><strong><code>example.com|</code></strong>  </p><h4 id="4-通过域名匹配"><a href="#4-通过域名匹配" class="headerlink" title="4. 通过域名匹配"></a>4. 通过域名匹配</h4><p>比如我想匹配所有来自 <code>ads.example.com</code> 这个域名的网址  </p><ul><li><a href="http://ads.example.com/foo.gif" target="_blank" rel="noopener">http://ads.example.com/foo.gif</a></li><li><a href="http://server1.ads.example.com/foo.gif" target="_blank" rel="noopener">http://server1.ads.example.com/foo.gif</a></li><li><a href="https://ads.example.com:8000/" target="_blank" rel="noopener">https://ads.example.com:8000/</a></li></ul><p>而不想匹配:  </p><ul><li><a href="http://ads.example.com.ua/foo.gif" target="_blank" rel="noopener">http://ads.example.com.ua/foo.gif</a></li><li><a href="http://example.com/redirect/http://ads.example.com/" target="_blank" rel="noopener">http://example.com/redirect/http://ads.example.com/</a></li></ul><p>那么匹配规则为: <strong><code>||ads.example.com^</code></strong> </p><h4 id="5-高级匹配规则"><a href="#5-高级匹配规则" class="headerlink" title="5. 高级匹配规则"></a>5. 高级匹配规则</h4><p>假如我有这样的需求:</p><ol><li>我只匹配来自 example.com 这个域名或其子域名的地址;</li><li>但不匹配 foo.example.com 这个子域名已经它的子域名</li><li>只匹配 图片或js文件的请求地址</li></ol><p>那么这个匹配规则为:</p><p><strong><code>||example.com^$script,image,domain=example.com|~foo.example.com</code></strong>  </p><p>那么 地址 <code>http://ads.example.com/foo.gif</code> 就能被匹配上。</p><h4 id="6-排除在规则之外"><a href="#6-排除在规则之外" class="headerlink" title="6. 排除在规则之外"></a>6. 排除在规则之外</h4><p>比如我不想让 <code>http://ads.example.com/notbanner/1.png</code>通过匹配<br>但是希望 <code>http://ads.example.com/notbanner/</code>下的所有 js 文件通过匹配</p><p>那么匹配规则:  </p><p><strong><code>@@||ads.example.com/notbanner^$~script</code></strong></p><h5 id="排除整个网站的网址"><a href="#排除整个网站的网址" class="headerlink" title="排除整个网站的网址"></a>排除整个网站的网址</h5><p>比如要排除 所有 域名<code>example.com</code>的网站</p><p>那么匹配规则如下:  </p><p><strong><code>@@||example.com^$document</code></strong></p><p>假如我们想注释掉一个规则是否支持呢？<br>答案是<strong>肯定的</strong>。  </p><p>例如: <code>!|http://example.com</code>  </p><h3 id="SS-中编辑"><a href="#SS-中编辑" class="headerlink" title="SS 中编辑"></a>SS 中编辑</h3><p>下面 我以 <code>ShadowsocksX-NG</code>-1.8.2 版本为例来说明一下如何编辑自定义<code>PAC规则</code></p><p><img src="/img/ss/ss_1.jpg" alt=""></p><p><img src="/img/ss/ss_2.jpg" alt=""></p><p>配置完之后最好点击一下 <code>从GFW List 更新PAC</code> 按钮。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;科学上网，SS是一大利器。它的实现原理 就是墙外一台服务器，墙内一台服务器(也就是我们的客户端)，两台服务器之间加密通讯，防火墙因为无法判定用户访问的网站是否在防火墙列表，所以放行,这样就可以通过墙外服务器做代理啦。但我们知道，任何网站都通过墙外服务器是&lt;code&gt;不明智的
      
    
    </summary>
    
      <category term="Tools" scheme="http://aicodeing.github.io/categories/Tools/"/>
    
    
      <category term="SS" scheme="http://aicodeing.github.io/tags/SS/"/>
    
      <category term="PAC" scheme="http://aicodeing.github.io/tags/PAC/"/>
    
  </entry>
  
  <entry>
    <title>KMP 算法及模式匹配</title>
    <link href="http://aicodeing.github.io/KMP-%E7%AE%97%E6%B3%95%E5%8F%8A%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://aicodeing.github.io/KMP-算法及模式匹配/</id>
    <published>2018-08-31T10:39:25.000Z</published>
    <updated>2019-05-29T11:19:08.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h2><p>字符串的模式匹配 通常是 定位一个子串在一个字符串中的位置。例如 <code>String.indexOf()</code>方法。  </p><h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>子串称为 <code>模式串</code></p><h3 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h3><p>思想:从左往右一个字符一个字符的匹配，如果匹配的过程中有某一个字符不匹配，主串回退到本次匹配开始位置的下一个位置，模式串回退到第一位，然后重新开始匹配。<br>过程如下:<br><img src="/img/kmp/kmp_1.jpg" alt=""><br>指针 i 指向主串第一个位置，j指向模式串第一个位置<br><img src="/img/kmp/kmp_2.jpg" alt=""><br>当出现不一致情况时:<br><img src="/img/kmp/kmp_3.jpg" alt="">  </p><p>将指针 <code>i</code> 回到 <code>B</code> 的位置 ;将指针 <code>j</code> 回退到 <code>A</code>的位置。<br><img src="/img/kmp/kmp_4.jpg" alt=""> </p><p><code>Java JDK</code> 中 <code>String.indexOf</code>实现就是该思想。该匹配过程易于理解，且在某些应用场合，如文本编辑等，效率也较高。但是时间复杂度比较高，达到了 <code>O(n^2)</code>。</p><p><strong>JDK实现</strong>:<br><strong>实现1:</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount, <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fromIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">        <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="comment">//查找第一个字母</span></span><br><span class="line">            <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">                <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="comment">//找到第一个字母匹配的 i,开始 匹配第2个字符，并以此循环匹配剩余字符</span></span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++) ;</span><br><span class="line">                <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相同思想的其他方式:<br><strong>实现2:</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount, <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fromIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = sourceOffset + fromIndex;</span><br><span class="line">        <span class="keyword">int</span> j = targetOffset;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sourceCount &amp;&amp; j &lt; targetCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source[i] == target[j]) &#123;<span class="comment">//继续比较后续字符</span></span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//指针回溯，重新开始匹配</span></span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = targetOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= targetCount) &#123;<span class="comment">//匹配完成</span></span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>分析:</strong><br>按照上图中的示例，主串 A <strong>B</strong> <strong>C</strong> D E F A B D J K。 模式串 A B D<br>常规算法中 除了 主串中 粗体字母 B 和 C 比较了两次以外，其他字母均只和模式串比较一次。在这种情况下，此算法的时间复杂度为O(n+m)。其中n 和m 分别是主串和模式串的长度。  </p><p>然而，在有些情况下，该算法的效率却很低。例如，当模式串为 ‘00000001’，主串为‘0000 0000 0000 0000 0001’时，由于模式中前7个字符均为‘0’，，又，主串中前 19 个字符均为 ‘0’，每趟比较都在模式的最后一个字符出现不等，此时需将指针 i 回溯到 i -6 的位置上，并从模式的第一个字符开始重新比较，整个匹配过程中指针i 需要回溯 12次,则在算法 ——<strong>实现2</strong> 中 while 循环的次数为 13 <em> 8 _(index </em> m)_。<br>    可见，算法实现2 在最坏情况下时间复杂度为O(n*m)。这种情况在只有 0，1 两种字符的文本处理中经常出现，因为在主串中可能存在多个和模式串“部分匹配”的子串，因为引起指针 <code>i</code>的多次回溯。 <code>01</code>串可以用在许多应用之中。比如，一些计算机的图形显示就是把画面表示为一个01串，一页书就是一个几百万个0和1组成的串。在二进制计算机上实际上处理的都是01串。一个字符的ASCII码也可以看成是8位二进制的01串。  </p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><code>D.E.Knuth</code>、<code>J.H.Morris</code>和<code>V.R.Pratt</code> 发明了<code>KMP</code>，该算法主要解决的问题就是 前面提到的<code>常规算法</code>需要多次回溯指针。<br><img src="/img/kmp/kmp_5.jpg" alt=""><br>如图所示，当 <code>i=2；j=2</code>模式匹配失败时,会经历 <code>i = 1,i = 2...</code>直到 指针 <code>i</code>指向<code>i = 6;</code>而<code>j</code>需要由<code>j = 2</code>回溯到<code>j = 0</code>。示例中这种情况还是比较理想的，我们也就是多比较了几次而已。但 对与模式串为 ‘00000001’，主串是‘0000 0000 0000 0000 0001’，每次 <code>i</code>指针更新一次，<code>j</code>指针都是到最后一个位置才知道不匹配，然后 <code>i和j</code>回溯，这个效率显然很低。那么<code>KMP</code>的思想呢?  </p><p><strong><code>KMP</code></strong>希望利用 <strong>前面已经匹配的信息，来避免 <code>i</code>指针的回溯，即<code>i</code>指针不回溯，修改<code>j</code>指针，让模式串尽量地移动到有效的位置</strong>  </p><p><strong><code>KMP</code></strong>想解决的问题是 <strong>当某个字符与主串不匹配时，我们应该知道<code>j</code>指针要移动到哪？</strong>   </p><p>我们看下规律:<br>当出现不匹配时:<br><img src="/img/kmp/kmp_6.jpg" alt=""><br>如图，C 和D 不匹配了，我们要把 <code>j</code>移动到哪？显然是 第 0 个位置，因为前面 i = 2 的位置是一个A，模式串的第一个字符也是A。<br><img src="/img/kmp/kmp_7.jpg" alt="">  </p><p>再看看另外一个示例:<br><img src="/img/kmp/kmp_8.jpg" alt=""><br>把指针 j 移到 j = 2的位置，因为前面两个字母一样的:<br><img src="/img/kmp/kmp_9.jpg" alt=""></p><p>我们可以大概看出一些规律，<strong>当匹配失败的时候，<code>j</code>要移动的下一个位置 <code>k</code>，它前面的<code>k</code>个字符和<code>i</code>之前的最后k个字符是一样的。</strong><br>有:<br><strong>‘p(0)p(1) …p(k-1)’ = ‘s(i-k)s(i-k+1)…s(i-1)’</strong><br><em>p 是模式串，s是主串</em><br>而已经得到的“部分匹配”的结果是:<br><strong>‘p(j-k)p(j-k+1)…p(j-1)’ = ‘s(i-k)s(i-k+1)…s(i-1)’</strong><br> ==&gt;<br><strong>‘p(0)p(1) …p(k-1)’ = ‘p(j-k)p(j-k+1)…p(j-1)’</strong>  </p><p>即 <strong>P[0 ~ k-1] = P[j-k ~ j-1]</strong></p><p> 那么如何求解 <code>k</code>就是 <code>KMP算法</code>的核心问题了。也即是计算每一个位置 <code>j</code>对应的<code>k</code>。所以用一个<code>数组next</code> 保持 <code>k</code>。  </p><pre><code>next[j] = k</code></pre><p>表示当S(i) != P(j)时，<code>j指针</code>需要回溯的位置。<br>算法表示:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] target) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] p = target;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码在数据结构中直接给出来，那么为什么这样处理呢？<br>当<code>j =0</code>时 如果出现不匹配:  </p><p> <img src="/img/kmp/kmp_11.jpg" alt=""><br> 这种情况下 j 已经在最左边了，不能再移动了，这时候需要i指针后移，所以代码中有 </p><pre><code>next[0] = -1;初始化。  </code></pre><p> 当j = 1时:<br>  <img src="/img/kmp/kmp_12.jpg" alt=""><br>  指针 j 一定会回溯到 0 的位置，因为它前面也只有这个位置了。<br>  再看看非边界情况:<br>  <img src="/img/kmp/kmp_13.jpg" alt=""></p><p>  出现匹配不通过的位置 j和 下一个回溯位置 k 的字符相同时， j+1 位置对应的k 和 j 位置对应的k 的关系是  <code>next[j+1] = next[j]+1</code><br>即<strong>当 <code>P[k] = P[j]</code></strong>时有:<br>  <code>next[j+1] = next[j]+1</code>  </p><p>  这个结论也可以通过数学证明:<br>  因为 <code>p(j)</code>之前已经有 <code>P[0 ~ k-1] = P[j-k ~ j-1]</code>。<br>  如果 <code>P[k] = P[j]</code> 则 <code>P[0 ~ k-1] +P[k] = P[j-k ~ j-1] + P[j]</code><br>即有<code>P[0 ~ k] = P[j-k ~ j]</code> =&gt; <code>next[j+1] = k+1 = next[j]+1</code></p><p><strong>当 <code>P[k] != P[j]</code>时:</strong><br>如图:<br><img src="/img/kmp/kmp_14.jpg" alt=""><br>代码中 对于 不相等的情况 <code>k = next[k];</code><br><img src="/img/kmp/kmp_15.jpg" alt="">  </p><p>所以有 <code>k = next[k];</code> </p><p>至此，我们获得了 <code>next数组</code>  </p><p>以下是<code>KMP</code>算法的实现:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf_KMP</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount, <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = sourceOffset + fromIndex;</span><br><span class="line">       <span class="keyword">int</span> j = targetOffset;</span><br><span class="line">       <span class="keyword">int</span>[] next = getNext_old(target);</span><br><span class="line">       <span class="keyword">while</span> (i &lt; sourceCount &amp;&amp; j &lt; targetCount) &#123;</span><br><span class="line">           <span class="keyword">if</span> (j == -<span class="number">1</span> || source[i] == target[j]) &#123;</span><br><span class="line">               ++i;</span><br><span class="line">               ++j;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               j = next[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (j &gt;= targetCount) &#123;</span><br><span class="line">           <span class="keyword">return</span> i - j;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出相对于 <code>常规算法</code> <code>i</code>就不需要回溯了。</p><p>该算法还可以进一步优化:<br><img src="/img/kmp/kmp_16.jpg" alt=""><br>显然，当通过 next算法获取 到的next 数组为[-1,0,0,1]<br>所以可以把j 移动到第1个元素:<br><img src="/img/kmp/kmp_17.jpg" alt=""><br>其实这一步是完全没有意义的，因为 后面的B 已经不匹配了，那前面的B 也一定不匹配了，同样的情况还发生在第 2 个元素A上。<br>显然当<code>p[j] = P[next[j]]</code>时，我们可以进一步处理:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] target) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] p = target;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[++j] == p[++k]) &#123; <span class="comment">// 当两个字符相等时要跳过</span></span><br><span class="line">                    next[j] = next[k];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    next[j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即当 两个字符相等时，跳过比较。</p><p>以上就是 KMP 算法的分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串的模式匹配&quot;&gt;&lt;a href=&quot;#字符串的模式匹配&quot; class=&quot;headerlink&quot; title=&quot;字符串的模式匹配&quot;&gt;&lt;/a&gt;字符串的模式匹配&lt;/h2&gt;&lt;p&gt;字符串的模式匹配 通常是 定位一个子串在一个字符串中的位置。例如 &lt;code&gt;String.
      
    
    </summary>
    
      <category term="算法" scheme="http://aicodeing.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://aicodeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP" scheme="http://aicodeing.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>git删除远程branch</title>
    <link href="http://aicodeing.github.io/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8Bbranch/"/>
    <id>http://aicodeing.github.io/git删除远程branch/</id>
    <published>2018-01-12T09:44:08.000Z</published>
    <updated>2019-05-29T11:19:08.298Z</updated>
    
    <content type="html"><![CDATA[<h5 id="删除远端分支"><a href="#删除远端分支" class="headerlink" title="删除远端分支"></a>删除远端分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch&gt;<span class="comment"># Git version 1.7.0 or newser</span></span><br><span class="line">git push origin :&lt;branch&gt;<span class="comment"># Git versions older than 1.7.0</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --delete &lt;branch&gt;</span><br><span class="line">git branch -d &lt;branch&gt;<span class="comment"># Shorter version</span></span><br><span class="line">git branch -D &lt;branch&gt;<span class="comment"># Force to delete un-merged branch</span></span><br></pre></td></tr></table></figure><h5 id="删除本地remote-tracking分支"><a href="#删除本地remote-tracking分支" class="headerlink" title="删除本地remote-tracking分支"></a>删除本地remote-tracking分支</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch --delete --remotes &lt;remote/branch&gt;</span><br><span class="line">git branch -dr &lt;remote/branch&gt;<span class="comment"># Shorter</span></span><br><span class="line"></span><br><span class="line">git fetch &lt;remote&gt; --prune<span class="comment"># Delete multiple obsolete tracking branches</span></span><br><span class="line">git fetch &lt;remote&gt; -p <span class="comment"># Shorter</span></span><br></pre></td></tr></table></figure><h5 id="简单的讲"><a href="#简单的讲" class="headerlink" title="简单的讲"></a>简单的讲</h5><p>当你需要删除本地或远端分支时，记住这里<code>三个不同的分支</code>。</p><ol><li>本地分支<code>X</code></li><li>远端分支<code>X</code></li><li>本地remote-tracking分支<code>origin/X</code>，用于追踪远端分支<code>X</code></li></ol><p><img src="/img/git_origin.png" alt=""></p><p>删除remote-tracking分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -dr origin/bugfix</span><br></pre></td></tr></table></figure></p><p><img src="/img/git_delete_remote_tracking.png" alt=""></p><p>删除remote分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete bugfix</span><br></pre></td></tr></table></figure></p><p><img src="/img/git_delete_remote.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;删除远端分支&quot;&gt;&lt;a href=&quot;#删除远端分支&quot; class=&quot;headerlink&quot; title=&quot;删除远端分支&quot;&gt;&lt;/a&gt;删除远端分支&lt;/h5&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin --delete &amp;lt;branch&amp;gt;	&lt;span class=&quot;comment&quot;&gt;# Git version 1.7.0 or newser&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin :&amp;lt;branch&amp;gt;		&lt;span class=&quot;comment&quot;&gt;# Git versions older than 1.7.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="http://aicodeing.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://aicodeing.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>神经网络01</title>
    <link href="http://aicodeing.github.io/Neural_Networks01/"/>
    <id>http://aicodeing.github.io/Neural_Networks01/</id>
    <published>2018-01-07T05:42:56.000Z</published>
    <updated>2019-05-29T11:19:08.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络?"></a>什么是神经网络?</h2><p>关于这个问题 最好的解释是阅读 Michael Nielsen 的开源教材 <a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">《Neural Networks and Deep Learning》</a><br>在本文中介绍什么是神经网络也依托于这教材。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是神经网络&quot;&gt;&lt;a href=&quot;#什么是神经网络&quot; class=&quot;headerlink&quot; title=&quot;什么是神经网络?&quot;&gt;&lt;/a&gt;什么是神经网络?&lt;/h2&gt;&lt;p&gt;关于这个问题 最好的解释是阅读 Michael Nielsen 的开源教材 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="AI" scheme="http://aicodeing.github.io/categories/AI/"/>
    
    
      <category term="neural network" scheme="http://aicodeing.github.io/tags/neural-network/"/>
    
      <category term="deep learn" scheme="http://aicodeing.github.io/tags/deep-learn/"/>
    
      <category term="AI" scheme="http://aicodeing.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Android属性动画的实现(动画启动)-2</title>
    <link href="http://aicodeing.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%8A%A8%E7%94%BB%E5%90%AF%E5%8A%A8-2/"/>
    <id>http://aicodeing.github.io/深入理解Android属性动画的实现-动画启动-2/</id>
    <published>2017-12-21T13:46:13.000Z</published>
    <updated>2019-05-29T11:19:08.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性动画的启动分析"><a href="#属性动画的启动分析" class="headerlink" title="属性动画的启动分析"></a>属性动画的启动分析</h3><p>在本文中,我们会分析属性动画如何启动的而且和Andoid <code>黄油计划</code>有什么关系</p><p>我们看看 <code>ObjectAnimator.start()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnimationHandler.getInstance().autoCancelBasedOn(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">            Log.d(LOG_TAG, <span class="string">"Anim target, duration: "</span> + getTarget() + <span class="string">", "</span> + getDuration());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mValues.length; ++i) &#123;</span><br><span class="line">                PropertyValuesHolder pvh = mValues[i];</span><br><span class="line">                Log.d(LOG_TAG, <span class="string">"   Values["</span> + i + <span class="string">"]: "</span> +</span><br><span class="line">                    pvh.getPropertyName() + <span class="string">", "</span> + pvh.mKeyframes.getValue(<span class="number">0</span>) + <span class="string">", "</span> +</span><br><span class="line">                    pvh.mKeyframes.getValue(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AnimationHandler.getInstance().autoCancelBasedOn(this)</code> cancel 相同Target和相同属性的动画<br>AnimationHandler 实例在线程局部单例。<code>autoCancelBasedOn(this)</code>会遍历 <code>AnimationHandler</code>实例持有的所有未完成的 <code>ValueAnimator</code>实例，cancel 掉符合条件的动画。</p><a id="more"></a><p>紧接着 <code>super.start()</code> 调用了<code>ValueAnimator.start()</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     start(<span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用了带参数的 <code>start</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mReversing = playBackwards;</span><br><span class="line">        </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">        mStarted = <span class="keyword">true</span>;</span><br><span class="line">        mPaused = <span class="keyword">false</span>;</span><br><span class="line">        mRunning = <span class="keyword">false</span>;</span><br><span class="line">        mAnimationEndRequested = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Resets mLastFrameTime when start() is called, so that if the animation was running,</span></span><br><span class="line">        <span class="comment">// calling start() would put the animation in the</span></span><br><span class="line">        <span class="comment">// started-but-not-yet-reached-the-first-frame phase.</span></span><br><span class="line">        mLastFrameTime = <span class="number">0</span>;</span><br><span class="line">        AnimationHandler animationHandler = AnimationHandler.getInstance();</span><br><span class="line">        animationHandler.addAnimationFrameCallback(<span class="keyword">this</span>, (<span class="keyword">long</span>) (mStartDelay * sDurationScale));</span><br><span class="line"></span><br><span class="line"> ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们略去与主流程无关的逻辑代码。这个方法标记了动画的状态，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mStarted = <span class="keyword">true</span>;</span><br><span class="line">mPaused = <span class="keyword">false</span>;</span><br><span class="line">mRunning = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>然后这个方法结束啦，有没有很疑惑？有没有很懵逼？动画怎么执行的？什么时候执行的？<br>要解答这问题，我们还是要分析 这两行不起眼的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimationHandler animationHandler = AnimationHandler.getInstance();</span><br><span class="line">animationHandler.addAnimationFrameCallback(<span class="keyword">this</span>, (<span class="keyword">long</span>) (mStartDelay * sDurationScale));</span><br></pre></td></tr></table></figure><p>第一行在当前线程获取 <code>AnimationHandler</code>实例；<br>第二行注册了一个callback。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register to get a callback on the next frame after the delay.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            getProvider().postFrameCallback(mFrameCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</span><br><span class="line">            mAnimationCallbacks.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">***注释说明:callback 会在delay 时间后的下一个 frame 获得回调。***</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">   getProvider().postFrameCallback(mFrameCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码 做了一件事情:保证一个<code>ValueAnimator</code>对象只向Provider注册一次 <code>mFrameCallback</code></p><p>瞅瞅 <code>getProvider</code>是啥？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AnimationFrameCallbackProvider <span class="title">getProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProvider = <span class="keyword">new</span> MyFrameCallbackProvider();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mProvider;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建了一个 <code>MyFrameCallbackProvider</code>实例， <code>MyFrameCallbackProvider</code> 继承  <code>AnimationFrameCallbackProvider</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimationFrameCallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postCommitCallback</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getFrameTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getFrameDelay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFrameDelay</span><span class="params">(<span class="keyword">long</span> delay)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnimationFrameCallbackProvider</code>接口定义了一些回调接口，按照注释说明主要作用是 提高 <code>ValueAnimator</code>的可测性，通过这个接口隔离，我们可以自定义 定时脉冲，而不用使用系统默认的 <code>Choreographer</code>,这样我们可以在测试中使用任意的时间间隔的定时脉冲.既然可以方便测试，那肯定有API来更改Provider 吧？</p><p>果不其然，我们猜对了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvider</span><span class="params">(AnimationFrameCallbackProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">       mProvider = <span class="keyword">new</span> MyFrameCallbackProvider();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       mProvider = provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ValueAnimator</code>提供了一个 <code>setProvider</code> 通过自定义的Provider 提供我们想要的任意时间间隔的回调，来更新动画。</p><p>明白了 接口<code>AnimationFrameCallbackProvider</code>的作用，也知道了一个新的名词<code>Choreographer</code>,它就是 <strong><em>Android 黄油计划</em></strong> 的核心。使用vsync（垂直同步）来协调View的绘制和动画的执行间隔。关于 <code>Choreographer</code> 在文章最后会做进一步解释<br>我们知道了默认情况下系统使用<code>Choreographer</code>,我们可以简单的认为 它是一个与 绘制和动画有关的 <em><strong>消息处理器</strong></em> 。<br>继续我们的 代码 <code>AnimationHandler.addAnimationFrameCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAnimationFrameCallback</span><span class="params">(<span class="keyword">final</span> AnimationFrameCallback callback, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mAnimationCallbacks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">       getProvider().postFrameCallback(mFrameCallback);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;</span><br><span class="line">       mAnimationCallbacks.add(callback);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行了 <code>getProvider().postFrameCallback(mFrameCallback)</code> 通过上面的分析我们知道 <code>getProvider()</code> 得到的是一个<code>MyFrameCallbackProvider</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default provider of timing pulse that uses Choreographer for frame callbacks.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrameCallbackProvider</span> <span class="keyword">implements</span> <span class="title">AnimationFrameCallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Choreographer mChoreographer = Choreographer.getInstance();</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(Choreographer.FrameCallback callback)</span> </span>&#123;</span><br><span class="line">           mChoreographer.postFrameCallback(callback);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCommitCallback</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">           mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> mChoreographer.getFrameTime();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFrameDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Choreographer.getFrameDelay();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrameDelay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">           Choreographer.setFrameDelay(delay);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注释说明系统默认使用的 <code>Choreographer</code>做定时脉冲来协调 frame 的更新 。 </p><p><code>MyFrameCallbackProvider.postFrameCallback()</code>方法调用了<code>mChoreographer.postFrameCallback(callback)</code> 这里说明一下 Choreographer 实例也是线程局部单例的。从这些信息中我们知道了动画可以在子线程中执行的(注意:这不意味着可以在子线程更新UI)，但是这个子线程必须有Looper。<br>接着分析 <code>Choreographer.postFrameCallback</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallback</span><span class="params">(FrameCallback callback)</span> </span>&#123;</span><br><span class="line">    postFrameCallbackDelayed(callback, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callback must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">                callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">   <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">      mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">      <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">          scheduleFrameLocked(now);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">          msg.arg1 = callbackType;</span><br><span class="line">          msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">          mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">动画使用的 `callbackType`为 `CALLBACK_ANIMATION`，而默认支持 三种类型：</span><br><span class="line"></span><br><span class="line"> `CALLBACK_INPUT`:处理输出相关的回调，最先被处理  </span><br><span class="line"> `CALLBACK_ANIMATION`:处理动画相关的回调，在 `CALLBACK_TRAVERSAL`类型之前处理  </span><br><span class="line"> `CALLBACK_TRAVERSAL`: 处理View 的layout 和 draw。该类型在所有其他异步消息处理完后开始处理，也基于这一点保证了界面不卡顿。</span><br><span class="line"> </span><br><span class="line"> 每一个类型的 `callbackType` 都拥有一个`CallbackQueue` 我们的动画callback 会通过 `mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);` 保存在 `CallbackQueue`中成为一个链表中的一个节点。  </span><br><span class="line"> 处理完 callback 之后 下面会执行`scheduleFrameLocked()`  </span><br><span class="line"> </span><br><span class="line"> ```java</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">          Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">          msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">          mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 默认情况下<code>USE_VSYNC</code>为true，当然设备厂商也可以设置为 false。如果 为false 会以 10 ms 为间隔计算下一次 doFrame 的时间，然后使用Handler来处理。  </p><p> 我们看看 <code>scheduleVsyncLocked()</code> 这行代码做了何事?  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>mDisplayEventReceiver</code> 当<code>USE_VSYNC</code>为true 时 实例化成 <code>FrameDisplayEventReceiver</code>对象 ，它主要是和 native层 做交互，协调 vsync 信号。<br> <code>mDisplayEventReceiver.scheduleVsync()</code> 请求当下一帧开始时同步vsync信号。</p><p> 当vsync 信号来时 回调 JNI 层会回调<code>DisplayEventReceiver.dispatchVsync</code>方法 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>FrameDisplayEventReceiver</code>实现了<code>doVsync</code>方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">           <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">           ....</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">           <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        ....</span><br><span class="line">               timestampNanos = now;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">               ....log</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mTimestampNanos = timestampNanos;</span><br><span class="line">           mFrame = frame;</span><br><span class="line">           Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">           doFrame(mTimestampNanos, mFrame);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 主要实现:根据JNI层的 <code>timestampNanos</code>纳秒值计算成毫秒，通过 Handler 执行<br> <code>Runable</code>，即执行了<code>doFrame(mTimestampNanos, mFrame);</code>这行代码。  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">     <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">     startNanos = System.nanoTime();</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">     <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">         <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">     ....</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">         ....</span><br><span class="line">         frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">....</span><br><span class="line">          scheduleVsyncLocked();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">       mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">       mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">         AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">         mFrameInfo.markInputHandlingStart();</span><br><span class="line">         doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">         mFrameInfo.markAnimationsStart();</span><br><span class="line">         doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">         mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">         doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">         doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         AnimationUtils.unlockAnimationClock();</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">     &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 与动画相关的关键代码: </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mFrameInfo.markAnimationsStart();</span><br><span class="line">doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br></pre></td></tr></table></figure><p> 以下是 doCallbacks的实现，有没有感觉即将看见胜利的曙光？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="comment">//取出可以执行的CallbackRecord 链表。</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                   now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line">  ....略去与动画无关的代码</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">           <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">.... log</span><br><span class="line"><span class="comment">//循环执行链表</span></span><br><span class="line">               c.run(frameTimeNanos);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">               mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                   recycleCallbackLocked(callbacks);</span><br><span class="line">                   callbacks = next;</span><br><span class="line">               &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 所以该方法最核心的功能是找到需要执行的 <code>CallbackRecord</code>链表，然后循环执行 它们的 <code>run</code>方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">       <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">       <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">               ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ((Runnable)action).run();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 在前面 注册回调<code>postFrameCallbackDelayed</code>时 token 是 <code>FRAME_CALLBACK_TOKEN</code> 所以执行 run 方法中的第一个if 分支<code>((FrameCallback)action).doFrame(frameTimeNanos);</code><br>  回调     <code>FrameCallback.doFrame(frameTimeNanos)</code> 方法。<br>  下面是 <code>Choreographer.FrameCallback</code> 的实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">          doAnimationFrame(getProvider().getFrameTime());</span><br><span class="line">          <span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              getProvider().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p> 看到<code>doAnimationFrame(getProvider().getFrameTime());</code>这一行代码，我们已经确认，我们的动画逻辑即将开始了。<br> 我们先搁置<code>doAnimationFrame</code>这行代码，先分析完 <code>doFrame</code> 回调。  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    getProvider().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里如果 <code>mAnimationCallbacks.size &gt;0</code>会再次将该 callback 注册给 <code>Choreographer</code>。为什么还要注册一次呢？之前不是注册过一次了吗？难道<code>Choreographer</code>把这个callback 释放了。<br> 我们回到<code>Choreographer.doCallbacks</code>方法。<br> 有一段 final 括号体中的代码我们没有分析  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">            recycleCallbackLocked(callbacks);</span><br><span class="line">            callbacks = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里调用了<code>recycleCallbackLocked(callbacks);</code>来回收整个链表中的节点记录。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleCallbackLocked</span><span class="params">(CallbackRecord callback)</span> </span>&#123;</span><br><span class="line">   callback.action = <span class="keyword">null</span>;</span><br><span class="line">   callback.token = <span class="keyword">null</span>;</span><br><span class="line">   callback.next = mCallbackPool;</span><br><span class="line">   mCallbackPool = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当 <code>mAnimationCallbacks.size &gt;0</code>时 需要再次添加回调，以便来获取下一帧的回调。<br> 当动画 paused 或 end 后 mAnimationCallbacks 会相应的remove callback。</p><h3 id="小结1"><a href="#小结1" class="headerlink" title="小结1"></a>小结1</h3><p>到目前为止 我们知道了当调用 <code>ObjectAnimator.start()</code>后:  </p><ol><li>取消之前的动画对相同属性,相同target的动画，防止出现多个动画同时更新 Target 的属性，出现错乱。不过这一行为默认是关闭的,设置<code>ObjectAnimator.setAutoCancel(true)</code>来打开;  </li><li>执行 <code>ValueAnimator.start()</code>方法；  </li><li><code>AnimationHandler.addAnimationFrameCallback</code>向<code>Choreographer</code>注册<code>Choreographer.FrameCallback</code>回调,通过该回调获得渲染时间脉冲的回调;  </li><li>通过系统的<code>vsync</code>垂直同步信号来协调 cpu,gpu 和渲染的时序;  </li><li><code>Choreographer</code> 获得 <code>vsync</code>信号后 根据 当前帧的<code>纳秒</code>来查找哪些 <code>Choreographer.FrameCallback</code>会被执行。  </li><li>执行<code>AnimationHandler.doAnimationFrame()</code>方法，开始真正的动画逻辑。</li></ol><h3 id="动画属性更新"><a href="#动画属性更新" class="headerlink" title="动画属性更新"></a>动画属性更新</h3><p>刚才我们分析到 <code>AnimationHandler.doAnimationFrame()</code> 方法，现在看看这个方法的功能是什么?  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> size = mAnimationCallbacks.size();</span><br><span class="line">   <span class="keyword">long</span> currentTime = SystemClock.uptimeMillis();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;</span><br><span class="line">            callback.doAnimationFrame(frameTime);</span><br><span class="line">            <span class="keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;</span><br><span class="line">                getProvider().postCommitCallback(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                      commitAnimationFrame(callback, getProvider().getFrameTime());</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;<span class="comment">//for</span></span><br><span class="line">   cleanUpList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要作用是遍历所有的 <code>AnimationFrameCallback</code>。 这个<code>AnimationFrameCallback</code> 是什么？什么时候添加到<code>mAnimationCallbacks</code>的？<br>刚才分析<code>Choreographer.FrameCallback.doFrame</code>时提到过，在动画paused 或 end 时会将<code>AnimationFrameCallback</code> 从<code>mAnimationCallbacks</code>中移除，如果<code>mAnimationCallbacks</code>的size 为0 就不再向<code>Choreographer</code>注册 callback。也就代表没有动画要被执行了。<br>其实 <code>AnimationFrameCallback</code>就是 <code>ObjectAnimator</code>或<code>ValueAnimaor</code>本身。我们看看 <code>ValueAnimator</code>的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> <span class="keyword">implements</span> <span class="title">AnimationHandler</span>.<span class="title">AnimationFrameCallback</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 这些<code>AnimationFrameCallback</code>就是那些待执行的 <code>属性动画</code>。<br>接下来看看<code>isCallbackDue(callback, currentTime)</code>这个 <code>if</code> 判断:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCallbackDue</span><span class="params">(AnimationFrameCallback callback, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">   Long startTime = mDelayedCallbackStartTime.get(callback);</span><br><span class="line">   <span class="keyword">if</span> (startTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startTime &lt; currentTime) &#123;</span><br><span class="line">        mDelayedCallbackStartTime.remove(callback);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 当前的的 纳秒时间 判断 动画是否需要执行，因为有些动画做了<code>delay</code>可能在当前的frame 窗口不需要执行。<br><code>callback.doAnimationFrame(frameTime);</code> 这行代码 开始回调 <code>ValueAnimator.doAnimationFrame</code>方法。然后判断<code>if (mCommitCallbacks.contains(callback))</code> 为 true的话会再次向<code>Choreographer</code>注册一个<code>Runnable</code>的callback，当下一个 frame 时间到来时 执行 <code>Runnable</code>。  </p><p>我们关注<strong>重点代码</strong><code>callback.doAnimationFrame(frameTime)</code> 也即是<code>ValueAnimator.doAnimationFrame(frameTime)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">   AnimationHandler handler = AnimationHandler.getInstance();</span><br><span class="line">   <span class="keyword">if</span> (mLastFrameTime == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// First frame</span></span><br><span class="line">       <span class="comment">//如果是动画的第一次回调，注册调整到下一个 frame 窗口 再执行。</span></span><br><span class="line">       handler.addOneShotCommitCallback(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           startAnimation();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (mSeekFraction &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           mStartTime = frameTime;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">long</span> seekTime = (<span class="keyword">long</span>) (getScaledDuration() * mSeekFraction);</span><br><span class="line">           mStartTime = frameTime - seekTime;</span><br><span class="line">           mSeekFraction = -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></span><br><span class="line">    &#125;</span><br><span class="line">    mLastFrameTime = frameTime;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        mPauseTime = frameTime;</span><br><span class="line">        handler.removeCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;</span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">            mStartTimeCommitted = <span class="keyword">false</span>; <span class="comment">// allow start time to be compensated for jank</span></span><br><span class="line">        &#125;</span><br><span class="line">        handler.addOneShotCommitCallback(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ... comments</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">   <span class="keyword">boolean</span> finished = animateBasedOnTime(currentTime);</span><br><span class="line">   <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">       endAnimation();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时第一帧动画时 会调整到下一个 frame 窗口执行。如果这个动画是 delay 动画，会执行<code>startAnimation()</code>初始化动画，标记动画正在 <code>mRunning</code>，并且 对<code>PropertyValuesHolder</code>执行初始化操作–主要就是初始化<code>估值器</code>。<br>下面分析 <code>boolean finished = animateBasedOnTime(currentTime);</code><br>返回值 <code>finished</code>标记是否动画已经执行完毕。如果最后一个关键帧(Keyframe)执行完毕,这里返回true，会执行<code>endAnimation()</code>做一些状态位复位和动画结束回调等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animateBasedOnTime</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> scaledDuration = getScaledDuration();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> fraction = scaledDuration &gt; <span class="number">0</span> ?</span><br><span class="line">                    (<span class="keyword">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="number">1f</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> lastFraction = mOverallFraction;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> newIteration = (<span class="keyword">int</span>) fraction &gt; (<span class="keyword">int</span>) lastFraction;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> lastIterationFinished = (fraction &gt;= mRepeatCount + <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                    (mRepeatCount != INFINITE);</span><br><span class="line">       <span class="keyword">if</span> (scaledDuration == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 0 duration animator, ignore the repeat count and skip to the end</span></span><br><span class="line">           done = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;</span><br><span class="line">          <span class="comment">// Time to repeat</span></span><br><span class="line">          <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                   mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastIterationFinished) &#123;</span><br><span class="line">           done = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       mOverallFraction = clampFraction(fraction);</span><br><span class="line">       <span class="keyword">float</span> currentIterationFraction = getCurrentIterationFraction(mOverallFraction);</span><br><span class="line">       animateValue(currentIterationFraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>currentTime</code>是<code>Choreographer</code>发出的计时脉冲时间，纳秒计时。<br>根据 <code>currentTime</code> 计算 <code>fraction</code>系数，即动画时间流逝比。<br>然后执行<code>animateValue(currentIterationFraction)</code> 计算动画的在当前时间比例下属性动画的值，如果是 <code>ObjectAnimator</code>还会降属性值设置该<code>Target</code>。<br><code>animateValue</code>方法被 <code>ObjectAnimator</code> 重载了。我们先分析<code>ValueAnimator. animateValue(fraction)</code> 然后再分析<code>ObjectAnimator. animateValue(fraction)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">   fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">   mCurrentFraction = fraction;</span><br><span class="line">   <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        mValues[i].calculateValue(fraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">            mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>fraction</code>这个时间流逝比系数 是线性的。通过<code>mInterpolator.getInterpolation()</code>计算出我们想要的fraction。然后使用这个系数计算 <code>PropertyValuesHolder.calculateValue(fraction)</code>。<br>计算完 属性值后 执行 <code>mUpdateListeners</code>的更新操作。到目前为止我们终于知道我们经常使用的 <code>AnimatorUpdateListener.onAnimationUpdate（）</code>何时执行的了。</p><p>我们再分析 被 <code>ObjectAnimator</code>重载后的<code>animateValue(fraction)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">   <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We lost the target reference, cancel and clean up. Note: we allow null target if the</span></span><br><span class="line">    <span class="comment">/// target has never been set.</span></span><br><span class="line">    cancel();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.animateValue(fraction);</span><br><span class="line">    <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">          mValues[i].setAnimatedValue(target);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要功能是 通过调用 <code>super.animateValue()</code>计算属性的值。然后调用<code>PropertyValuesHolder.setAnimatedValue(Object)</code>来更新属性值到对应的<code>Target</code>上。</p><p><a href="http://aicoding.tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-1/" target="_blank" rel="noopener">深入理解Android属性动画的实现-1</a> 这篇文章中介绍过 <code>PropertyValuesHolder</code>具有更新属性的能力，也持有<code>关键帧</code>的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">       mProperty.set(target, getAnimatedValue());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         mTmpValueArray[<span class="number">0</span>] = getAnimatedValue();</span><br><span class="line">         mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Property</code>更新属性值。如果之前是通过 <code>propertyName</code>来初始化的动画，这里通过 <code>mSetter</code>来反射调用 set 方法，更新属性值。</p><p><a href="http://aicoding.tech/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-1/#Keyframe" target="_blank" rel="noopener">深入理解Android属性动画的实现-1</a> 这篇文章还介绍了如何通过<code>fraction</code>计算动画的属性值。这里就不在赘述。 </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到目前位置我们已经分析完 属性动画的创建—&gt; 属性动画的启动 –&gt; 属性的计算和更新。<br>这里我们再回顾一下:</p><ol><li><code>ObjectAnimator.start()</code>开始启动动画；</li><li>向<code>Choreographer</code>注册callback；</li><li><code>Choreographer</code>获得<code>vsync</code>垂直同步信号量后回调<code>Choreographer.FrameCallback.doFrame()</code>执行逻辑进入到<code>AnimationHandler</code>中；</li><li><code>AnimationHandler</code>持有 <code>AnimationFrameCallback</code>也即是<code>ValueAnimator</code>,然后执行<code>ValueAnimator.doAnimationFrame(time)</code>;</li><li><code>ValueAnimator.animateBasedOnTime(time)</code>执行，通过 <code>TimeInterpolator</code>计算最终的 时间流逝比<code>fraction</code>,然后调用<code>PropertyValuesHolder.calculateValue(fraction)</code>计算属性的值，并回调 <code>AnimatorUpdateListener.onAnimationUpdate()</code>方法。</li><li><code>PropertyValuesHolder</code>调用<code>Keyframes.getIntValue(fraction)</code>,这中间又使用到估值器<code>TypeEvaluator</code>和<code>Keyframe</code>最终结算处我们需要的属性值。</li><li>然后<code>ObjectAnimator</code>调用<code>PropertyValuesHolder.setAnimatedValue(target)</code>来更新 <code>target</code>的属性值。</li></ol><h3 id="附加知识点"><a href="#附加知识点" class="headerlink" title="附加知识点"></a>附加知识点</h3><p>文章中提到过<code>Choreographer</code>和<code>Android黄油计划</code>。其实在本文的流程分析中已经简单分析了 <code>Choreographer</code>在动画类型上的执行流程：  </p><ol><li>创建<code>DisplayEventReceiver</code>的子类<code>FrameDisplayEventReceiver</code>来与JNI 层交互。JNI层的 <code>vsync</code>信号量通过callback 这个类的 <code>dispatchVsync</code>方法来告诉应用层 可以开始新的一帧的渲染了。  </li><li><code>Choreographer</code>接收到 <code>vsync</code>信号后执行<code>doFrame(frameTimeNanos,frame)</code>方法，对三个支持的类型<code>CALLBACK_INPUT</code>,<code>CALLBACK_ANIMATION</code>,<code>CALLBACK_TRAVERSAL</code>做相应的回调。<br><strong>需要说明下:</strong>  _源码中还有一个类型<code>CALLBACK_COMMIT</code>主要处理注册 commit Runnable的需求，即延迟一个frame 的需求。因为它是一种业务辅助，不像其它三种，有明显的业务支持。所以在本文中倾向说三种支持类型，请知悉_。  </li><li>回调进入<code>Choreographer.FrameCallback.doFrame(timeNanos)</code>  </li><li>然后进入到业务层，例如 :<br><code>CALLBACK_ANIMATION</code>类型进入到<code>AnimationHandler.mFrameCallback</code>;<br><code>CALLBACK_TRAVERSAL</code>类型进入到<code>ViewRootImpl</code> 执行<code>scheduleTraversals()</code> 进而执行了<code>View.layout</code>,<code>View.measure</code>,<code>View.draw</code>方法开启View的渲染操作；  <code>CALLBACK_INPUT</code>这个类型相比前两个特殊一些，因为输入事件由另一个引擎负责。让输入引擎产生输入事件后不是立刻在 视图层产生响应。而是要等待下一个 <code>vsync</code>垂直同步信号，跟着统一的时钟脉冲来响应。所以 在<code>ViewRootImpl</code>中会使用到<code>mChoreographer.postCallback(Choreographer.CALLBACK_INPUT,mConsumedBatchedInputRunnable, null)</code>。具体这里不再展开描述。</li></ol><p>简言之，<code>Choreographer</code>就是一个消息处理器，根据 <code>vsync</code>垂直同步信号 来处理三种支持类型的回调。</p><p>至于 <code>Android黄油计划(Project Butter)</code> <code>Choreographer</code>只是其中一个重要的特性。还有其他方便的优化。例如 引入了<code>三重缓冲</code>和 JNI层的<code>vsync</code>。至于 <code>vsync</code>的好处以及和 该计划之前 的Android的渲染相比 请参考<a href="http://blog.csdn.net/michaelcao1980/article/details/43233765" target="_blank" rel="noopener">Android 4.4 Graphic系统详解（2） VSYNC的生成</a> 这篇优质文章。在这里也对该篇文章的原作者致敬。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性动画的启动分析&quot;&gt;&lt;a href=&quot;#属性动画的启动分析&quot; class=&quot;headerlink&quot; title=&quot;属性动画的启动分析&quot;&gt;&lt;/a&gt;属性动画的启动分析&lt;/h3&gt;&lt;p&gt;在本文中,我们会分析属性动画如何启动的而且和Andoid &lt;code&gt;黄油计划&lt;/code&gt;有什么关系&lt;/p&gt;
&lt;p&gt;我们看看 &lt;code&gt;ObjectAnimator.start()&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AnimationHandler.getInstance().autoCancelBasedOn(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (DBG) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Log.d(LOG_TAG, &lt;span class=&quot;string&quot;&gt;&quot;Anim target, duration: &quot;&lt;/span&gt; + getTarget() + &lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt; + getDuration());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; mValues.length; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                PropertyValuesHolder pvh = mValues[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Log.d(LOG_TAG, &lt;span class=&quot;string&quot;&gt;&quot;   Values[&quot;&lt;/span&gt; + i + &lt;span class=&quot;string&quot;&gt;&quot;]: &quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    pvh.getPropertyName() + &lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt; + pvh.mKeyframes.getValue(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&quot;, &quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    pvh.mKeyframes.getValue(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;AnimationHandler.getInstance().autoCancelBasedOn(this)&lt;/code&gt; cancel 相同Target和相同属性的动画&lt;br&gt;AnimationHandler 实例在线程局部单例。&lt;code&gt;autoCancelBasedOn(this)&lt;/code&gt;会遍历 &lt;code&gt;AnimationHandler&lt;/code&gt;实例持有的所有未完成的 &lt;code&gt;ValueAnimator&lt;/code&gt;实例，cancel 掉符合条件的动画。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://aicodeing.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://aicodeing.github.io/tags/Android/"/>
    
      <category term="动画" scheme="http://aicodeing.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
