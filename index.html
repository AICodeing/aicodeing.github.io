<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="AICoding Technical Blog" type="application/atom+xml" />






<meta name="description" content="As a blog, included a variety of technical articles">
<meta property="og:type" content="website">
<meta property="og:title" content="AICoding Technical Blog">
<meta property="og:url" content="http://aicodeing.github.io/index.html">
<meta property="og:site_name" content="AICoding Technical Blog">
<meta property="og:description" content="As a blog, included a variety of technical articles">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AICoding Technical Blog">
<meta name="twitter:description" content="As a blog, included a variety of technical articles">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://aicodeing.github.io/"/>





  <title>AICoding Technical Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?67f1e533d19b5b095ebcd8f0cd066001";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AICoding Technical Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">AICoding team</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android-ContentProvider的装置流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android-ContentProvider的装置流程/" itemprop="url">Android-ContentProvider的装载流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T19:22:00+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-ContentProvider的装置流程/" class="leancloud_visitors" data-flag-title="Android-ContentProvider的装载流程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天项目中使用了 <code>android jetpak</code>中的<code>lifecyle-process</code>组件，帮助我们管理生命周期，接入后发现不需要任何初始化操作，它的源码也比较简单，就4个文件，发现它使用<code>ContentProvider</code>的装载特性来做自动初始化操作。联想到多年前在做插件化时遇到<code>ContentProvider</code> 需要提前处理的情况。才发现，<code>Google</code>也会<code>投机取巧</code>啦。  本文我们就分析一下<code>ContentProvider</code>的装载流程。  </p>
<h3 id="1-ContentProvider-启动装载的场景"><a href="#1-ContentProvider-启动装载的场景" class="headerlink" title="1. ContentProvider 启动装载的场景"></a>1. ContentProvider 启动装载的场景</h3><p>先把结论抛出来,触发 <code>ContentProvider</code>装载的几个场景有:  </p>
<ul>
<li>进程启动，初始化Application时</li>
<li>三方应用通过<code>ContentResolver</code>调用<code>ContentProvider</code>的相关功能时</li>
</ul>
<p>我们先跟踪一下 进程启动时的场景  </p>
<h3 id="2-ContentProvider-进程启动装载"><a href="#2-ContentProvider-进程启动装载" class="headerlink" title="2. ContentProvider 进程启动装载"></a>2. ContentProvider 进程启动装载</h3><p>我们都知道 <code>Android</code>进程启动需要给定一个入口类，而每个程序的进程入口类就是<code>ActivityThread</code>。  </p>
<p><em>我们基于<code>android-28</code>，也就是<code>Android P</code></em>  </p>
<p><code>ActivityThread</code>的入口函数为<code>main</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">		  ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>会调用 <code>ActivityThread</code>的<code>attach</code>方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;<span class="comment">//我们的进程属于 非系统进程，会执行该逻辑</span></span><br><span class="line">        	  ...</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通知 AMS 执行 attachApplication 操作</span></span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//系统进程执行的逻辑，因为允许在系统进程，直接生产 Application 实例，执行生命周期方法即可</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">                mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">                ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我继续跟入 <code>ActivityManagerService</code>的<code>attachApplication</code> 方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续<code>attachApplicationLocked</code>方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//前面 获取 ProcessRecord</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">             <span class="comment">//因为系统进程已经ready ，所以这里就会向 PackageManagerService 查询 apk的所有 ContentProvider 标签对应的 ProviderInfo</span></span><br><span class="line">             <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">        	 List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">        	 </span><br><span class="line">        	 ...</span><br><span class="line">        	 </span><br><span class="line">        	<span class="comment">//到目前为止 已经有了 ContentProvider的信息了，但是 ConentProvider 还没有装载</span></span><br><span class="line">        	</span><br><span class="line">        	<span class="keyword">if</span> (app.isolatedEntryPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">                <span class="comment">// being bound to an application.</span></span><br><span class="line">                thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                        app.instr.mClass,</span><br><span class="line">                        profilerInfo, app.instr.mArguments,</span><br><span class="line">                        app.instr.mWatcher,</span><br><span class="line">                        app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                thread.bindApplication(processName, appInfo, providers, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                        <span class="keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                        getCommonServicesLocked(app.isolated),</span><br><span class="line">                        mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                        buildSerial, isAutofillCompatEnabled);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下我们没有使用 <code>Instrumentation</code>所以 会执行 最后一个 <code>else</code>  </p>
<p>以后执行时序会再次进入到 <code>ActivityThread</code>中，也就是从AMS 进程进入到了我们的App进程中 ，同时把前面的  <code>providers</code>传入。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">                String buildSerial, <span class="keyword">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">            AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            data.instrumentationName = instrumentationName;</span><br><span class="line">            data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">            data.debugMode = debugMode;</span><br><span class="line">            data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">            data.trackAllocation = trackAllocation;</span><br><span class="line">            data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">            data.persistent = persistent;</span><br><span class="line">            data.config = config;</span><br><span class="line">            data.compatInfo = compatInfo;</span><br><span class="line">            data.initProfilerInfo = profilerInfo;</span><br><span class="line">            data.buildSerial = buildSerial;</span><br><span class="line">            data.autofillCompatibilityEnabled = autofillCompatibilityEnabled;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br><span class="line">``` </span><br><span class="line"> 到目前为止，通过`Handler` 消息 将 `Binder` 进程释放，这样就避免了一个App的启动持续 Block 住系统进程  </span><br><span class="line"> </span><br><span class="line"> ```java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p> 之后又进入到了 <code>handleBindApplication</code>方法  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123;</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">	 			...</span><br><span class="line">               <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">               mInstrumentation = (Instrumentation)</span><br><span class="line">                   cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Unable to instantiate instrumentation "</span></span><br><span class="line">                   + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//按照前面的分析，如果没有 AMS 调用时没有传入 instrumentationName，就会自动生成一个</span></span><br><span class="line">		mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">     mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//生成Application实例，内部还会调用Application 的 attach 方法</span></span><br><span class="line">           app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">           app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled);</span><br><span class="line"></span><br><span class="line">           mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">           <span class="comment">// app's custom Application class</span></span><br><span class="line">           <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">               <span class="comment">// ！！！！！重点重点，这里就开启装载ContentProvider的流程</span></span><br><span class="line">                   installContentProviders(app, data.providers);</span><br><span class="line">                   <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">                   <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">                   mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">           <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                          mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                   + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//!!!!! 通过 mInstrumentation 调用 Application的 onCreate 方法</span></span><br><span class="line">               mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                     <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                     + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">           <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">           <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                   || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">               StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 通过这段代码分析，我们清楚的知道，<code>ContentProvider</code>的装载时机在 <code>Application</code>的<code>attach</code>之后，在 <code>onCreate</code>之前。这就是当初做插件化的时候，必须在<code>onCreate</code>之前替换掉 <code>ProviderInfo</code>的原因,否则装载 <code>ContentProvider</code>必定失败。  </p>
<p> 下面我们再分析一下 <code>installContentProviders</code>方法  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">           <span class="comment">//遍历装载每一个 ContentProvider</span></span><br><span class="line">           ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                   <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">           <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">               cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">               results.add(cph);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       		<span class="comment">//装载完成后通知 AMS，ContentProvider 装载完毕，后面就可以正常使用了</span></span><br><span class="line">           ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">          ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">   ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">      IContentProvider provider;</span><br><span class="line">      <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;<span class="comment">//前面传入的 holder 为null</span></span><br><span class="line">                      Context c = <span class="keyword">null</span>;</span><br><span class="line">          ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (info.splitName != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  c = c.createContextForSplit(info.splitName);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">              LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// System startup case.</span></span><br><span class="line">                  packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//通过反射得到生成一个 Provider 的实例</span></span><br><span class="line">              localProvider = packageInfo.getAppFactory()</span><br><span class="line">                      .instantiateProvider(cl, info.name);</span><br><span class="line">                      <span class="comment">//获取Provider的Binder接口</span></span><br><span class="line">              provider = localProvider.getIContentProvider();</span><br><span class="line">              <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">                        info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">                        info.applicationInfo.sourceDir);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//该方法最终会调动 Provider的 onCreate 方法</span></span><br><span class="line">              localProvider.attachInfo(c, info);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          provider = holder.provider;</span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 到目前为止，<code>ContentProvider</code> 已经启动完成。<br> 后面的操作就是建立 <code>ContentProviderHolder</code>,将 <code>ContentProviderHolder</code> 存放到<code>mProviderMap</code>,<code>mLocalProviders</code>,<code>mLocalProvidersByName</code>等集合中，方便下次使用和索引。  </p>
<p> 再回到调用栈的上一级<code>installContentProviders</code>  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">               StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">               buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">               buf.append(cpi.authority);</span><br><span class="line">               buf.append(<span class="string">": "</span>);</span><br><span class="line">               buf.append(cpi.name);</span><br><span class="line">               Log.i(TAG, buf.toString());</span><br><span class="line">           &#125;</span><br><span class="line">           ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                   <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">           <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">               cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">               results.add(cph);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 在该方法的最后执行了  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager.getService().publishContentProviders(</span><br><span class="line">               getApplicationThread(), results);</span><br></pre></td></tr></table></figure>
<p> 它会通知<code>AMS</code>,<code>AMS</code>进程会将 <code>providers</code>信息存储在 成员变量中，方便其他进程使用  </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">           List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       enforceNotIsolatedCaller(<span class="string">"publishContentProviders"</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       		<span class="comment">//获取调用者的进程信息，这里就是我们provider程序的进程信息</span></span><br><span class="line">           <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;<span class="comment">//遍历装载好的Provider</span></span><br><span class="line">               ContentProviderHolder src = providers.get(i);</span><br><span class="line">               <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//从之前解析好的ProviderInfo 列表中查找 出对应的 ContentProviderRecord</span></span><br><span class="line">               ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">               <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;<span class="comment">//因为在Provider装载之前就通过 generateApplicationProvidersLocked 方法生成了ContentProviderRecord实例，所以不会为null</span></span><br><span class="line">                   ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                   <span class="comment">//!!!! 重点:将Provider的信息记录到mProviderMap中，方便下次调用</span></span><br><span class="line">                   mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                   String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                       mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                   &#125;</span><br><span class="line">					...<span class="comment">//省略部分的操作是将等待Provider装载的状态重置</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                   	<span class="comment">//将 刚装载成功的Provider的Binder接口记录到ContentProviderRecord中，在此之前，ContentProviderRecord实例中都没有Provider 的Binder引用，都是不可用状态</span></span><br><span class="line">                       dst.provider = src.provider;</span><br><span class="line">                       dst.proc = r;</span><br><span class="line">                       dst.notifyAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   updateOomAdjLocked(r, <span class="keyword">true</span>);</span><br><span class="line">                   maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                           src.info.authority);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 从此之后，<code>ContentProvider</code>已经是Ready状态了，可以直接供使用了。  </p>
<h3 id="3-Client-调用-ContentProvider"><a href="#3-Client-调用-ContentProvider" class="headerlink" title="3. Client 调用 ContentProvider"></a>3. Client 调用 ContentProvider</h3><p>常规的调用方式是通过<code>ContentResolver</code>,获取<code>ContentResolver</code> 都是通过<code>Context</code>来实现  </p>
<p><em>android.content.Context.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>android.content.ContextWrapper.java</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getContentResolver();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们知道真正的<code>Context</code>实例是 <code>ContextImpl</code>类型的，下面分析一下<code>ContextImpl</code>的实现方式:<br><em>android.content. ContextImpl.java</em>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mContentResolver;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>mContentResolver</code> 对象是 <code>ApplicationContentResolver</code>类型的  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContentResolver</span> <span class="keyword">extends</span> <span class="title">ContentResolver</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ActivityThread mMainThread;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ApplicationContentResolver</span><span class="params">(Context context, ActivityThread mainThread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(context);</span><br><span class="line">            mMainThread = Preconditions.checkNotNull(mainThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireExistingProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseProvider</span><span class="params">(IContentProvider provider)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.releaseProvider(provider, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseUnstableProvider</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.releaseProvider(icp, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unstableProviderDied</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            mMainThread.handleUnstableProviderDied(icp.asBinder(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appNotRespondingViaProvider</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">            mMainThread.appNotRespondingViaProvider(icp.asBinder());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">resolveUserIdFromAuthority</span><span class="params">(String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ContentProvider.getUserIdFromAuthority(auth, getUserId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们以 <code>ContentResolver</code>的<code>insert</code>方法作为切入点，进行分析  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Uri <span class="title">insert</span><span class="params">(@RequiresPermission.Write @NonNull Uri url,</span></span></span><br><span class="line"><span class="function"><span class="params">                @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        Preconditions.checkNotNull(url, <span class="string">"url"</span>);</span><br><span class="line">        <span class="comment">//1.首先根据URI 找到 ConentProvider的远端Binder引用</span></span><br><span class="line">        IContentProvider provider = acquireProvider(url);</span><br><span class="line">        <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown URL "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//2.调用 ConentProvider</span></span><br><span class="line">            Uri createdRow = provider.insert(mPackageName, url, values);</span><br><span class="line">            <span class="keyword">long</span> durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">            maybeLogUpdateToEventLog(durationMillis, url, <span class="string">"insert"</span>, <span class="keyword">null</span> <span class="comment">/* where */</span>);</span><br><span class="line">            <span class="keyword">return</span> createdRow;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseProvider(provider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们分析的是 <code>ContentProvider</code>的装载流程，所以只分析 <code>acquireProvider</code>方法  </p>
<p>最终会进入到<code>ApplicationContentResolver</code>的<code>acquireProvider</code>方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>mMainThread</code> 就是 <code>ActivityThread</code> 对象  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//!!! 首先在本进程空间内查询 已经装载的 ContentProvider</span></span><br><span class="line">        <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There is a possible race here.  Another thread may try to acquire</span></span><br><span class="line">        <span class="comment">// the same provider at the same time.  When this happens, we want to ensure</span></span><br><span class="line">        <span class="comment">// that the first one wins.</span></span><br><span class="line">        <span class="comment">// Note that we cannot hold the lock while acquiring and installing the</span></span><br><span class="line">        <span class="comment">// provider since it might take a long time to run and it could also potentially</span></span><br><span class="line">        <span class="comment">// be re-entrant in the case where the provider is in the same process.</span></span><br><span class="line">        ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">            <span class="comment">//如果本进程空间内不存在ConentProvider，就委托AMS去查询</span></span><br><span class="line">                holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                        getApplicationThread(), auth, userId, stable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">        <span class="comment">// any ties in the race.</span></span><br><span class="line">        holder = installProvider(c, holder, holder.info,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">        <span class="keyword">return</span> holder.provider;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法 首先支持在本进程空间内查询 <code>ConentProvider</code>,其实就是从前面分析中提到的 <code>mProviderMap</code>中获取，在 随进程启动时装载的<code>Provider</code> 被放在<code>mProviderMap</code>中，这时就能直接访问使用了。  但也有可能需要查询不到,出现这种情况的情景如下:  </p>
<ul>
<li>请求的<code>Provider</code>需要独立进程允许，但是该进程还未启动，所以 <code>Provider</code> 未被装载。</li>
<li>请求的<code>Provider</code>是第三方程序的，需要通过<code>AMS</code> 获得。</li>
<li>请求的<code>Provider</code>是系统进程所有的，比如媒体库的<code>Provider</code>,这也需要AMS提供</li>
</ul>
<p>不管是以上三种情况的哪一种，都会进入到<code>AMS</code>， 我们选一种最长路径的情况做分析<br><mark><strong>假设我们请求的<code>Provider</code>是一个第三方APP的，但是这个App 还没有运行。</strong></mark>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           IApplicationThread caller, String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">       enforceNotIsolatedCaller(<span class="string">"getContentProvider"</span>);</span><br><span class="line">       <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">           String msg = <span class="string">"null IApplicationThread when getting content provider "</span></span><br><span class="line">                   + name;</span><br><span class="line">           Slog.w(TAG, msg);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span></span><br><span class="line">       <span class="comment">// with cross-user grant.</span></span><br><span class="line">       <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, stable, userId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>真正执行的是<code>getContentProviderImpl</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            String name, IBinder token, <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">     		<span class="comment">// First check if this content provider has been published...</span></span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">            <span class="comment">// If that didn't work, check if it exists for user 0 and then</span></span><br><span class="line">            <span class="comment">// verify that it's a singleton provider before using it.</span></span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">                <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cpi = cpr.info;</span><br><span class="line">                    <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                            cpi.name, cpi.flags)</span><br><span class="line">                            &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                        userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                        checkCrossUser = <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cpr = <span class="keyword">null</span>;</span><br><span class="line">                        cpi = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">boolean</span> providerRunning = cpr != <span class="keyword">null</span> &amp;&amp; cpr.proc != <span class="keyword">null</span> &amp;&amp; !cpr.proc.killed;</span><br><span class="line">            <span class="keyword">if</span> (providerRunning) &#123;<span class="comment">//根据我们的假设，Provider 是未运行状态</span></span><br><span class="line">            </span><br><span class="line">            ...         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先AMS 从 <code>mProviderMap</code>中获取，前面分析随进程启动而装载的Provider 在自己进程装载完成后会通过<code>publishContentProviders</code>将 <code>Provider</code>列表保持在<code>AMS</code>中，其实就是保存在AMS的<code>mProviderMap</code>中。<br>根据我们的假设 <code>Provider</code> 所在的进程还未启动，所以 <code>mProviderMap</code>中是查询不到的  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">         checkTime(startTime, <span class="string">"getContentProviderImpl: before resolveContentProvider"</span>);</span><br><span class="line">         <span class="comment">// ！！！首先通过PMS 查询 Provider的Info信息，为下一步的装载做准备</span></span><br><span class="line">         cpi = AppGlobals.getPackageManager().</span><br><span class="line">             resolveContentProvider(name,</span><br><span class="line">                            STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: after resolveContentProvider"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//如果找不大，说明未在 Manifest 文件中注册或者 程序未安装，直接返回NUll</span></span><br><span class="line">   <span class="keyword">if</span> (cpi == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//是否是singleton？其实就是 Provider在 Manifest 注册的时候是否增加了'singleUser'属性</span></span><br><span class="line">   <span class="comment">//如果 singleUser 属性设置为 true，意味着多用户环境下可以共用Provider对象。</span></span><br><span class="line">   <span class="comment">//其他情况就是系统Provider 是保持单例的</span></span><br><span class="line">   <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid);</span><br><span class="line">   <span class="keyword">if</span> (singleton) &#123;</span><br><span class="line">      userId = UserHandle.USER_SYSTEM;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//按照之前的假设，我们要访问的Provider 是不支持多用户共享的，所以需要重新装载</span></span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//后面就是一些检验Provider 的访问权限的校验，这里就不分析了</span></span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//获取目标Provider的进程信息，如果进程信息存在，说明目前进程是启动状态</span></span><br><span class="line">    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                                cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.d(TAG_PROVIDER,<span class="string">"Installing in existing process "</span> + proc);</span><br><span class="line">        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: scheduling install"</span>);</span><br><span class="line">            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通知目标进程装载指定的Provider</span></span><br><span class="line">                 proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          checkTime(startTime, <span class="string">"getContentProviderImpl: before start process"</span>);</span><br><span class="line">          <span class="comment">//如果目标进程未启动，先启动目标进程</span></span><br><span class="line">          proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                    cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">                                    <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                            cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">          checkTime(startTime, <span class="string">"getContentProviderImpl: after start process"</span>);</span><br><span class="line">          <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     cpr.launchingApp = proc;</span><br><span class="line">     <span class="comment">//将ProcessRecord添加到正在等待启动的列表中，如果完成Provider的装载后会从mLaunchingProviders列表中</span></span><br><span class="line">     mLaunchingProviders.add(cpr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上诉代码中得知:</p>
<ol>
<li>当目标 <code>Provider</code> 未装载运行时，会通过<code>PMS</code> 获取<code>Provider</code>信息，为装载做准备</li>
<li>检测目标 <code>Provider</code> 的进程是否在运行</li>
<li>如果目标进程已经运行，会自己通知目标进程去装载指定的<code>Provider</code></li>
<li>如果目标进程未运行，会先启动进程</li>
</ol>
<p>当是情况<code>3</code>时， 代码最终会执行进入 ActivityThread.installContentProviders(Context context, List<providerinfo> providers) 中，这个方法在分析 随进程启动时装载<code>Provider</code> 中已经介绍过。  </providerinfo></p>
<p>当是情况<code>4</code>时，会执行 AMS 的 <code>startProcessLocked</code>方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">                hostingName, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继而又调用 另一个重载方法:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="comment">//正常情况下我们的目标进程不是隔离进程，前一步也的确传入false</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don't have to do anything more if:</span></span><br><span class="line">        <span class="comment">// (1) There is an existing application record; and</span></span><br><span class="line">        <span class="comment">// (2) The caller doesn't think it is dead, OR there is no thread</span></span><br><span class="line">        <span class="comment">//     object attached to it so we know it couldn't have crashed; and</span></span><br><span class="line">        <span class="comment">// (3) There is a pid assigned to it, so it is either starting or</span></span><br><span class="line">        <span class="comment">//     already running.</span></span><br><span class="line">        <span class="comment">//如源码注释所说，启动前判断一下目标进程其实是存活的，什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">                checkTime(startTime, <span class="string">"startProcess: done, added package to proc"</span>);</span><br><span class="line">                <span class="keyword">return</span> app;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这种情况下，说明需要认定目标进程已经死了，以下代码处理清除目标进程的操作</span></span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: bad proc running, killing"</span>);</span><br><span class="line">            killProcessGroup(app.uid, app.pid);</span><br><span class="line">            handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: done killing old proc"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String hostingNameStr = hostingName != <span class="keyword">null</span></span><br><span class="line">                ? hostingName.flattenToShortString() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//正常情况下 app 为 null，我们需要启动进程</span></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">            <span class="comment">//创建代表进程状态的 ProcessRecord 对象</span></span><br><span class="line">            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">         &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//继续启动进程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">        <span class="keyword">return</span> success ? app : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续启动进程  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">           String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义进程启动的入口类是 "android.app.ActivityThread"</span></span><br><span class="line">      <span class="keyword">final</span> String entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">      <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                   startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码规定了，进程的入口是 “android.app.ActivityThread”   </p>
<p>后面会继续进入到 <code>startProcess</code>方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                    app.processName);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">            <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">            <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">                startResult = startWebView(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startResult = Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里发现对 <code>webview_service</code> 进程做了单独处理,应该是因为Android接入的是 Chromium 内核,<br>最后 通过 <code>Process.start</code>方法开启真正的进程之旅啊<br>下面顺带着简单介绍下进程的启动流程，不过不会深入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>发现通过 Zygote 进程孵化  </p>
<p><strong>android.os.ZygoteProcess.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加一堆 Zygote 参数</span></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">            argsForZygote.add(invokeWith);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <strong><code>openZygoteSocketIfNeeded(abi)</code></strong> 这里打开了  zygote的socket连接，说明 孵化进程通过经典的<code>socket</code>进行通信。有兴趣的同学可以深入了解下  </p>
<p><code>zygote socket</code> 打开之后，我们继续分析<code>zygoteSendArgsAndGetResult</code> 方法  </p>
<pre><code class="java"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span>
<span class="function"><span class="params">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span>
<span class="function">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>{
        <span class="keyword">try</span> {
            <span class="keyword">int</span> sz = args.size();
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {
                <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);
                }
            }
            <span class="comment">//往 socket 中写入命令数据，包括 进程的入口类</span>
            <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;
            <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;

            writer.write(Integer.toString(args.size()));
            writer.newLine();

            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) {
                String arg = args.get(i);
                writer.write(arg);
                writer.newLine();
            }

            writer.flush();

            <span class="comment">// Should there be a timeout on this?</span>
            Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();

            <span class="comment">//从 socket 中读取启动结果</span>
            result.pid = inputStream.readInt();
            result.usingWrapper = inputStream.readBoolean();

            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);
            }
            <span class="keyword">return</span> result;
        } <span class="keyword">catch</span> (IOException ex) {
            zygoteState.close();
            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);
        }
    }
</code></pre>
<p>再往后 具体如何调用 <code>ActivityThread</code>的<code>main</code>方法就不做具体深入了。<br>最终会执行<code>ActivityThread</code>的<code>main</code>，这又回到了文章开头介绍的，进程启动时装载<code>Provider</code>的场景。  </p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol>
<li><code>Provider</code>的装载分两种场景，分别是 <em>随进程启动而装载 和 被调用时装载</em></li>
<li>随进程启动的<code>Provider</code>装载时机在<code>Application</code>的<code>onCreate</code>方法之前，<code>attach</code>方法之后</li>
<li>装载后的<code>Provider</code>会记录在本进程空间的<code>mProviderMap</code>中，同时也会通知 AMS，AMS 也会保持在它自己的 <code>mProviderMap</code>中</li>
<li>在 Client 通过<code>ContentResolver</code>调用<code>Provider</code>时 首先到调用者的进程空间中去查询，如果存在直接返回使用; 如果不存在，通知AMS 去获取。如果AMS中直接有保持的实例，直接返回实例，否则AMS去装载Provider。</li>
<li>AMS 去装载时有区分是否目标进程已经存在还是未存在; 如果已经存在，直接调用 目标进程的<code>scheduleInstallProvider</code>方法去装载；如果目标进程不存在，同 <code>zygote</code> 进程去启动进程,进而 <code>Provider</code> 随着进程启动而装载。</li>
<li>还需要注意的是，如果<code>Provider</code>是设置了 <code>singleUser</code>属性，会被多个用户共享。</li>
<li>如第<code>4</code>条。如果通过<code>AMS</code> 获取到了别的进程的 <code>Provider</code>实例，需要在自己的进程空间保留一份引用，方便下次调用时，直接返回，而不再需要通过<code>AMS</code>获取。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android-Binder通信的数据传输载体-Parcel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android-Binder通信的数据传输载体-Parcel/" itemprop="url">Android-Binder通信的数据传输载体-Parcel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T14:09:19+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-Binder通信的数据传输载体-Parcel/" class="leancloud_visitors" data-flag-title="Android-Binder通信的数据传输载体-Parcel">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道在 Android上常用的两种对象序列化工具是<code>Serializable</code>和<code>Parcelable</code>。尤其我们做和<code>Binder</code>相关的数据传输时，选择的都是<code>Parcelable</code>数据。<code>Parcelable</code>其实就是一个接口，约定，如果一个对象希望使用<code>Parcelable</code>方式将数据序列化到内存中，必须实现 <code>Parcelable</code>接口。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, @WriteFlags <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接口的一个核心方法就是 <code>writeToParcel</code>，其实就是调用<code>Parcel</code>提供的一系列方法，将数据序列化到<code>Parcel</code>中。   </p>
<h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4><p><code>Parcel</code>是一种数据的载体，用于承载Binder相关的通信数据，数据可以是原始类型的，也可以是对象的引用。  </p>
<p><code>Parcel</code>常用的方法有:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">writeByte(<span class="keyword">byte</span> val) <span class="comment">//写入一个byte</span></span><br><span class="line">readByte()<span class="comment">//读取一个byte</span></span><br><span class="line">writeBoolean(<span class="keyword">boolean</span> val)</span><br><span class="line">readBoolean()</span><br><span class="line">writeInt(<span class="keyword">int</span> val)</span><br><span class="line">readInt()</span><br><span class="line">writeLong(<span class="keyword">long</span> val)</span><br><span class="line">readLong()</span><br><span class="line">writeFloat(<span class="keyword">float</span> val)</span><br><span class="line">readFloat()</span><br><span class="line">writeDouble(<span class="keyword">double</span> val)</span><br><span class="line">readDouble()</span><br><span class="line">writeString(String val)</span><br><span class="line">readString()</span><br></pre></td></tr></table></figure>
<p>这些方法都是成对匹配使用的，即在数据封装端，调用相应的writexxx方法，在解封端使用readxxx方法。  </p>
<p>以上列举的操作数据类型是原始数据类型，和String，还可以写入其他类型:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            writeInt(VAL_NULL);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeInt(VAL_STRING);</span><br><span class="line">            writeString((String) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            writeInt(VAL_INTEGER);</span><br><span class="line">            writeInt((Integer) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            writeInt(VAL_MAP);</span><br><span class="line">            writeMap((Map) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Bundle) &#123;</span><br><span class="line">            <span class="comment">// Must be before Parcelable</span></span><br><span class="line">            writeInt(VAL_BUNDLE);</span><br><span class="line">            writeBundle((Bundle) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PersistableBundle) &#123;</span><br><span class="line">            writeInt(VAL_PERSISTABLEBUNDLE);</span><br><span class="line">            writePersistableBundle((PersistableBundle) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Parcelable) &#123;</span><br><span class="line">            <span class="comment">// types will be written.</span></span><br><span class="line">            writeInt(VAL_PARCELABLE);</span><br><span class="line">            writeParcelable((Parcelable) v, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Short) &#123;</span><br><span class="line">            writeInt(VAL_SHORT);</span><br><span class="line">            writeInt(((Short) v).intValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            writeInt(VAL_LONG);</span><br><span class="line">            writeLong((Long) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Float) &#123;</span><br><span class="line">            writeInt(VAL_FLOAT);</span><br><span class="line">            writeFloat((Float) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">            writeInt(VAL_DOUBLE);</span><br><span class="line">            writeDouble((Double) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            writeInt(VAL_BOOLEAN);</span><br><span class="line">            writeInt((Boolean) v ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">            <span class="comment">// Must be after String</span></span><br><span class="line">            writeInt(VAL_CHARSEQUENCE);</span><br><span class="line">            writeCharSequence((CharSequence) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            writeInt(VAL_LIST);</span><br><span class="line">            writeList((List) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> SparseArray) &#123;</span><br><span class="line">            writeInt(VAL_SPARSEARRAY);</span><br><span class="line">            writeSparseArray((SparseArray) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_BOOLEANARRAY);</span><br><span class="line">            writeBooleanArray((<span class="keyword">boolean</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_BYTEARRAY);</span><br><span class="line">            writeByteArray((<span class="keyword">byte</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String[]) &#123;</span><br><span class="line">            writeInt(VAL_STRINGARRAY);</span><br><span class="line">            writeStringArray((String[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> CharSequence[]) &#123;</span><br><span class="line">            <span class="comment">// Must be after String[] and before Object[]</span></span><br><span class="line">            writeInt(VAL_CHARSEQUENCEARRAY);</span><br><span class="line">            writeCharSequenceArray((CharSequence[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> IBinder) &#123;</span><br><span class="line">            writeInt(VAL_IBINDER);</span><br><span class="line">            writeStrongBinder((IBinder) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Parcelable[]) &#123;</span><br><span class="line">            writeInt(VAL_PARCELABLEARRAY);</span><br><span class="line">            writeParcelableArray((Parcelable[]) v, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_INTARRAY);</span><br><span class="line">            writeIntArray((<span class="keyword">int</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_LONGARRAY);</span><br><span class="line">            writeLongArray((<span class="keyword">long</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Byte) &#123;</span><br><span class="line">            writeInt(VAL_BYTE);</span><br><span class="line">            writeInt((Byte) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Size) &#123;</span><br><span class="line">            writeInt(VAL_SIZE);</span><br><span class="line">            writeSize((Size) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> SizeF) &#123;</span><br><span class="line">            writeInt(VAL_SIZEF);</span><br><span class="line">            writeSizeF((SizeF) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">            writeInt(VAL_DOUBLEARRAY);</span><br><span class="line">            writeDoubleArray((<span class="keyword">double</span>[]) v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = v.getClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isArray() &amp;&amp; clazz.getComponentType() == Object.class) &#123;</span><br><span class="line">                writeInt(VAL_OBJECTARRAY);</span><br><span class="line">                writeArray((Object[]) v);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                <span class="comment">// Must be last</span></span><br><span class="line">                writeInt(VAL_SERIALIZABLE);</span><br><span class="line">                writeSerializable((Serializable) v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Parcel: unable to marshal value "</span> + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>Parcel</code>还支持多种 <code>Object</code>类型。</p>
<p>但是大部分情况下，封装端写入的对象和 解封端获得的对象不是同一个了，而是将对象中的数据复制过去一份，相当于是新 clone 了一个对象。那有没办法使用原来的对象呢？  </p>
<p>答案是可以的，不过是间接的，这类对象我们称之为<code>Active Objects</code>。Parcel 写入的是他们的特殊标记引用。这类对象常见的有以下两种:  </p>
<ol>
<li>Binder。Binder 是Android系统中IPC的核心通信机制，它还是一个对象，Parcel 可以通过<code>writeStrongBinder(IBinder val)</code>写入Binder对象，解封端读取的是原Binder对象的一个特殊代理类(BinderProxy),但是最终的操作还是被原Binder对象响应，所以可以间接的认为将Binder对象传递了过去。  </li>
<li>FileDescriptor 。FD 是Linux中的文件描述符，可以通过Parcel 的<code>writeFileDescriptor(FileDescriptor val)</code>方法写入</li>
</ol>
<p>不管是 Binder 还是 FileDescriptor 接收端的对象仍然会基于和原对象相同的操作，所以可以认为是 <code>Active Object</code>。  </p>
<h4 id="Parcel-写入数据分析"><a href="#Parcel-写入数据分析" class="headerlink" title="Parcel 写入数据分析"></a>Parcel 写入数据分析</h4><p>我们基于 <code>Parcel</code>写入<code>String</code> 来做一个源码分析  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        mReadWriteHelper.writeString(<span class="keyword">this</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteHelper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ReadWriteHelper DEFAULT = <span class="keyword">new</span> ReadWriteHelper();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(Parcel p, String s)</span> </span>&#123;</span><br><span class="line">            nativeWriteString(p.mNativePtr, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readString</span><span class="params">(Parcel p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nativeReadString(p.mNativePtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可见 <code>Parcel</code> 有 <code>native</code> 代码的实现  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Parcel</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">            mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        init(nativePtr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">            mNativePtr = nativePtr;</span><br><span class="line">            mOwnsNativeParcelObject = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNativePtr = nativeCreate();<span class="comment">//调用native代码，获得指针</span></span><br><span class="line">            mOwnsNativeParcelObject = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>nativeCreate()</code>定义在<code>framework/base/cor/jni/android_os_Parcel.cpp</code>文件中  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gParcelMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    &#123;<span class="string">"nativeWriteInt"</span>,            <span class="string">"(II)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeInt&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteString"</span>,         <span class="string">"(ILjava/lang/String;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeString&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteStrongBinder"</span>,   <span class="string">"(ILandroid/os/IBinder;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeStrongBinder&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeWriteFileDescriptor"</span>, <span class="string">"(ILjava/io/FileDescriptor;)V"</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeFileDescriptor&#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="string">"nativeReadInt"</span>,             <span class="string">"(I)I"</span>, (<span class="keyword">void</span>*)android_os_Parcel_readInt&#125;,</span><br><span class="line">    &#123;<span class="string">"nativeReadLong"</span>,            <span class="string">"(I)J"</span>, (<span class="keyword">void</span>*)android_os_Parcel_readLong&#125;,</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"nativeCreate"</span>,              <span class="string">"()I"</span>, (<span class="keyword">void</span>*)android_os_Parcel_create&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>android_os_Parcel.cpp</code>中定义了native和java的方法映射。所以native层执行的方法是<code>android_os_Parcel_create()</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以Java层的<code>mNativePtr</code>变量实际上是native层的一个<code>Parcel(C++)</code>对象  </p>
<p><code>Parcel.cpp</code>代码位置<code>frameworks/native/libs/binder/Parcel.cpp</code><br>从源码位置上就能看出来，<code>Parcel</code>就是用来辅助Binder通信的。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Parcel::Parcel()</span><br><span class="line">&#123;</span><br><span class="line">    initState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Parcel::initState()</span><br><span class="line">&#123;</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="number">0</span>;</span><br><span class="line">    mDataSize = <span class="number">0</span>;</span><br><span class="line">    mDataCapacity = <span class="number">0</span>;</span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    ALOGV(<span class="string">"initState Setting data size of %p to %d\n"</span>, <span class="keyword">this</span>, mDataSize);</span><br><span class="line">    ALOGV(<span class="string">"initState Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="literal">NULL</span>;</span><br><span class="line">    mObjectsSize = <span class="number">0</span>;</span><br><span class="line">    mObjectsCapacity = <span class="number">0</span>;</span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mHasFds = <span class="literal">false</span>;</span><br><span class="line">    mFdsKnown = <span class="literal">true</span>;</span><br><span class="line">    mAllowFds = <span class="literal">true</span>;</span><br><span class="line">    mOwner = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Parcel 对象初始化的过程中只是简单的初始化了各个成员变量，并没有分配内存。Parcel 遵循的是动态扩展的原则，只有在真正需要的时候才会申请内存，避免了资源浪费。  </p>
<p>Parcel对象初始化的这些变量定义在<code>`frameworks/native/libs/binder/Parcel.h</code>文件中，我们来看看它们的含义  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span>            mError;</span><br><span class="line">  <span class="keyword">uint8_t</span>*            mData;<span class="comment">//Parcel中存储的数据内容，它是一个8位 uint8_t类型的指针</span></span><br><span class="line">  <span class="keyword">size_t</span>              mDataSize;<span class="comment">//Parcel 中已经存储的数据大小</span></span><br><span class="line">  <span class="keyword">size_t</span>              mDataCapacity;<span class="comment">//最大容量</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">size_t</span>      mDataPos;<span class="comment">//当前数据存储到哪了？</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>我们看看 如何往<code>Parcel</code>中写入数据，以 写入String 为例:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">       mReadWriteHelper.writeString(<span class="keyword">this</span>, val);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(Parcel p, String s)</span> </span>&#123;</span><br><span class="line">           nativeWriteString(p.mNativePtr, s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>执行的是<code>android_os_Parcel.cpp</code>中的<code>android_os_Parcel_writeString</code>方法  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeString</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr, jstring val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = NO_MEMORY;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">const</span> jchar* str = env-&gt;GetStringCritical(val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (str) &#123;</span><br><span class="line">                err = parcel-&gt;writeString16(str, env-&gt;GetStringLength(val));</span><br><span class="line">                env-&gt;ReleaseStringCritical(val, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = parcel-&gt;writeString16(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将指针<code>mNativePtr</code>转成Native 层的Parcel对象；然后将Java成的String转成Native层的字符串；调用 Parcel对象的<code>writeString16</code>方法入,这时候已经进入 <code>Parcel.cpp</code>中，我们看看 它的<code>writeString16</code>方法    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeString16(<span class="keyword">const</span> String16&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> writeString16(str.<span class="built_in">string</span>(), str.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> Parcel::writeString16(<span class="keyword">const</span> <span class="keyword">char16_t</span>* str, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> writeInt32(<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> err = writeInt32(len);<span class="comment">//写入数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        len *= <span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>);<span class="comment">//len * 单位大小 得到占用的空间大小</span></span><br><span class="line">        <span class="keyword">uint8_t</span>* data = (<span class="keyword">uint8_t</span>*)writeInplace(len+<span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(data, str, len);</span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char16_t</span>*&gt;(data+len) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        err = mError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writeString16</code>方法首先通过<code>writeInt32</code>写入字符串的长度  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeInt32(<span class="keyword">int32_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAligned(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">Parcel</span>:</span>:writeAligned(T val) &#123;</span><br><span class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) &#123;<span class="comment">//如果容量够</span></span><br><span class="line">restart_write:</span><br><span class="line">        *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;<span class="comment">//保存val</span></span><br><span class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));<span class="comment">//修正mDataPos和mDataSize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(<span class="keyword">sizeof</span>(val));<span class="comment">//数据超过Parcel的存储容量，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入String size 调用的是一个模板类，泛型T是int类型，首先判断是否容量充足，如果充足直接写入，否则扩容。  </p>
<p>回到 <code>writeString16</code>方法，继续写入一个 String 字符串。<code>len *= sizeof(char16_t);</code>计算一共需要占用多少字节,然后使用<code>writeInplace</code>计算复制数据的目标地址，如果一切顺利，后面会调用<code>memcpy</code>真正的将字符串拷贝进去。  </p>
<p>我们分析一下<code>writeInplace</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* Parcel::writeInplace(<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> padded = PAD_SIZE(len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check for integer overflow</span></span><br><span class="line">    <span class="keyword">if</span> (mDataPos+padded &lt; mDataPos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+padded) &lt;= mDataCapacity) &#123;</span><br><span class="line">restart_write:</span><br><span class="line">        <span class="keyword">uint8_t</span>* <span class="keyword">const</span> data = mData+mDataPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to pad at end?</span></span><br><span class="line">        <span class="keyword">if</span> (padded != len) &#123;<span class="comment">//需要尾部填充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> mask[<span class="number">4</span>] = &#123;</span><br><span class="line">                <span class="number">0x00000000</span>, <span class="number">0xffffff00</span>, <span class="number">0xffff0000</span>, <span class="number">0xff000000</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> mask[<span class="number">4</span>] = &#123;</span><br><span class="line">                <span class="number">0x00000000</span>, <span class="number">0x00ffffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          </span><br><span class="line">            *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(data+padded<span class="number">-4</span>) &amp;= mask[padded-len];<span class="comment">//填充尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finishWrite(padded);<span class="comment">//修正mDataPos和mDataSize</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(padded);<span class="comment">//容量不足，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define PAD_SIZE(s) (((s)+3)&amp;~3)</span><br></pre></td></tr></table></figure>
<p><code>PAD_SIZE</code>以4字节对齐，即每一份占4字节。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len =1 padded = 4 </span><br><span class="line">len =4 padded = 4 </span><br><span class="line">len =5 padded = 8</span><br><span class="line">len =8 padded = 8</span><br><span class="line">len =9 padded = 12</span><br></pre></td></tr></table></figure>
<p>回到<code>writeInplace</code>方法，如果 <code>padded != len</code>说明写入的数据长度不是4字节的整数倍，所以需要在空余的尾部填充一些 <code>mask</code>数据，这里填充的字节序有两种:<code>BIG_ENDIAN</code>和<code>LITTLE_ENDIAN</code>,他们的填充字段不同。</p>
<p>该方法中同样考虑了 容量不足时使用<code>growData</code>方法扩容。 </p>
<p>再次回到<code>writeString16</code>方法中   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (data) &#123;</span><br><span class="line">           memcpy(data, str, len);</span><br><span class="line">           *reinterpret_cast&lt;char16_t*&gt;(data+len) = 0;</span><br><span class="line">           return NO_ERROR;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>有了拷贝的目标地址，然后系统调用<code>memcpy</code>将 字符串 <code>str</code>拷贝到目标地址中；<br>在最后写入结束标记<code>0</code>。 至此，写入一个String 操作完成。  </p>
<p>总结一下写入String 操作:  </p>
<ol>
<li>Java成的<code>Parcel.writeString</code>最终调用<code>Parcel.cpp</code>中的<code>writeString16</code>方法</li>
<li>首先写入一个4直接的Int值，表示 String的长度</li>
<li>通过 <code>writeInplace</code>函数计算 要写入的目标地址，注意，这里以4字节为单位进行分配</li>
<li>如果空间不足，使用函数<code>growData</code>进行扩容，中间会设计到调用<code>continueWrite</code>函数做老数据拷贝</li>
<li>获得目标地址后，使用<code>memcpy</code>函数进行拷贝</li>
<li>最后写入结束标记<code>0</code></li>
</ol>
<h4 id="Parcel-读数据分析"><a href="#Parcel-读数据分析" class="headerlink" title="Parcel 读数据分析"></a>Parcel 读数据分析</h4><p>上面分析了往Parcel 中写一个String，这里配对分析一下<code>readString</code><br>readString 也是经过natice 层处理的，最终调用到<code>android_os_Parcel.cpp</code>中  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">android_os_Parcel_readString</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char16_t</span>* str = parcel-&gt;readString16Inplace(&amp;len);</span><br><span class="line">        <span class="keyword">if</span> (str) &#123;</span><br><span class="line">            <span class="keyword">return</span> env-&gt;NewString(str, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又调用了<code>Parcel.cpp</code>中的<code>readString16Inplace</code>方法  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char16_t</span>* Parcel::readString16Inplace(<span class="keyword">size_t</span>* outLen) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> size = readInt32();<span class="comment">//首先读出String的大小</span></span><br><span class="line">    <span class="comment">// watch for potential int overflow from size+1</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">0</span> &amp;&amp; size &lt; INT32_MAX) &#123;</span><br><span class="line">        *outLen = size;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char16_t</span>* str = (<span class="keyword">const</span> <span class="keyword">char16_t</span>*)readInplace((size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char16_t</span>));<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *outLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 readInt，读出String 的大小；然后通过<code>readInplace</code>获取到字符串的起始地址；<br>最后 new 一个Java层的字符串对象返回。</p>
<p>这里以 String的写入和读取为例做的分析，其他类型数据的写入和读取也都类似，就不一一分析了。至于 <code>Active Object</code>的写入和读取，在之后的Binder 分析文章中会有具体分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android-智能指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android-智能指针/" itemprop="url">Android-智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T22:12:49+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-智能指针/" class="leancloud_visitors" data-flag-title="Android-智能指针">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针?"></a>什么是智能指针?</h3><p>Android 上层APP 基本都是基于Java 语言进行来发的，对于Java 语言来说是没有<code>指针</code>概念的，因为在 JVM层，Java 就将指针隐藏起来了，基于Java 开发不需要涉及对象的手动内存分配和释放。那Android 为什么搞一个 <code>智能指针</code>呢？ 这主要是因为 Android 的Framework 相当一部分还是 <code>C/C++</code>来实现的，<code>C/C++</code>是有指针概念的，但是对于一个庞大的操作系统而言，智能肯定是满天飞的，这中间很容易就出现指针相关的错误，为了减少在指针方面的关注，Android 封装了自己的<code>智能指针</code>用于管理<code>C/C++</code>层的对象引用问题，期望能像 Java一样，忘记指针的概念。  </p>
<p>但事实上，<code>智能指针</code>并不是真正的指针，它只是对<code>C++</code>对象自动回收机制的封装。</p>
<p>我们来看看智能指针如何实现的?  </p>
<h4 id="常见的指针问题"><a href="#常见的指针问题" class="headerlink" title="常见的指针问题"></a>常见的指针问题</h4><p>在 C/C++项目中，常见的指针问题大致有:  </p>
<ul>
<li>指针未初始化</li>
<li>new 操作和delete 操作未配套操作</li>
<li>野指针</li>
</ul>
<p>Android的智能指针主要也是为了解决这三个问题  </p>
<p><strong>指针未初始化:</strong> 解决这个问题 只需要在创建智能指针的时候，将 指针置空<br><strong>new 和 delete不配套:</strong> 在C++中，<code>构造函数</code>和<code>析构函数</code>是在对象new出来和delete的时候调用的,可以在这两个地方做相应的处理<br><strong>野指针:</strong> 解决这个问题其实就是让智能指针自动能判断对象是否可以被回收。这也是三个问题中的核心问题。</p>
<p>智能指针采用的是<code>引用计数器</code>方式来比较一个对象是否需要被回收。  </p>
<p><em>那么引用计数器是应该智能指针拥有呢还是被对象Object拥有呢？</em>  </p>
<p>如果计数器由智能指针拥有，假如 智能指针<code>SmartPointer1</code>和智能指针<code>SmartPointer2</code>都引用 object对象，当 <code>SmartPointer1</code>不再引用object时，计数器为0，删除了对象object，但是 <code>SmartPoint2</code>还在引用着object。回收object 肯定是不合理的。所以 引用计数器只能是 object 拥有。</p>
<h3 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h3><p>智能指针在Android上有三个比较重要的实现，分别是<code>轻量级指针</code>,<code>强指针</code>,<code>弱指针</code>。它们的实现原理都是一致的，即由对象本身来提供引用计数器，但是它不会去维护这个引用计数器的值，而是由智能指针来维护</p>
<h4 id="轻量级智能指针-LightRefBase"><a href="#轻量级智能指针-LightRefBase" class="headerlink" title="轻量级智能指针 LightRefBase"></a>轻量级智能指针 LightRefBase</h4><p>这里所说的轻量级指针不是说 <code>LightRefBase</code> 是一个指针的定义，它是 配合智能指针的object对象的最简单，最轻量级的实现。  </p>
<p>源码位置 <code>frameworks/native/include/utils/RefBase.h</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LightRefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline LightRefBase() : mCount(0) &#123; &#125; //mCount 就是引用计数器,初始化值为0</span><br><span class="line">    inline void incStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        android_atomic_inc(&amp;mCount);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void decStrong(__attribute__((unused)) const void* id) const &#123;</span><br><span class="line">        <span class="keyword">if</span> (android_atomic_dec(&amp;mCount) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">inline</span> ~LightRefBase() &#123; &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给类有一个成员变量<code>mCount</code>，这就是<code>引用计数器</code>，它的初始化值为<code>0</code>，另外，这个类还提供两个成员函数<code>incStrong</code>和<code>decStrong</code>,分别是用来增加引用和减少引用计数的，这两个函数提供给智能指针来调用，在decStrong函数中，如果当前引用计数值为1，那么当减1后就会变成0，于是就会delete这个对象。</p>
<p>轻量级智能指针 LightRefBase 是需要和 智能指针搭配使用的，只有继承 <code>LightRefBase</code>的类型对象才能使用智能指针(先不考虑RefBase)。  </p>
<h4 id="强指针-sp"><a href="#强指针-sp" class="headerlink" title="强指针 sp"></a>强指针 sp</h4><p>前面说的 <code>LightRefBase</code>的计数器是由智能指针来修改的，那就是 <code>sp</code>了。  </p>
<p>源码定义位置：<code>frameworks/native/include/utils/StrongPointer.h</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    inline sp() : m_ptr(0) &#123; &#125;//首先将引用置空，解决指针为初始化问题</span><br><span class="line"></span><br><span class="line">    sp(T* other);</span><br><span class="line">    sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp(U* other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~sp();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment</span></span><br><span class="line"></span><br><span class="line">    sp&amp; <span class="keyword">operator</span> = (T* other);</span><br><span class="line">    sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;T&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;U&gt;&amp; other);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; sp&amp; <span class="keyword">operator</span> = (U* other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Special optimization for use by ProcessState (and nobody else).</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">force_set</span><span class="params">(T* other)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessors</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span>  T&amp;      <span class="keyword">operator</span>* () <span class="keyword">const</span>  &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">    <span class="keyword">inline</span>  T*      <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_ptr;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  T*      <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span>         </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Operators</span></span><br><span class="line"></span><br><span class="line">    COMPARE(==)</span><br><span class="line">    COMPARE(!=)</span><br><span class="line">    COMPARE(&gt;)</span><br><span class="line">    COMPARE(&lt;)</span><br><span class="line">    COMPARE(&lt;=)</span><br><span class="line">    COMPARE(&gt;=)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">wp</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>强指针sp 初始化的时候 首先将 引用 <code>m_ptr</code>置空，<code>m_ptr</code>指向的就是<code>LightRefBase</code>,当然也可以是<code>RefBase</code>,只不过 <code>RefBase</code>还支持弱指针访问，比较复杂，后面会再详细介绍。  </p>
<p>先看看 sp 构造函数做了什么事情  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">sp&lt;T&gt;::sp(T* other)</span><br><span class="line">: m_ptr(other)</span><br><span class="line">  &#123;</span><br><span class="line">    if (other) other-&gt;incStrong(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>sp的构造函数有多个，这里只分析了其中一个，其他的类似。通过构造方法与引用对象关联时，首先调用了<code>LightRefBase</code>或<code>RefBase</code>的<code>incStrong</code>增加引用数量。  </p>
<p>sp 还重载了运算符<code>=</code>,当使用 <code>=</code>将一个对象与智能指针sp关联时，会操作object对象的引用数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> = (T* other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">    m_ptr = other;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用<code>=</code>运算符时，将判断该指针之前是否引用过别的对象，即 <code>m_ptr</code>是否不为空，如果有引用，<code>m_ptr</code>不为空，需要先将原引用对象的引用计数器减小，在将新引用的对象计数器增加，并和 <code>m_ptr</code>关联。  </p>
<p>sp的析构函数  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt;::~sp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行析构函数的时候，将减小引用对象的引用计数器。  </p>
<p>回顾上面提及的<code>LightRefBase</code>和<code>sp</code>好像无法避免循环引用的问题。而<code>弱指针wp</code>就是专门解决该问题的。  </p>
<p><code>LightRefBase</code>之所以称之为 <code>轻量级的</code>，是与<code>RefBase</code>相比而言的。<code>RefBase</code>的实现比<code>LightRefBase</code>复杂许多，其内部包含了 弱指针wp的定义和实现。  </p>
<h4 id="弱指针wp"><a href="#弱指针wp" class="headerlink" title="弱指针wp"></a>弱指针wp</h4><p>如前面所说，弱指针的主要使命就是解决循环引用的问题，我们看看它和 强指针sp的区别  </p>
<p>弱指针wp源码定义在 <code>frameworks/native/include/utils/RefBase.h</code>中  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class wp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef typename RefBase::weakref_type weakref_type;</span><br><span class="line">    //约定 弱指针执行的对象类型必须是 RefBase 类型，而不能是 LightRefBase</span><br><span class="line">    </span><br><span class="line">    inline wp() : m_ptr(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    wp(T* other);//构造函数</span><br><span class="line">    wp(const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line">    </span><br><span class="line">    wp&amp; operator = (T* other);//运算符重载</span><br><span class="line">    wp&amp; operator = (const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    void set_object_and_refs(T* other, weakref_type* refs);</span><br><span class="line"></span><br><span class="line">    // promotion to sp</span><br><span class="line">    </span><br><span class="line">    sp&lt;T&gt; promote() const; // 将弱指针升级为强指针sp</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line">    //以下是重载一些逻辑运算符</span><br><span class="line"></span><br><span class="line">    COMPARE_WEAK(==)</span><br><span class="line">    COMPARE_WEAK(!=)</span><br><span class="line">    COMPARE_WEAK(&gt;)</span><br><span class="line">    COMPARE_WEAK(&lt;)</span><br><span class="line">    COMPARE_WEAK(&lt;=)</span><br><span class="line">    COMPARE_WEAK(&gt;=)</span><br><span class="line"></span><br><span class="line">    inline bool operator == (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line"></span><br><span class="line">    T*              m_ptr; //指向目标对象的指针</span><br><span class="line">    weakref_type*   m_refs;//指向weakref_type类型的弱引用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和 强指针sp相比，wp有以下重要区别:  </p>
<ul>
<li>除了指向目标对象的 m_ptr 外，wp另外还有一个 m_refs 指针，类型为 weakref_type</li>
<li>没有重载 -&gt;, * 等运算符</li>
<li>有一个 promote()方法用来将wp提升为sp</li>
<li>弱指针的目标对象类型不是<code>LightRefBase</code>，而是 <code>RefBase</code></li>
</ul>
<p>惯例，我们看看 wp的构造函数实现:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;::wp(T* other)</span><br><span class="line">    : m_ptr(other)</span><br><span class="line">&#123;</span><br><span class="line">    if (other) m_refs = other-&gt;createWeak(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出和 sp的构造方法不同，没有直接调用 目标对象的 <code>incStrong</code>方法，而是调用了<code>createWeak</code>方法。可见wp并没有直接增加目标对象的引用计数器，因为 <code>createWeak</code>方法是 <code>RefBase</code>中定义的，我们稍后会详细分析 <code>RefBase</code>  </p>
<p>析构函数:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_ptr) m_refs-&gt;decWeak(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数也没有直接操作 引用计数器。</p>
<p>我们再看看运算符<code>=</code>的重载  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">wp&lt;T&gt;&amp; wp&lt;T&gt;::operator = (T* other)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_type* newRefs =</span><br><span class="line">        other ? other-&gt;createWeak(this) : 0;</span><br><span class="line">    if (m_ptr) m_refs-&gt;decWeak(this);</span><br><span class="line">    m_ptr = other;</span><br><span class="line">    m_refs = newRefs;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，运算符<code>=</code>同样也没有直接操作引用计数器，而是操作 <code>weakref_type</code></p>
<p>综上，wp主要操作的是 <code>weakref_type</code>。并不直接影响引用计数器，所以称之为弱指针，不会改变引用关系。</p>
<h4 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h4><p>前面多处提到<code>RefBase</code>，我们可以认为 <code>RefBase</code>是既支持强指针sp的也支持弱指针wp的对象类型，如果你定义的对象需要用到弱指针，请务必继承<code>RefBase</code>,而如果只使用强指针，你可以选择轻量级的<code>LightRefBase</code>也可以选择适应大多数情况的<code>RefBase</code></p>
<p>即<code>RefBase</code>不仅支持强指针还支持弱指针，它的源码定义位置: <code>frameworks/native/include/utils/RefBase.h</code><br>源码实现位置: <code>frameworks/native/libs/utils/RefBase.cpp</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//增加强引用计数器，强指针sp专用</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//减少强引用计数器，强指针sp专用</span></span><br><span class="line">    			....</span><br><span class="line">    		<span class="comment">//嵌套在 RefBase 内部，wp 中会操作该类型对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//增加弱引用计数器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//减少弱引用计数器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    			<span class="comment">// 用于创建一个weakref_type类型的对象，来处理弱引用关系</span></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            </span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">				...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();<span class="comment">//RefBase的构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase(); <span class="comment">//RefBase的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="comment">// 这些 Flag 参数 用来标记object的生命周期的，在 extendObjectLifetime 方法使用</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">weakref_type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">weakref_impl</span>;</span></span><br><span class="line">    </span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		...</span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;<span class="comment">//真实的处理引用关系的成员变量，不同于LightRefBase 的 Int类型的 mCount</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过分析 <code>RefBase</code>以及 <code>weakref_type</code> 的定义,发现 <code>RefBase</code>和<code>LightRefBase</code>的区别，虽然 <code>RefBase</code>和<code>LightRefBase</code>都提供了<code>incStrong</code>和<code>decStrong</code>成员函数来操作它的引用计数器,但 <code>RefBase</code>它不像<code>LightRefBase</code>类一样直接提供一个整型值（mutable volatile int32_t mCount）来维护对象的引用计数，前面我们说过，复杂的引用计数技术同时支持强引用计数和弱引用计数，在<code>RefBase</code>类中，这两种计数功能是通过其成员变量<code>mRefs</code>来提供的。  </p>
<p><code>mRefs</code>是<code>weakref_impl</code> 类型的,在<code>RefBase.h</code>文件中只定义了<code>weakref_impl</code>,具体实现在 <code>frameworks/native/libs/utils/RefBase.cpp</code> 中，在 RefBase.cpp 文件中还具体实现了<code>incStrong</code>,<code>decStrong</code>等方法，让我们一起来看看。   </p>
<p>首先我们分段分析一下 <code>mRefs</code>的<code>weakref_impl</code>类型实现。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefBase</span>:</span>:weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;<span class="comment">//继承 weakref_type</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;<span class="comment">//强引用计数器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;<span class="comment">//弱引用计数器</span></span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS <span class="comment">//宏DEBUG_REFS来区分DEBUG环境和正式环境</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// DEBUG环境下</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">        , mStrongRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mWeakRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)</span><br><span class="line">        , mRetain(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~weakref_impl()<span class="comment">//weakref_impl析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    ... 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//增加强引用计数器，这里使用了 mStrongRefs指针</span></span><br><span class="line">        addRef(&amp;mStrongRefs, id, mStrong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        addRef(&amp;mWeakRefs, id, mWeak);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ref_entry</span> //结构体 <span class="title">ref_entry</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ref_entry* next;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_REFS_CALLSTACK_ENABLED</span></span><br><span class="line">        CallStack <span class="built_in">stack</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">int32_t</span> ref;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		...<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       ...<span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> Mutex mMutex;</span><br><span class="line">    ref_entry* mStrongRefs;<span class="comment">//用来做强引用记录</span></span><br><span class="line">    ref_entry* mWeakRefs; <span class="comment">//弱引用记录</span></span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过查看源码实现，我们知道 <code>RefBase</code>不同于<code>LightRefBase</code>,它使用结构体<code>ref_entry</code>来记录引用关系。成员变量<code>mStrong</code>做强引用计数器，<code>mWeak</code>做弱引用计数器。  </p>
<p>回到 前面 wp 构造函数和 <code>=</code>运算符重载中，都调用了<code>RefBase.createWeak()</code>方法用来生成一个 <code>weakref_type</code> 实例，其实就是 <code>weakref_impl</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::weakref_type* RefBase::createWeak(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">    mRefs-&gt;incWeak(id);</span><br><span class="line">    return mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RefBase.h</code>定义中，<code>mRefs</code>定义为 <code>weakref_impl</code> 类型,所以这里调用的是<code>weakref_impl中的incWeak()</code>方法  </p>
<p>mRefs 是在 RefBase对象初始化的时候就在构造方法中完成了赋值  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RefBase::RefBase()</span><br><span class="line">    : mRefs(new weakref_impl(this))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 <code>mRefs</code>就是一个<code>weakref_impl</code> 实例。  当弱指针wp需要第一次初始化弱引用时，会直接返回 <code>mRefs</code>对象，并且 操作<code>mRefs</code>对象执行<code>incWeak()</code>方法，增加一次弱引用计数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::weakref_type::incWeak(const void* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);</span><br><span class="line">    impl-&gt;addWeakRef(id);</span><br><span class="line">    const int32_t c = android_atomic_inc(&amp;impl-&gt;mWeak);</span><br><span class="line">    ALOG_ASSERT(c &gt;= 0, &quot;incWeak called on %p after last weak ref&quot;, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然，在<code>incWeak</code>方法中，调用了<code>weakref_impl</code>的<code>addWeakRef</code>，而 <code>addWeakRef</code>最终通过<code>addRef</code>实现:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void addRef(ref_entry** refs, const void* id, int32_t mRef)</span><br><span class="line">    &#123;</span><br><span class="line">        if (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">            ref_entry* ref = new ref_entry;</span><br><span class="line">            // Reference count at the time of the snapshot, but before the</span><br><span class="line">            // update.  Positive value means we increment, negative--we</span><br><span class="line">            // decrement the reference count.</span><br><span class="line">            ref-&gt;ref = mRef;</span><br><span class="line">            ref-&gt;id = id;</span><br><span class="line">#if DEBUG_REFS_CALLSTACK_ENABLED</span><br><span class="line">            ref-&gt;stack.update(2);</span><br><span class="line">#endif</span><br><span class="line">            ref-&gt;next = *refs;</span><br><span class="line">            *refs = ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实就是新创建一个ref_entry，把 弱引用指针 wp本身 包装在 一个 ref_entry 中，添加到单链表的ref_entry 数据结构中，建立弱引用链表。<br>将wp添加到弱引用链表之后，<code>incWeak</code>方法还通过<code>android_atomic_inc</code>增加了弱引用计数器<code>mWeak</code>的值。  </p>
<p>到目前为止，wp如何实现弱引用计数已经分析完成，总结一下:  </p>
<ol>
<li>wp 通过构造方法或重载运算符= 会调用 RefBase的createWeak方法，来创建一个weakref_type 也就是weakref_impl实例</li>
<li>weakref_impl 在RefBase对象构造的时候就已经创建好了，将 weakref_impl 对象返回给 wp</li>
<li>触发weakref_impl的incWeak 方法，将wp指针添加到弱引用链表中，并使用Android的原子操作方法，增加弱引用计数器 mWeak的值。</li>
</ol>
<p>前面说了，RefBase 不仅支持wp还像 LightRefBase 一样支持 强指针sp。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);<span class="comment">//增加弱引用计数器</span></span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_inc(&amp;refs-&gt;mStrong);<span class="comment">//增加强引用计数器，返回的是增加之前的值</span></span><br><span class="line">	... 省略<span class="built_in">log</span></span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;<span class="comment">//判断是不是第一次被引用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果是第一次被引用，需要调整一下 mStrong的值</span></span><br><span class="line">    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();<span class="comment">//是第一次被引用时，会回调 RefBase的onFirstRef()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码看出，RefBase的强引用增加引用时，会同时增加弱引用计数器。还会判断是否是第一次被引用。如果是第一次被引用需要修改强引用计数器<code>weakref_impl</code>中<code>mStrong</code>的值；<br>因为<code>weakref_impl</code>初始化的时候，<code>mStrong</code>被赋值为<code>INITIAL_STRONG_VALUE</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define INITIAL_STRONG_VALUE (1&lt;&lt;28)</span><br></pre></td></tr></table></figure>
<p><code>android_atomic_inc</code>方法是在 原 mStrong 的基础上加一，需要再减去 原始值<code>INITIAL_STRONG_VALUE</code>。  </p>
<p>下面我们在分析一下 RefBase对象什么时候被释放  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line">    ... <span class="comment">//省略 log</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;<span class="comment">//当引用数字当前是1时，会回调 RefBase的onLastStrongRef 方法</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//判断当前引用输入强引用关系时，会释放 对象</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);<span class="comment">//正常执行减小弱引用计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先减少强引用计数器mStrong,如果减少到0了(c ==1 ，因为c 返回的是上一次计数器的值)就执行 RefBase对象的 onLastStrongRef 方法，并且，如果当前引用类型是强引用，就释放引用的对象。  </p>
<p>因为<code>incStrong</code>中同步增加了弱引用计数器，同样，为了对称，<code>decStrong</code>时也应该调用<code>decWeak</code>。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    impl-&gt;removeWeakRef(id);<span class="comment">//将弱引用指针wp从 弱引用链表中移除</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);<span class="comment">//减小弱引用计数器</span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decWeak called on %p too many times"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//该引用类型是强引用类型</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">//该对象从没有被强引用指针引用过，如果 弱引用都没有了，当然释放对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 最后一个强引用也消失的时候，这里释放 weakref_impl 对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//该引用类型是弱引用</span></span><br><span class="line">        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_&#123;WEAK|FOREVER&#125;</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//最后一个弱引用消失时，释放对象</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将弱引用指针wp从弱引用链表中移除，减小 <code>mWeak</code> 计数器; 如果当时是最后一个弱引用执行dec操作，会根据 <code>LIFETIME</code> 做不同的处理，具体看上述源码注释。 </p>
<p>前面多次提到，前引用增加时会同步的增加弱引用计数器，但是弱引用增加时肯定不会增加强引用计数器，所以弱引用计数器的值一定会大于强引用计数器，让程序走到这里的时候，弱引用计数器一定为0，而强引用计数器值有两种可能，一种就是  <code>INITIAL_STRONG_VALUE</code>即从来没有强引用指针引用，这种情况当然要释放对象；第二种就是在有强引用的情况下，强引用的<code>decStrong</code> 方法会释放<code>RefBase</code>对象，在这里只需要释放<code>weakref_impl</code>对象就行了，不需要再重复释放 <code>RefBase</code>对象。</p>
<p>总结:  </p>
<ol>
<li>Android中的智能指针分为<code>强指针sp</code>和<code>弱指针wp</code></li>
<li>有一个配合sp使用的<code>LightRefBase</code>，我们称之为<code>轻量级指针</code></li>
<li>通常和智能指针搭配使用的对象必须是 <code>RefBase</code> 类型，如果不需要 <code>弱指针wp</code>，可以使用轻量级的 <code>LightRefBase</code> 实现轻量级指针</li>
<li>对于 <code>RefBase</code> 对象而言，增加强引用也会同步的增加一个弱引用，反之不会。</li>
<li>弱指针要想访问对象，必须升级为强指针，通过弱指针wp的<code>promote</code>方法，最终调用<code>weakref_impl</code>的<code>attemptIncStrong</code>。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android进程间通信-Binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android进程间通信-Binder/" itemprop="url">Android进程间通信-Binder之初印象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T13:26:34+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android进程间通信-Binder/" class="leancloud_visitors" data-flag-title="Android进程间通信-Binder之初印象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说到<code>Android</code>中进程间通信，应用最广泛的非<code>Binder</code>莫属。<br>在同一个进程空间中，内存虚地址的映射规则完全一致，他们在一个 虚地址空间中，所以两个函数互相调用很简单。但在两个不同的进程中，如我们的应用程序App和Framework中的<code>ActivityManagerService</code>进行函数调用，因为不在一个虚地址空间，所以没法直接通过内存地址访问到彼此的函数或变量。<br>如下图:  </p>
<p><img src="/img/binder/binder_mem_barrier.jpg" alt="">  </p>
<p>既然无法<code>直接</code>访问到对方进程的内存空间，那只能通过<code>间接</code>方式了，binder的职责就是帮助进程间接访问对方进程空间。  </p>
<p><img src="/img/binder/binder_desc.jpg" alt=""></p>
<p><code>Binder</code>是Android中使用最广泛的IPC机制，Binder 通信的组成元素有:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Binder驱动</span><br><span class="line">2. ServiceManager</span><br><span class="line">3. Binder Client</span><br><span class="line">4. Binder Server</span><br></pre></td></tr></table></figure>
<p>Binder 通信可以类比我们常见的网络通信<br>Binder 驱动相当于 网络请求中的路由器<br>ServiceManager 相当于网络请求中的DNS解析服务器<br>Binder Client相当于网络请求的客户端<br>Binder Service 相当于 处理网络请求的服务器</p>
<p>本篇文章主要目的是给出Binder 通信的整体印象，后续文章中会详细分析Binder 通信中各个组成元素如何实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/IPC-mmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/IPC-mmap/" itemprop="url">Linux-mmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T23:09:56+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/IPC-mmap/" class="leancloud_visitors" data-flag-title="Linux-mmap">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在文章<a href="/Linux-SharedMemory/">Linux-共享内存(Shared Memory)</a>中介绍了通过<br><code>shmget</code>和<code>shmat</code> 实现开辟一块共享内存，两个或多个进程共享这一块内存区域；今天介绍一个类似的概念，<code>mmap</code>函数。  </p>
<p><code>mmap</code>函数 全名可以认为是<code>Memory Map</code>,可以将某个设备或者文件映射到应用进程的内存空间中，这样，访问这块内存就相当于对设备或文件进行读写，而不需要再通过 <code>read</code>和<code>write</code>了，所以由此可知，<code>mmap</code>也是支持进程间通信的，即通过映射同一块物理内存来共享内存。  虽然 <code>mmap</code>可以实现进程间通信，但是 <code>mmap</code>最出名的还是文件映射，即将一个物理硬盘上的文件映射到内存中，避免系统调用<code>read</code>和<code>write</code>。</p>
<p>为了便于理解 为何 避免了系统调用<code>read</code>和<code>write</code>就提升了效率，我们先看看普通的读写文件的原理。  </p>
<p>要读一个普通文件时，首先 进程调用<code>read</code>或是<code>write</code>后会陷入内核态，之后内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。  </p>
<p>Linux的内存映射函数<code>mmap</code>, 它把文件内容映射到一段内存上(准确说是虚拟内存上), 通过对这段内存的读取和修改, 实现对文件的读取和修改,<code>mmap()</code>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。</p>
<p>从前面的描述，不难发现 <strong><code>mmap</code>在最初并没有立马在物理内存上开辟空间，而 <code>共享内存shmget</code>和<code>shmat</code>正好相反，他们一开始就开辟了一份物理内存，而且这块是没有OOM的</strong></p>
<p><strong>区别:</strong><br><code>mmap</code>只是映射到虚地址空间上，并没有发生实际的copy，但访问这个文件的时候，内存发生了缺页中断，才会 copy 到 主存中，由于是虚地址空间，所以可操作的文件数据可以很多，大于物理主存，而且由于操作的可以是一个磁盘文件，所以读写速度肯定慢一些。<br><code>shmget</code>需要开劈一块实实在在的物理内存区域，受物理内存大小的影响，所以不能很大，不过由于操作的一直是内存，所以读写速度比较快。</p>
<p>假如我们想 进程A和进程B 都能读取一个硬盘上的文件，使用 <code>mmap</code>再合适不过了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br></pre></td></tr></table></figure>
<p>这是 <code>mmap</code>函数的定义，先看看参数的意思:  </p>
<p><strong>addr：</strong> 指出文件或设备应该被映射到进程空间的哪个其实地址。这个参数如果为空,则由内核驱动自行决定被映射的地址。  </p>
<p><strong>length:</strong> 被映射到进程空间中内存块的大小<br><strong>prot</strong> 指被映射内存的访问权限  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROT_READ：内存页可读</span><br><span class="line">PROT_WRITE：内存页可写</span><br><span class="line">PROT_EXEC：内存页可执行</span><br><span class="line">PROT_SEM：内存页可用于atomic操作</span><br><span class="line">PROT_NONE：内存页不可访问</span><br></pre></td></tr></table></figure>
<p><strong>flags</strong> 指定程序对内存块的修改带来的影响</p>
<p><strong>fd</strong> 被映射到进程空间的文件的描述符<br><strong>offset</strong> 指定了从文件的哪一部分开始映射，一般为0</p>
<p><strong>返回值</strong> 成功时为0，否则错误码</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Java-Stack-Impl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java-Stack-Impl/" itemprop="url">Java-Stack Impl</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T22:35:37+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Java-Stack-Impl/" class="leancloud_visitors" data-flag-title="Java-Stack Impl">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前几天给一个亲戚学生讲了下 计算机中栈的相关知识，记得在 <code>JDK</code>中也有 <code>Stack</code>的实现<code>java.util.Stack</code>它继承于 <code>Vector</code>类，是线程安全的。通过翻看源码发现，它是基于 <code>线性表</code>来实现的<code>Stack</code>, 而<code>Stack</code>最为我们熟知的还是使用<code>单链表</code>来实现。  </p>
<h3 id="基于-单链表实现-Stack"><a href="#基于-单链表实现-Stack" class="headerlink" title="基于 单链表实现 Stack"></a>基于 单链表实现 Stack</h3><p>下面我们来基于<code>单链表</code>来实现一个<code>Stack</code>  </p>
<p>先定义 <code>Stack</code>需要的必要方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然基于单链表来实现，就需要定义一个链表的结构  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        E value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>完整的 <code>StackWithLinkList</code>实现  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithLinkList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        E value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackWithLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头插法 实现 入栈操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        node.value = item;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            res = first.value;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素,不执行出栈操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很轻松的就基于 <code>单链表</code>实现了一个<code>栈</code>, 但在实现的过程中有一些小小的不爽，我们都知道，计算单链表中有多少个元素，就需要遍历一遍 链表，时间复杂度是<code>O(n)</code>，为了实现复杂度<code>O(1)</code>，我们只需加上计数器即可，其实 <code>JDK</code>中的<code>LinkedList</code>这种链表结构也是使用了计数器来实现<code>O(1)</code>复杂度的<code>size</code>计算。  </p>
<p>现在只需要在类中增加一个成员变量,并且在需要计数的地方，修改 计数器  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        node.value = item;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            res = first.value;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>JDK</code>中集合都采用了 <code>迭代器设计模式</code> 有一个 <code>iterator()</code>方法来隔离集合的遍历功能。我希望 <code>Stack</code>也拥有这个功能，于是乎开始动手  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; cursor = head.next;</span><br><span class="line">        Node&lt;E&gt; cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            E res = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res = cursor.value;</span><br><span class="line">                cur = cursor;</span><br><span class="line">                cursor = cursor.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从head 开始查找</span></span><br><span class="line">                Node tmp = head;</span><br><span class="line">                <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur == tmp.next) &#123;</span><br><span class="line">                        tmp.next = cur.next;</span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = tmp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>利用 <code>单链表</code>的特性，写出一个 <code>Iterator</code>还是比较顺畅的。<br>现在可以很Happy的添加<code>iterator()</code>方法啦  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于-线性表-实现-Stack"><a href="#基于-线性表-实现-Stack" class="headerlink" title="基于 线性表 实现 Stack"></a>基于 线性表 实现 Stack</h3><p>前面说到<code>JDK</code>是利用<code>线性表</code>实现的<code>Stack</code>,但是 <code>java.util.Stack</code>不能满足我们的要求，我首先查看了<code>JDK</code>中<code>java.util.Stack</code>的实现，发现它没有实现 <code>Iterator</code>,但可以使用父类<code>Vector</code>的<code>iterator()</code>方法，但不幸的是，它还是顺序的，没有实现<code>Stack</code>的<code>先进后出</code>。如果能实现一个 带反转功能的 <code>Iterator</code>就能完美解决问题啦。</p>
<p>那下面我们来实现一个基于<code>线性表</code>的<code>Stack</code><br>我们利用 <code>JDK</code>中已经完善的<code>ArrayList</code>来实现<code>Stack</code>,避免做太多与主题无关的实现。    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E obj;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line">        obj = peek();</span><br><span class="line">        list.remove(len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line">        <span class="keyword">return</span> list.get(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要反转 iterator</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseJavaListIterator&lt;&gt;(list);</span><br><span class="line">        	<span class="comment">//顺序 iterator</span></span><br><span class="line"><span class="comment">//        return new JavaListIterator&lt;&gt;(list);</span></span><br><span class="line">			<span class="comment">//使用 ArrayList中自带的 iterator</span></span><br><span class="line"><span class="comment">//        return list.iterator();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用<code>线性表</code>的<code>顺序性</code>和<code>连续性</code>，实现 <code>Stack</code>比较高效，直观。  为了避免 像<code>java.util.Stack</code>没有<code>Iterator</code>的尴尬，我们自己实现一个 具有反转功能的<code>Iterator</code>。  </p>
<p>为了同时兼容顺序的<code>Iterator</code>,首先写一个适配 <code>线性表</code>的 <code>Iterator</code>,以后可以扩展非 <code>List</code>实现的线性表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayLikeIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    ArrayLikeIterator() &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否反转遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bumpIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 &#123;<span class="doctag">@link</span> #isReverse()&#125;为 true， 需要重写该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的 线性表实现的<code>Stack</code>使用的是 <code>java.util.List</code>,所有 继承<code>ArrayLikeIterator</code> 实现一个<code>JavaListIterator</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayLikeIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaListIterator</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.length = list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">resetLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reviseIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isReverse()) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">indexInArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; length &amp;&amp; index &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements.</span></span><br><span class="line"><span class="comment">     * (In other words, returns &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #next&#125; would</span></span><br><span class="line"><span class="comment">     * return an element rather than throwing an exception.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the iteration has more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexInArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next element in the iteration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="keyword">this</span>.bumpIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.remove(lastIndex());</span><br><span class="line">        resetLength();</span><br><span class="line">        reviseIndex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的<code>JavaListIterator</code> 其实还是<code>顺序迭代</code>的，为了实现我们带<strong>反转功能</strong>的<code>Iterator</code>，我们还得实现一个<code>ReverseJavaListIterator</code>，原理很简单，就是倒序遍历 <code>List</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseJavaListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">JavaListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReverseJavaListIterator</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(list);</span><br><span class="line">        <span class="keyword">this</span>.index = list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">indexInArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bumpIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-Stack"><a href="#测试-Stack" class="headerlink" title="测试 Stack"></a>测试 Stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Stack&lt;Integer&gt; stack = new StackWithLinkList&lt;&gt;();</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> StackWithList&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"size="</span> + stack.size());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="number">2</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                System.out.println(<span class="string">"remove "</span> + next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---- print all ----"</span>);</span><br><span class="line">        System.out.println(<span class="string">"size="</span> + stack.size());</span><br><span class="line">        Iterator&lt;Integer&gt; iterator1 = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator1.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size=4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">remove 2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">---- print all ----</span><br><span class="line">size=3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>至此，我们基于 <code>单链表</code>和<code>线性表</code>的两种<code>Stack</code>实现方案测试通过。<br>其实还有很多需要完善的地方，比如多线程冲突修改问题，我们可以模仿 <code>JDK</code>,每次增删修改元素都使用<code>modCount</code>来记录，如果 <code>modCount != expectedModCount</code> 我们也可以抛出<code>ConcurrentModificationException</code>异常。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android-Dex-File/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android-Dex-File/" itemprop="url">Android-Dex File</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T14:35:48+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-Dex-File/" class="leancloud_visitors" data-flag-title="Android-Dex File">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>文章<a href="/Android-Dalvik-And-ART/">Android-Dalvik And ART</a>中介绍了，<code>ART</code>和<code>Dalvik</code>两种虚拟机，这次介绍以下 他们的可执行文件 <code>.dex</code>。</p>
<h3 id="Dex-文件的生成"><a href="#Dex-文件的生成" class="headerlink" title="Dex 文件的生成"></a>Dex 文件的生成</h3><p><code>Android</code>开发，通常是使用 <code>Java</code>语言进行开发 (即使是 <code>Kotlin</code>最终也是编译成 Java 字节码)。而     <code>Java</code>文件的编译产物就是 <code>.class</code>字节码文件，而 Android的<code>Dalvik</code>虚拟机或 <code>ART</code>是不能直接运行 <code>.class</code> 文件的，需要将 <code>.class</code>文件转成 <code>.dex</code>文件。目前 Android 官方提供两种方式，一种是 <code>dx</code>工具，另一种是<code>d8</code>工具。<br>这两种编译工具在 Android SDK Platform 的 build-tools目录；<br>如: <code>your_sdk_path/build-tools/28.0.3</code>, <code>28.0.3</code>是 version，如果你有其他 version的编译工具，替换 version 即可。  在 该目录下，存在 <code>dx</code>和 <code>d8</code>两个可执行文件。    </p>
<h4 id="生成-class-文件"><a href="#生成-class-文件" class="headerlink" title="生成 class 文件"></a>生成 class 文件</h4><p>例如 我编写了一个Hi.java 文件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String text = <span class="string">"Hi Class"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"main --&gt;"</span>);</span><br><span class="line">		Hi hi = <span class="keyword">new</span> Hi();</span><br><span class="line">		hi.print(text);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">		System.out.println(text);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行 <code>javac</code>命令把 <code>Hi.java</code> 文件编译换成 <code>Java</code> 字节码 <code>.class</code> 文件  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ javac Hi.java</span><br></pre></td></tr></table></figure>
<p>在当前目录生成文件 <code>Hi.class</code>，由于 class文件是 Java虚拟机的可执行文件，所以可以直接使用 <code>java</code> 命令执行  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ java Hi</span><br><span class="line">main --&gt;</span><br><span class="line">Hi Class</span><br></pre></td></tr></table></figure>
<h4 id="生成-dex-文件"><a href="#生成-dex-文件" class="headerlink" title="生成 dex 文件"></a>生成 dex 文件</h4><p>有了 <code>.class</code>文件之后，利用 <code>dx</code>或 <code>d8</code>工具生成 <code>.dex</code>文件  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dx --dex  --output=Hi.dex Hi.class</span><br></pre></td></tr></table></figure>
<p>生成 <code>Hi.dex</code>文件</p>
<p>或 使用 <code>d8</code>编译器:  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ d8 Hi.class</span><br></pre></td></tr></table></figure>
<p>在当前目录生成了 <code>classes.dex</code>文件</p>
<p>这个 <code>.dex</code>文件就可以在Android 运行时环境直接执行。  </p>
<h3 id="Dex-文件"><a href="#Dex-文件" class="headerlink" title="Dex 文件"></a>Dex 文件</h3><p>现在分析一下 <code>Dex</code>的格式, <code>Dex</code>文件的定义在 <code>dalvik/libdex/DexFile.h</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure representing a DEX file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Code should regard DexFile as opaque, using the API calls provided here</span></span><br><span class="line"><span class="comment"> * to access specific structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* directly-mapped "opt" header */</span></span><br><span class="line">    <span class="keyword">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointers to directly-mapped structs and arrays in base DEX */</span></span><br><span class="line">    <span class="keyword">const</span> DexHeader*    pHeader;</span><br><span class="line">    <span class="keyword">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="keyword">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="keyword">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="keyword">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="keyword">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">    <span class="keyword">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">    <span class="keyword">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These are mapped out of the "auxillary" section, and may not be</span></span><br><span class="line"><span class="comment">     * included in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>*         pRegisterMapPool;       <span class="comment">// RegisterMapClassPool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* points to start of DEX file data */</span></span><br><span class="line">    <span class="keyword">const</span> u1*           baseAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* track memory overhead for auxillary structures */</span></span><br><span class="line">    <span class="keyword">int</span>                 overhead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* additional app-specific data structures associated with the DEX */</span></span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>图形化表示:  </p>
<p><img src="/img/dex/dex_struct.jpg" alt=""></p>
<p>在介绍之前，先铺垫一些符号的定义  </p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8位的有符号数</td>
</tr>
<tr>
<td>ubyte</td>
<td>8位的无符号数</td>
</tr>
<tr>
<td>short</td>
<td>16位的有符号数</td>
</tr>
<tr>
<td>ushort</td>
<td>16位的无符号数</td>
</tr>
<tr>
<td>int</td>
<td>32位的有符号数</td>
</tr>
<tr>
<td>uint</td>
<td>32位的无符号数</td>
</tr>
<tr>
<td>long</td>
<td>64位的有符号数</td>
</tr>
<tr>
<td>ulong</td>
<td>64位的无符号数</td>
</tr>
<tr>
<td>sleb128</td>
<td>有符号的 LEB128格式,可变长度</td>
</tr>
<tr>
<td>uleb128</td>
<td>无符号的 LEB128格式，可变长度</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>无符号的 LEB128格式 +1，可变长的</td>
</tr>
</tbody>
</table>
<p>什么是 <code>LEB128</code> 呢？ LEB128是小端数据格式，它用于任意有符号或无符号整数量的可变长度编码。在 dex 文件中，<code>LEB128</code>仅用于编码32位数量。<br>每个LEB128编码值由一到五个字节组成，它们一起代表一个32位值。除了最后一个字节之外，每个字节都有一个符号位，位于每个字节的最高位，其余的7位是 有效数据。这样的一个字节或多个字节就形成了 <code>LEB128数值</code>。  </p>
<p>对于一个LEB128的有符号数据(<code>sleb128</code>)，最后一个字节的最高位被拓展成为这个LEB128数值的最终有符号信息，1表示负数，0表示正数。对于一个无符号的LEB128数值(<code>uleb128</code>)，最后一个字节的最高位，无论是1还是0，始终看做0，以此表示无符号。</p>
<p><code>uleb128p1</code> 是 <code>uleb128</code>的变种，规则是：uleb128p1 + 1 = uleb128</p>
<p>既然是 小端数据格式，以 2字节举例: </p>
<p><img src="/img/dex/leb128_art.jpg" alt=""></p>
<p>回到Dex 文件的布局</p>
<h4 id="DexHeader"><a href="#DexHeader" class="headerlink" title="DexHeader"></a>DexHeader</h4><p>在 <code>DexFile</code> 中 第一块数据结构就是 <code>DexHeader</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped "header_item" struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* includes version number */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section */</span></span><br><span class="line">    u4  endianTag;</span><br><span class="line">    u4  linkSize;</span><br><span class="line">    u4  linkOff;</span><br><span class="line">    u4  mapOff;</span><br><span class="line">    u4  stringIdsSize;</span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>magic[8]</code></strong> 存储8字节的magic，用来标记 这是一个 Dex 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubyte[8] DEX_FILE_MAGIC = &#123; 0x64 0x65 0x78 0x0a 0x30 0x33 0x38 0x00 &#125;</span><br><span class="line">                        = &quot;dex\n038\0&quot;</span><br></pre></td></tr></table></figure>
<p><code>038</code>就是 Dex的版本号  添加的 <code>\n</code>和<code>\0</code>就是来区分 字符串 dex 和版本号的,<code>038</code>版本是Android 8.0 开始支持的。</p>
<p><strong>checksum</strong> 用于校验Dex 文件的，参与计算的数据是除了 magic 和checksum 两个字段外的所有数据  </p>
<p><strong>signature</strong> 除了 magic和 checksum 和 signature 外的部分的 SHA-1签名，用于唯一标识文件</p>
<p><strong>file_size</strong> 整个文件的大小</p>
<p><strong>header_size</strong> Header 部分的大小</p>
<p><strong>endian_tag</strong> 字节序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint ENDIAN_CONSTANT = 0x12345678; //大端序</span><br><span class="line">uint REVERSE_ENDIAN_CONSTANT = 0x78563412;//小端序，如果是小断序，需要反转成正常的大端序</span><br></pre></td></tr></table></figure>
<p><strong>link_size</strong> 链接部分的大小，如果此文件未静态链接，则为0</p>
<p><strong>link_off</strong> 从文件的开头到链接部分的偏移量，或者如果link_size == 0则为0.偏移量（如果非零）应该是link_data部分的偏移量</p>
<p><strong>map_off</strong> 从文件的开头到 map item 的偏移量。偏移量必须为非零，应该是数据部分的偏移量，data 应采用下面“map_list”指定的格式。</p>
<p><strong>string_ids_size</strong> 字符串标识符列表中的字符串数<br><strong>string_ids_off</strong> 从文件的开头到字符串标识符列表的偏移量，如果string_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是string_ids部分的开头。</p>
<p><strong>type_ids_size</strong> 类型标识符列表中的元素数，最多为65535</p>
<p><strong>type_ids_off</strong> 从文件开头到类型标识符列表的偏移量，如果type_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是type_ids部分的开头。</p>
<p><strong>proto_ids_size</strong> 原型标识符列表中的元素数，最多为65535<br><strong>proto_ids_off</strong> 从文件的开头到原型标识符列表的偏移量，如果proto_ids_size == 0，则为0（无可否认是一个奇怪的边缘情况）。偏移量（如果非零）应该是proto_ids部分的开头。</p>
<p>类似的 <code>field_ids_size</code>,<code>method_ids_size</code>,<code>class_defs_size</code>,<code>data_size</code> 分别对应着Dex File 不同的区域的大小。相应的<code>*_off</code>对应着从文件头到各自区域的偏移量</p>
<p>_提一句，Android上常见的 方法数 超过 65535 问题就是因为 <code>method_ids_size</code>使用无符号int来标识，而无符号int的最大范围是 65535。所以就限制了一个 Dex 文件中最多只能索引 65535 个方法。所以 后期的版本，Google 采用了分割 Dex 的方式解决这个问题。_</p>
<h4 id="DexStringId-Section"><a href="#DexStringId-Section" class="headerlink" title="DexStringId Section"></a>DexStringId Section</h4><p>该区域存储 字符串标识符列表。存储着使用的所有字符串的标识符，如代码引用的常量对象。</p>
<h4 id="DexTypeId-Section"><a href="#DexTypeId-Section" class="headerlink" title="DexTypeId Section"></a>DexTypeId Section</h4><p>存储着 类型标识符列表。<br>这些是此文件引用的所有类型（类，数组或基本类型）的标识符，无论是否在文件中定义。<br>此列表必须按字符串索引排序，并且不得包含任何重复的条目</p>
<h4 id="DexFieldId-Section"><a href="#DexFieldId-Section" class="headerlink" title="DexFieldId Section"></a>DexFieldId Section</h4><p>存储字段标识符列表。<br>这些是此文件引用的所有字段的标识符，无论是否在文件中定义。<br>必须对此列表进行排序，其中定义类型（通过type_id索引）是主要顺序，字段名称（通过string_id索引）是中间顺序，类型（通过type_id索引）是次要顺序。<br>该列表不得包含任何重复的条目。</p>
<h4 id="DexMethodId-Section"><a href="#DexMethodId-Section" class="headerlink" title="DexMethodId Section"></a>DexMethodId Section</h4><p>方法标识符列表。<br>这些是此文件引用的所有方法的标识符，无论是否在文件中定义。<br>必须对此列表进行排序，其中定义类型（通过type_id索引）是主要顺序，方法名称（通过string_id索引）是中间顺序，方法原型（通过proto_id索引）是次要顺序。<br>该列表不得包含任何重复的条目。</p>
<h4 id="DexProtoId-Section"><a href="#DexProtoId-Section" class="headerlink" title="DexProtoId Section"></a>DexProtoId Section</h4><p>方法原型标识符列表。<br>这些是此文件引用的所有原型的标识符。<br>此列表必须按返回类型（按type_id索引）主要顺序排序，然后按参数列表排序（词典排序，按type_id索引排序的各个参数）。<br>该列表不得包含任何重复的条目。</p>
<p>proto 的意思是 method prototype 代表 java 语言里的一个 method 的原型 。proto_ids 里的元素为 proto_id_item，结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Direct-mapped &quot;proto_id_item&quot;.</span><br><span class="line"> */</span><br><span class="line">struct DexProtoId &#123;</span><br><span class="line">    u4  shortyIdx;          /* index into stringIds for shorty descriptor */</span><br><span class="line">    u4  returnTypeIdx;      /* index into typeIds list for return type */</span><br><span class="line">    u4  parametersOff;      /* file offset to type_list for parameter types */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>包含 方法名称，方法的返回值，参数。</p>
<h4 id="DexClassDef-Section"><a href="#DexClassDef-Section" class="headerlink" title="DexClassDef Section"></a>DexClassDef Section</h4><p>类定义列表。<br>必须对类进行排序，使得给定类的超类和实现的接口在引用类之前出现在列表中。</p>
<h4 id="Data-Section"><a href="#Data-Section" class="headerlink" title="Data Section"></a>Data Section</h4><p>数据区，包含上面列出的表的所有支持数据。</p>
<h4 id="Link-Data"><a href="#Link-Data" class="headerlink" title="Link Data"></a>Link Data</h4><p>静态链接文件中使用的数据。</p>
<h3 id="分析-Hi-dex"><a href="#分析-Hi-dex" class="headerlink" title="分析 Hi.dex"></a>分析 Hi.dex</h3><p>使用编辑器打开 <code>Hi.dex</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">6465 780a 3033 3500 *(magic) 4e7d 2ba4 *(checksum) b499 ca35</span><br><span class="line">ee34 b9d6 94de 96e8 a865 9759 ae06 7dee *(signature)</span><br><span class="line">bc03 0000 *(file_size) 7000 0000 *(header_size) 7856 3412 *(endian_tag) 0000 0000 *(link_size)</span><br><span class="line">0000 0000 *(link_off) 1003 0000 *(map_off) 1300 0000 *(string_ids_size) 7000 0000 *(string_ids_off)</span><br><span class="line">0700 0000 *(type_ids_size) bc00 0000 *(type_ids_off) 0300 0000 d800 0000</span><br><span class="line">0200 0000 fc00 0000 0600 0000 0c01 0000</span><br><span class="line">0100 0000 3c01 0000 6002 0000 5c01 0000</span><br><span class="line">0602 0000 1002 0000 1802 0000 2202 0000</span><br><span class="line">2b02 0000 3102 0000 4802 0000 5c02 0000</span><br><span class="line">7002 0000 8402 0000 8702 0000 8b02 0000</span><br><span class="line">a002 0000 a602 0000 b002 0000 b502 0000</span><br><span class="line">bc02 0000 c502 0000 cb02 0000 0400 0000</span><br><span class="line">0500 0000 0600 0000 0700 0000 0800 0000</span><br><span class="line">0900 0000 0b00 0000 0900 0000 0500 0000</span><br><span class="line">0000 0000 0a00 0000 0500 0000 f801 0000</span><br><span class="line">0a00 0000 0500 0000 0002 0000 0000 0300</span><br><span class="line">1100 0000 0400 0100 0e00 0000 0000 0000</span><br><span class="line">0000 0000 0000 0000 0100 0000 0000 0200</span><br><span class="line">0c00 0000 0000 0100 0f00 0000 0100 0100</span><br><span class="line">1000 0000 0200 0000 0100 0000 0000 0000</span><br><span class="line">0100 0000 0200 0000 0000 0000 0300 0000</span><br><span class="line">0000 0000 f202 0000 0000 0000 0100 0000</span><br><span class="line">0000 0000 ec01 0000 0500 0000 1a00 0200</span><br><span class="line">6900 0000 0e00 0000 0100 0100 0100 0000</span><br><span class="line">e001 0000 0400 0000 7010 0500 0000 0e00</span><br><span class="line">0200 0100 0200 0000 e401 0000 1200 0000</span><br><span class="line">6201 0100 1a00 0d00 6e20 0400 0100 2201</span><br><span class="line">0000 7010 0100 0100 6200 0000 6e20 0300</span><br><span class="line">0100 0e00 0300 0200 0200 0000 f001 0000</span><br><span class="line">0600 0000 6200 0100 6e20 0400 2000 0e00</span><br><span class="line">0100 0e00 0601 000e 785a 5a00 0300 0e00</span><br><span class="line">0c01 000e 5a00 0000 0100 0000 0300 0000</span><br><span class="line">0100 0000 0600 083c 636c 696e 6974 3e00</span><br><span class="line">063c 696e 6974 3e00 0848 6920 436c 6173</span><br><span class="line">7300 0748 692e 6a61 7661 0004 4c48 693b</span><br><span class="line">0015 4c6a 6176 612f 696f 2f50 7269 6e74</span><br><span class="line">5374 7265 616d 3b00 124c 6a61 7661 2f6c</span><br><span class="line">616e 672f 4f62 6a65 6374 3b00 124c 6a61</span><br><span class="line">7661 2f6c 616e 672f 5374 7269 6e67 3b00</span><br><span class="line">124c 6a61 7661 2f6c 616e 672f 5379 7374</span><br><span class="line">656d 3b00 0156 0002 564c 0013 5b4c 6a61</span><br><span class="line">7661 2f6c 616e 672f 5374 7269 6e67 3b00</span><br><span class="line">046d 6169 6e00 086d 6169 6e20 2d2d 3e00</span><br><span class="line">036f 7574 0005 7072 696e 7400 0770 7269</span><br><span class="line">6e74 6c6e 0004 7465 7874 0025 7e7e 4438</span><br><span class="line">7b22 6d69 6e2d 6170 6922 3a31 2c22 7665</span><br><span class="line">7273 696f 6e22 3a22 7631 2e30 2e33 3522</span><br><span class="line">7d00 0100 0301 000a 0088 8004 dc02 0181</span><br><span class="line">8004 f802 0109 9003 0301 c403 0000 0000</span><br><span class="line">0e00 0000 0000 0000 0100 0000 0000 0000</span><br><span class="line">0100 0000 1300 0000 7000 0000 0200 0000</span><br><span class="line">0700 0000 bc00 0000 0300 0000 0300 0000</span><br><span class="line">d800 0000 0400 0000 0200 0000 fc00 0000</span><br><span class="line">0500 0000 0600 0000 0c01 0000 0600 0000</span><br><span class="line">0100 0000 3c01 0000 0120 0000 0400 0000</span><br><span class="line">5c01 0000 0320 0000 0400 0000 e001 0000</span><br><span class="line">0110 0000 0200 0000 f801 0000 0220 0000</span><br><span class="line">1300 0000 0602 0000 0020 0000 0100 0000</span><br><span class="line">f202 0000 0310 0000 0100 0000 0c03 0000</span><br><span class="line">0010 0000 0100 0000 1003 0000</span><br></pre></td></tr></table></figure>
<p><code>6465 780a 3033 3500</code> 对应的 <code>0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00</code><br> = <code>&quot;dex\n035\0&quot;</code> 说明 我使用 的 <code>dx</code> 编译器 使用的Dex 版本是 <code>035</code></p>
<p>在 以上数据中，我使用*(name)做了部分分割，只有明确 Dex 文件的结构，读懂 Dex 文件也不是那么的难了，有了 这个基础之后，以后就可以明白 各种热修复框架的实现思路了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Android-Dalvik-And-ART/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Android-Dalvik-And-ART/" itemprop="url">Android-Dalvik And ART</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T12:01:56+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-Dalvik-And-ART/" class="leancloud_visitors" data-flag-title="Android-Dalvik And ART">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>熟悉 <code>Android</code>的都知道， <code>Android</code> 应用程序的开发 通常采用 <code>Java</code>语言进行开发，不同于 <code>Java</code> 的是，<code>Java</code> 环境编译后的生成的是 <code>.class</code>文件，而 Android 的 可执行文件是 <code>.dex</code>文件(Dalvik Executable)，它是 <code>.class</code>文件经过 工具<code>dx</code>处理后的文件格式，可被 <code>Dalvik</code>虚拟机直接运行(目前 都转为使用更先进的<code>d8</code>编译器来处理 <code>.class</code>文件来生成 <code>.dex</code>文件)。执行这些 <code>dex</code>文件的 运行环境就是 <code>Dalvik</code>，后来Google 推出了更先进的 <code>ART</code>。  </p>
<p><code>ART</code>和<code>Dalvik</code>是服务于Android应用和Android系统服务的.<code>Dalvik</code>在Android项目一开始的时候就被引入，而<code>ART</code>在<code>Android4.4</code>的时候被引入，并对开发人员可见，在<code>Android 5.0</code>的时候，<code>ART</code>虚拟机这个是成为默认的虚拟机。 <code>ART</code>的推出就是为了替代<code>Dalvik</code>虚拟机来获得更好的性能的。<code>ART</code>和 <code>Dalvik</code>都支持运行 <code>dex</code>字节码，因此为 <code>Dalvik</code>开发的应用程序，也可以直接被 <code>ART</code>虚拟机运行(当然有一些Dalvik的技术特性不被支持了，比如 显示的调用<code>System.gc()</code>，具体可参考<a href="https://developer.android.com/guide/practices/verifying-apps-art.html" target="_blank" rel="noopener">Verifying App Behavior on the Android Runtime (ART)</a>)。  </p>
<h3 id="ART-的新特性"><a href="#ART-的新特性" class="headerlink" title="ART 的新特性"></a>ART 的新特性</h3><h4 id="AOT编译-–-Ahead-of-time-AOT-compilation"><a href="#AOT编译-–-Ahead-of-time-AOT-compilation" class="headerlink" title="AOT编译 – Ahead-of-time (AOT) compilation"></a>AOT编译 – Ahead-of-time (AOT) compilation</h4><p>ART引入了提前（AOT）编译，可以提高应用程序性能。 ART还具有比Dalvik更严格的安装时间验证。<br>在安装App时，ART使用设备上的<code>dex2oat</code>工具编译应用程序。此实用程序接受<code>DEX</code>文件作为输入，并为目标设备生成已编译的应用程序可执行文件<code>.oat</code>,由于<code>Dalvik</code>虚拟机使用了这么多年，整个系统中可能很多地方硬编码使用了<code>.odex</code>文件，为了无缝的替换<code>Dalvik</code>虚拟机，通过<code>dex2oat</code>生成的 <code>.oat</code>文件在有些地方可能会命名为<code>.odex</code>。<br>例如/data/app/{pkg}/oat/{cpuType}下,在我的手机上是<code>/data/app/{pkg}-xxx/oat/arm64/</code>，目录下的文件是以 <code>.odex</code>结尾。<br>虽然名字是<code>.odex</code>,但是不同于通过<code>dex2opt</code>生成的<code>.odex</code>文件。<code>dex2oat</code>输出的<code>.odex</code>文件其实就是 <code>.oat</code>文件，是 elf文件格式，里面包含着本地机器码。<br><mark>由于是针对 当前设备的，所以生成的可执行文件不能被别的机器使用。</mark>  </p>
<p>随便说一下，<code>/data/app/{pkg}/oat/{cpuType}</code> 目录下 可能还包含<code>.art</code>和 <code>.vdex</code>文件。 <code>.vdex</code> 这是<code>Android8</code>引入的，它存储是 app 安装时执行 <code>dex2oat</code>经过验证后的dex文件，以后可以使用<code>.vdex</code>文件，避免再次验证Dex文件的合法性。<br><code>.art</code>文件 主要存储apk 启动的热点函数相关地址的记录，方便寻址相关；该文件不会在程序安装时就生成，而是运行了一段时间后，收集到了足够过的JIT热点方法信息，会再次进行<code>dex2oat</code>，将热点方法编译成<code>native code</code>,这就是<code>.art</code>文件的作用。</p>
<h4 id="改进GC机制"><a href="#改进GC机制" class="headerlink" title="改进GC机制"></a>改进GC机制</h4><p>参考之前的<a href="/JVM-垃圾收集器/">JVM-垃圾收集器</a>一文，JVM 的垃圾收集器往 并发收集方向前进，同样，为了尽量减少GC对 用户进程的卡顿影响，改进的GC机制也采用了并行收集和并发处理。  </p>
<p><code>ART</code>虚拟机 默认使用的垃圾收集器是 <code>CMS</code>收集器，我们知道 <code>CMS</code>收集器采用的是<code>标记-清除</code>算法，没有<code>内存-整理</code>，所以 当 Android 应用程序进入后台后 缓存状态时，虚拟机会执行 <code>堆内存压缩整理</code>，减少内存碎片的产生。</p>
<p>除了垃圾收集器的升级换代，针对内存的分配方面，<code>ART</code>也引入了全新的 基于 位图的内存分配器，称为RosAlloc（插槽分配器)。这个新的分配器具有分片锁定，针对小内存分配，增加了 <code>Thread Local</code>的 buffers，提高 小内存的分配性能。</p>
<h4 id="开发和调试改进"><a href="#开发和调试改进" class="headerlink" title="开发和调试改进"></a>开发和调试改进</h4><p>ART提供了许多功能来改进应用程序开发和调试。比如:  </p>
<ul>
<li>支持 <code>采样分析</code></li>
<li>增加更多的 虚拟机调试功能，比如可以通过<code>ART</code>知道 一个给定的 Class 有多少个实例，已经对象的引用状态</li>
<li>改进了异常和崩溃报告中的诊断细节</li>
</ul>
<h4 id="ART的JIT编译器"><a href="#ART的JIT编译器" class="headerlink" title="ART的JIT编译器"></a>ART的JIT编译器</h4><p>我们知道 在 <code>Android 2.2</code> 的时候，为了提升 <code>Dalvik</code>的性能，引入了<code>JIT（Just-In-Time ）</code>技术。这是一种在 运行时 编译 频繁使用的 Class，成为 <code>native code</code> 机器码，提升 效率，免得在程序运行期间 每次都重新翻译成 机器码的尴尬。但是这个性能提升也不是绝对的，比如 Class 中的大部分代码执行较少，那么JIT编译花费的时间不一定少于执行dex的时间。所以 <code>JIT</code>不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码。而且，<code>JIT</code>将 dex 字节码编译成native code 是发生在程序运行期间的，而且生成的 <code>native code</code> 也不是一劳永逸的，下次运行，还是需要重新执行<code>JIT</code> 过程。</p>
<p>使用过早期Nexus5 搭配 Android5.0的人可能知道，安装一个App，简直是龟速，其实就是安装的时候如果全量编译成机器码很耗时，为了照顾安装效率，就取消了全量编译，这时候再引入 <code>JIT</code> 就很有意义了，针对比较热门的代码，使用<code>JIT</code>编译成 native code，<br>所以在 <code>ART</code> 中实现了 <code>JIT</code>编译器是很有必要的，在Android7.0中重新引入了<code>ART</code>下的<code>JIT</code>技术。  </p>
<p>以下是 <code>JIT</code>在 <code>ART</code>系统中的结构示意图</p>
<p><img src="/img/art/art-jit-arch.png" alt=""></p>
<p>可以看出，如果 <code>ART</code> 虚拟机 面对 非 <code>oat</code>可执行文件时，还是有必要的。</p>
<p>以下是 <code>JIT</code>的工作流程示意图:  </p>
<p><img src="/img/art/jit-workflow.png" alt=""></p>
<p><code>JIT</code>是运行时编译，是动态编译，<code>AOT</code>可以被认为是静态编译，二者配合和互补，在效率做平衡。</p>
<p>当然也可以不适用 <code>JIT</code>，可以通过以下命令禁止: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell stop</span><br><span class="line">adb shell setprop dalvik.vm.usejit false</span><br><span class="line">adb shell start</span><br></pre></td></tr></table></figure>
<p><a href="https://source.android.com/devices/tech/dalvik" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/Linux-SharedMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Linux-SharedMemory/" itemprop="url">Linux-共享内存(Shared Memory)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T12:00:49+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Linux-SharedMemory/" class="leancloud_visitors" data-flag-title="Linux-共享内存(Shared Memory)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前<a href="/Linux-信号机制/">Linux-信号机制</a>这篇文章介绍了 <code>Linux</code>系统中的一个进程间通信方式- <code>信号机制</code>。这次我们来介绍以下 另一种进程间通信方式-<code>共享内存</code>。  </p>
<p>共享内存的原理是: <strong>两个进程可以直接访问同一块内存区域。</strong> 由于两个进程交互的数据在同一块内存区域，避免了 copy 操作，所以速度是比较快的。  </p>
<p>我们知道之所以划分进程这一概念，就是为了各个进程运行在各自独立的内存空间之中，避免了进程的非法访问和数据破坏。所以，共享内存肯定不是简单的，两个进程直接分配同一块内存区域。 它所占用的空间既不属于进程A 也不属于进程B，而是属于系统内核。 需要使用到 内存映射，将块所属内核的内存区域映射到两个进程之中。  如下图:  </p>
<p><img src="/img/share_mem/share_mem.jpg" alt=""></p>
<p>实现共享内存比较简单，只需要厦门几步:  </p>
<ol>
<li>创建内存共享区</li>
<li>映射内存共享区到进程空间</li>
<li>访问共享内存</li>
<li>对共享内存进行读写操作，也即进行进程间通信</li>
<li>撤销共享内存的进程映射</li>
<li>删除共享内存区域，回收内存</li>
</ol>
<h4 id="1-创建内存共享区"><a href="#1-创建内存共享区" class="headerlink" title="1. 创建内存共享区"></a>1. 创建内存共享区</h4><p>进程A 通过操作系统提供的API 从内存中申请一块共享区域，在Linux 环境中，可以通过 <code>shmget</code>函数来创建或获取共享内存区域  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * key：SHM 标识</span><br><span class="line"> * size：SHM 大小</span><br><span class="line"> * shmflg：创建或得到的属性，例如 IPC_CREAT</span><br><span class="line"> * return：成功返回 shmid，失败返回 -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br></pre></td></tr></table></figure>
<p><strong>参数 <code>key</code></strong>: 创建的内存区域会和给定的 <code>key</code>进行绑定，另外一个进程B 可以通过传入相同的 <code>key</code>来获取进程A创建的共享内存区域。在 以下两种key 的取值情况下，会创建一个新的内存共享区，否则就是返回已有的内存共享区  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. key 值为 `IPC_PRIVATE`  </span><br><span class="line">2. key不为 `IPC_PRIVATE` ，但是 另一个参数`shmflg `指定了 `IPC_CREATE`标记</span><br></pre></td></tr></table></figure>
<p><strong>参数 <code>size</code></strong>: 指定申请的共享内存的大小，以字节为单位， <mark>注意:</mark>Linux系统下，分配的内存大小都是页的整数倍</p>
<p><strong>参数shmflg</strong>: 有以下几种取值   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IPC_CREATE：申请新建区域</span><br><span class="line">IPC_EXCL：和 IPC_CREATE共同使用，如果指定的区域已经存在，则返回错误。</span><br><span class="line">mode_flags：同 open 函数的 mode 参数，用来指定 文件的权限</span><br><span class="line">SHM_HUGETLB：使用&quot;huge pages&quot;机制来申请</span><br><span class="line">SHM_NORESERVE: 此区域不保留 swap 空间</span><br></pre></td></tr></table></figure>
<p>对于 进程A要创建一个共享内存区域，参数 shmflg 设置为 <code>IPC_CREATE</code>即可。</p>
<p><strong>返回值</strong>: 是内存共享区域的id值，用于唯一标识该区域。进程需要映射该区域时 需要使用 此 id 值。</p>
<h4 id="2-映射内存共享区到进程空间"><a href="#2-映射内存共享区到进程空间" class="headerlink" title="2.映射内存共享区到进程空间"></a>2.映射内存共享区到进程空间</h4><p>将进程A申请创建的共享内存映射到进程A的进程空间中，需要使用 <code>shmat</code>函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmid：SHM ID</span><br><span class="line"> * shmaddr：SHM 内存地址</span><br><span class="line"> * shmflg：SHM 权限</span><br><span class="line"> * return：成功返回 SHM 的地址，失败返回 (void *) -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br></pre></td></tr></table></figure>
<p><strong>参数 shmid</strong>: 就是 共享内存区域的id值，由<code>shmget</code>函数返回的。  </p>
<p><strong>参数 shmaddr</strong>: 将内存共享区域映射到指定的地址，可以为 <code>0</code>,此时系统将自动分配地址  </p>
<p><strong>参数shmflg</strong>: 和 <code>shmget</code>方法中的 参数<code>shmflg</code> 一样。</p>
<p><strong>返回值</strong>: 如果成功执行后，返回该内存区域的其实地址</p>
<h4 id="3-访问共享内存"><a href="#3-访问共享内存" class="headerlink" title="3.访问共享内存"></a>3.访问共享内存</h4><p>经过前面 2 步，进程A 成功创建了 共享内存，并将共享内存区域映射到了 进程A的进程空间之中，那么现在 就该进程B 访问 共享内存区域了。进程B 就是利用 进程A 创建 内存空间时绑定的<code>key</code>,通过函数<code>shmget</code>来 获取 内存共享区域，然后再使用 <code>shmat</code>函数将共享内存区域也映射到进程B的空间中。</p>
<h4 id="4-进行进程间通信"><a href="#4-进行进程间通信" class="headerlink" title="4.进行进程间通信"></a>4.进行进程间通信</h4><p>这一步就是进程A或进程B 往 共享内存区域写入自己的信息，实现数据交换或者说实现通信。<mark>注意</mark>: 如果涉及到进程A和进程B 写入数据同步问题，还需要 进程A和进程B协议处理，因为 共享内存没有同步机制。往共享内存区域 copy 数据可以使用 函数<code>memcpy</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * dest: 指向用于存储复制内容的目标地址</span><br><span class="line"> * src: 指向要复制的数据源</span><br><span class="line"> * count: 要被复制的字节数</span><br><span class="line"> * return：返回一个指向目标存储区 dest 的指针</span><br><span class="line"> */</span><br><span class="line">void *memcpy(void *dest, const void *src, size_t count)</span><br></pre></td></tr></table></figure>
<h4 id="5-撤销内存映射"><a href="#5-撤销内存映射" class="headerlink" title="5.撤销内存映射"></a>5.撤销内存映射</h4><p>Linux中 使用 函数<code>shmdt</code>来解除当前进程与共享内存区域的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmaddr：已经映射的 SHM 地址</span><br><span class="line"> * return：成功返回 0，失败返回 -1，并设置 erron</span><br><span class="line"> */</span><br><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure>
<h4 id="6-删除共享内存区"><a href="#6-删除共享内存区" class="headerlink" title="6.删除共享内存区"></a>6.删除共享内存区</h4><p>经过第5步骤取消了 进程A和进程B 对共享内存的映射关系，如果不需要再次使用的话就可以释放掉 这块共享内存区域了，在Linux 系统中，可以通过 函数<code>shmctl</code>来实现。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * shmid：SHM ID</span><br><span class="line"> * cmd: 控制命令</span><br><span class="line"> * buf: 共享内存区域需要更新的数据，或需要写出的数据</span><br><span class="line"> * return：成功返回 0，否则 失败</span><br><span class="line"> */</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br></pre></td></tr></table></figure>
<p><strong>参数 cmd</strong>: 释放掉共享内存区域时需要执行的命令，可选值如下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPC_STAT：状态查询，结果存入 参数buf</span><br><span class="line">IPC_SET: 在权限允许的情况下，将共享内存状态更新为 buf 中的数据</span><br><span class="line">IPC_RMID: 删除共享内存段</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>write_shm.c</code> </p>
<p>进程 A 创建 共享内存区域 并写入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 1. 创建 SHM</span><br><span class="line">	int shm_id = shmget(13, 2048, IPC_CREAT | 0666);</span><br><span class="line">	if (shm_id != -1) &#123;</span><br><span class="line">		// 2. 映射 SHM</span><br><span class="line">		void* shm = shmat(shm_id, NULL, 0);</span><br><span class="line">		if (shm != (void*)-1) &#123;</span><br><span class="line">			// 3. 写 SHM</span><br><span class="line">			char str[] = &quot;share memory&quot;;</span><br><span class="line">			memcpy(shm, str, strlen(str) + 1);</span><br><span class="line">			// 4. 关闭 SHM</span><br><span class="line">			shmdt(shm);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			perror(&quot;shmat:&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		perror(&quot;shmget:&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程B 从共享内存中读取数据  </p>
<p><code>read_shm.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 1. 获取 SHM</span><br><span class="line">	int shm_id = shmget(13, 2048, IPC_CREAT | 0666);</span><br><span class="line"></span><br><span class="line">	if (shm_id != -1) &#123;</span><br><span class="line">		// 2. 映射 SHM</span><br><span class="line">		void* shm = shmat(shm_id, NULL, 0);</span><br><span class="line">		if (shm != (void*)-1) &#123;</span><br><span class="line">			// 3. 读取 SHM</span><br><span class="line">			char str[50] = &#123; 0 &#125;;</span><br><span class="line">			memcpy(str, shm, strlen(&quot;share memory&quot;));</span><br><span class="line">			printf(&quot;shm = %s\n&quot;, (char *)shm);</span><br><span class="line">			// 4. 关闭 SHM</span><br><span class="line">			shmdt(shm);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			perror(&quot;shmat:&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		perror(&quot;shmget:&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (0 == shmctl(shm_id, IPC_RMID))</span><br><span class="line">		printf(&quot;delete shm success.\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>gcc</code> 命令将 文件 <code>write_shm.c</code> 和 <code>read_shm.c</code> 编译成可执行文件  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc write_shm.c -o write_shm</span><br><span class="line">gcc read_shm.c -o read_shm</span><br></pre></td></tr></table></figure>
<p>先运行 <code>write_shm</code> 在运行 <code>read_shm</code>, <code>read_shm</code>执行后会输出 结果<br><code>share memory</code>。 这就意味着 我们成功的通过 共享内存实现了进程A 和进程B的通信。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aicodeing.github.io/JVM-垃圾收集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AICoding Team">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AICoding Technical Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/JVM-垃圾收集器/" itemprop="url">JVM-垃圾收集器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T14:29:52+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/JVM-垃圾收集器/" class="leancloud_visitors" data-flag-title="JVM-垃圾收集器">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面一篇文章 <a href="/JVM-垃圾回收算法/">JVM-垃圾回收算法</a> 介绍了内存回收的 各种实现方案，这篇文章继续介绍一下 基于这些算法的 <strong>垃圾收集器的具体实现</strong> 。  </p>
<p>Java 虚拟机规范对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商，不同的版本的虚拟机所提供的垃圾收集器可能都不相同。目前商用的垃圾收集器大致如下图所示：  </p>
<p><img src="/img/jvm_gc/gc-garbage_collector.jpg" alt=""></p>
<p>在不同的 内存划分区域，使用不同的垃圾回收器 搭配使用。  </p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><code>Serial 收集器</code>是 <code>新生代</code> 内存区域，使用 <code>复制算法</code> 的最基本，最悠久的收集器。这个收集器是 <code>单线程</code>的收集器，它只会使用一个收集线程去完成垃圾收集工作，它在进行垃圾收集时，必须暂停其他工作线程，直到 GC 过程完成后，才重新恢复 工作线程。因此，这个收集器工作时，就会 产生 <code>Stop The World</code>的情况。  </p>
<p>对应的 <code>老年代</code>内存区域的回收算法 是 <code>Serial Old</code>收集器。它们工作的过程如下:  </p>
<p><img src="/img/jvm_gc/gc_serial.jpg" alt=""></p>
<p>可以看出，不管是 新生代还是老年代，用户线程和 GC 线程不能同时工作。  </p>
<p>竟然 <code>Serial收集器</code>是这么的低效率，那为什么还存在呢？ 其实在 特殊的场景下，该收集器还是有自己的优点的，比如在 Client 模式下，<code>Serial收集器</code>就是默认的新生代收集器。它简单，高效，对于单个Cpu和小内存的环境来说，<code>Serial收集器</code>由于没有线程交互的开销，可以获得最高的单线程收集效率。所以<code>Serial收集器</code>对于运行Client模式下的虚拟机来说是一个很好的选择。  </p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><code>ParNew收集器</code>其实就是 <code>Serial收集器</code>的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为和 <code>Serial收集器</code>完全一致。它的工作过程如下:  </p>
<p><img src="/img/jvm_gc/gc_parnew.jpg" alt=""></p>
<p>由于 <code>ParNew收集器</code>和 <code>Serial收集器</code>几乎一样，所以 他们两个都可以和 老年代的<code>Serial Old收集器</code>搭配使用。 </p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p><code>Parallel Scavenge收集器</code>也是作用在 <code>新生代</code>的 一款收集器,它也是使用 <code>复制算法</code>，并且和 <code>ParNew收集器</code>一样，也是并行的多线程收集器。看上去和 <code>ParNew收集器</code>没有什么不一样？  </p>
<p><code>Parallel Scavenge收集器</code>的特定是它与 其他收集器的关注点不同，<code>ParNew收集器</code>以及后面会讲的 老年代的 <code>CMS收集器</code>关注点都是 <strong>尽可能的缩短垃圾收集时用户线程的停顿时间</strong> 。而 <code>Parallel Scavenge收集器</code>的目标是达到一个可控制的<code>吞吐量</code>. 也就是CPU运行用户代码的时间与CPU总耗时的比值，即：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 用户代码运行时间 / (用户代码运行时间+GC时间)</span><br></pre></td></tr></table></figure>
<p>停顿时间越短就越适合需要与用户交互的程序，可以提升用户的体验，例如 Client模式下。  </p>
<p>而高吞吐量则可以高效的利用CPU时间尽快完成运算任务，主要适合在 后台运算，而不需要太多的交互。一般 Server 程序需要一个比较高的吞吐量。  </p>
<p><code>Parallel Scavenge收集器</code>有两个重要的可配置参数 <code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>。   </p>
<p><code>-XX:MaxGCPauseMillis</code>参数控制最大垃圾收集停顿时间，允许的值是一个大于0的毫秒数，收集器尽可能的保证内存回收花费的时间不超过设定的值。但 它和参数<code>-XX:GCTimeRatio</code>是互斥的。如果  <code>-XX:MaxGCPauseMillis</code>调小些，为了尽快完成回收，会把新生代区域的大小设定的比较小，就会导致 新生代会频繁的触发 GC。   </p>
<p><code>-XX:GCTimeRatio</code>参数设置 吞吐量的大小，它的值应当在 0 到100 之间，取整数。<br>如果要提高吞吐量，势必会 减少 GC的次数，那么 新生代的大小会大一些，并且每次GC的时间比较长。  </p>
<p>由于<code>Parallel Scavenge收集器</code>比较重视 提高吞吐量，所以 它也常被称为<code>吞吐量优先收集器</code>。一般不建议直接设置 参数 <code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>。建议使用<code>-XX:+UseAdaptiveSizePolicy</code>该参数的开启，虚拟机会根据当前系统的运行情况动态调整 GC 停顿时间和 吞吐量，也成为<code>GC自适应调整策略</code>。</p>
<p><strong>上面介绍的是 新生代的 垃圾收集器, 后面会谈下 老年代的收集器</strong></p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>刚才谈到 新生代的 收集器 <code>Serial收集器</code>的时候 提到了与之搭配的 老年代 收集器是 <code>Serial Old收集器</code>。它不同于<code>Serial收集器</code>使用的 <code>复制算法</code>，<code>Serial Old收集器</code>采用的是 <code>标记-整理</code>算法，它也是推荐在 Client模式下使用的。<br>在 Server 模式下，它也有特定的作用，比如和 新生代的 <code>Parallel Scavenge收集器</code>搭配使用；还有就是 当做 后面会讲到的 <code>CMS收集器</code>的 候补收集器。</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>同 <code>Serial Old收集器</code>是 <code>Serial收集器</code>在 老年代的 对应方案，<code>Parallel Old 收集器</code>是前面提到的<code>Parallel Scavenge收集器</code>在老年代的收集器版本。</p>
<p>它使用的也是多线程工作 和 <code>标记-整理</code>算法。<br>它与 <code>Parallel Scavenge收集器</code> 搭配使用的过程如下:  </p>
<p><img src="/img/jvm_gc/gc_parallel.jpg" alt=""></p>
<p>从图中可以看出，不管是老年代还是新生代，都使用并行GC线程进行收集。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>前面提到的 不管是 <code>Serial</code>收集器 还是 <code>Parall</code>收集器，他们虽然有的可以有多个GC线程进行回收，但都无法与用户线程<code>并发执行</code>。也就是说 GC过程中 <code>Stop The World</code> 还是一个上帝准则。  </p>
<p><code>CMS收集器</code>全称(Concurrent Mark Sweep) 作用于<code>老年代</code>内存区域，是第一款真正意义上的<code>并发收集器</code>，它实现了让用户线程与垃圾收集线程同时(几乎)工作。但 它只能和新生代中的 <code>Serial收集器</code>或 <code>ParNew收集器</code>搭配使用。</p>
<p><code>CMS收集器</code>是一种以获取最短回收停顿时间为目标的收集器。从名字中可以看出，它采用的是 <code>标记-清除</code>算法，它的整个GC 过程分为 4个步骤:</p>
<ul>
<li>初始化标记 (CMS initial mark)</li>
<li>并发标记(CMS concurrent mark)</li>
<li>重新标记(CMS remark)</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
<p>其中第一步和第三步，任然需要<code>Stop The Work</code> 无法做到 完全并发。</p>
<p><mark>初始化标记</mark>: 仅仅是标记一下 GC Roots 能直接关联到的对象，所以速度很快。  </p>
<p><mark>并发标记</mark>: 就是进行 <code>GC Roots Tracing</code> 的过程(简历引用链),这部分是很耗时的。不过采用了并发操作，可以和用户线程同时运行，所以能大大提升 用户的卡顿情况。   </p>
<p><mark>重新标记</mark>:重新标记 是因为在 并发标记的过程中，由于用户线程在并发执行，可能导致一些对象的引用关系发生了变化，这个阶段就是 修正 标记结果。由于需要避免对象引用的再次改变，所以，这个步骤是 需要 <code>Stop The World</code>的，这里的耗时比 <code>初始化标记</code>耗时长，但远比 <code>并发标记</code>时间短。  </p>
<p><mark>并发清除</mark>:这个阶段就是 清除 无用的对象。由于这个过程是并发执行的，用户在这个过程中可能也改变了引用关系，所以 <code>CMS收集器</code>无法处理类似的 浮动垃圾,需要等到下一次GC 过程再处理。  </p>
<p><code>CMS收集器</code>的过程如下:  </p>
<p><img src="/img/jvm_gc/gc_cms.jpg" alt=""></p>
<p><strong>缺点:</strong>   </p>
<p><strong>内存使用率降低</strong><br>由于GC过程中，用户线程在并发执行，那就还需要预留足够的内存空间给用户线程使用，因此 <code>CMS 收集器</code>不能像其他收集器一样，等到 老年代 几乎被填满后再进行收集，需要预留一部分空间提供给并发的用户线程,所以 内存的利用率会稍微低一些，在 <code>JDK1.5</code>中默认设置下，CMS收集器 当 老年代使用了 68% 的空间就会触发GC。在后来的 <code>JDK1.6</code>中，CMS的<br>这个阈值提升到了 92%。要是在 CMS 运行期间，预留的内存无法满足程序使用了，就会触发 <code>Concurrent Mode Failure</code>的失败，这时候启用前面提到的备用方案<code>Serial Old收集器</code>。这样的话，停顿的时间就更长了，所以还是降低一下内存的使用了，来提升性能，也就是 <strong>空间换时间啦</strong> 。</p>
<p><strong>CPU吞吐量降低</strong><br>在 CMS收集器 并发阶段，虽然不会导致用户线程停顿，但是会因为 占用了一部分线程从而导致用户线程变慢，总吞吐量会有所降低。CMS模式的回收线程数是 <code>(CPU数+3)/4</code>,也就是说 当 CPU个数在4个以上时，并发回收线程会占用不少于 25%的CPU资源，并且随着CPU数量的增加而降低，如果 CPU的数量不足 4个，CMS 对用户程序的影响可能变得更大。</p>
<p>还有一个缺点: <code>CMS收集器</code> 采用的是 <code>标记-清除</code>算法，而非<code>标记-整理</code>算法，所以垃圾收集结束后，会产生内存碎片。碎片过多的时候，将会影响大对象的内存分配，这时候不得不进行一次 <code>Full GC</code>。为了解决这个问题 CMS 提供了一个参数 <code>-XX:+UseCMSCompactAtFullCollection</code>开关参数，这个开关参数模式是开的。用于当 CMS 收集器 顶不住要进行 <code>FullGC</code>时 开启内存碎片的整理过程。而内存整理的过程是无法并发的，所以也会导致卡顿时间变长。</p>
<h2 id="最前沿的垃圾收集器"><a href="#最前沿的垃圾收集器" class="headerlink" title="最前沿的垃圾收集器"></a>最前沿的垃圾收集器</h2><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1(Garbage-First)收集器</code>是当今收集器技术发展的最前沿成果之一，在 <code>JDK1.7</code> 才正式商用。 这是一款面向 <code>Server 端</code>的垃圾收集器。它的目的是希望未来能替换 <code>CMS收集器</code>。<br>G1 收集器的特点:</p>
<ul>
<li>并行与并发:<code>G1</code> 能充分利用多CPU，多核心来缩短 <code>Stop The World</code>的时间</li>
<li>分代收集:<code>G1</code> 可以不需要其他收集器配合就能独立管理整个 GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活一段时间的老对象。</li>
<li>空间整合: 与 <code>CMS</code> 采用的<code>标记-清除</code>算法不同，G1 整体来看采用的是 <code>标记-整理</code>算法，从局部(两个<code>Region</code>之间)上来看是基于 <code>复制</code>算法来实现的，G1 运行期间，不会产生内存碎片。</li>
<li>可预测的停顿:与其他收集器相比，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为<code>M</code>毫秒的时间片段内，消耗在垃圾收集上的时间不得超过<code>N</code>毫秒。</li>
</ul>
<p>在 G1 之前的其他收集器进行回收的范围是整个新生代或老年代，而 G1 不是这样。它将堆内存划分为多个 大小相等的<code>独立Region</code>,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一些<code>Region</code>，这些<code>Region</code>可以不连续。</p>
<p>G1 收集器能建立可预测的停顿时间模型，是因为它可以进行有计划地避免整个Java堆中进行全区域的垃圾收集。 <strong>G1跟踪每个<code>Region</code> 回收所获得空间的大小，已经回收所需要的时间</strong> 。它在后台维护一个 <strong>优先级列表</strong> ，每次根据允许的收集时间， <strong>优先回收价值最大的Region。</strong> 这样有优先级的回收，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。  </p>
<p>G1 收集器的过程步骤大致划分为:  </p>
<ul>
<li>初始化标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p><mark>初始化标记</mark>:与<code>CMS收集器</code>一样 需要 <code>Stop The World</code>，仅仅标记一下与 <code>GC Roots对象</code>直接关联的对象。 不同之处是，需要修改 <code>TAMS(Next Top at Mark Start)</code>的值，让下一阶段用户程序并发运行时，能在正确可用的 <code>Region</code>中创建新对象。</p>
<p><mark>并发标记</mark>:也是 从 <code>GC Roots</code> 开始对堆中的对象进行 引用链分析，该阶段可以与用户线程并发执行。</p>
<p><mark>最终标记</mark>:是为了修正 用户程序 并发期间，导致的对象引用变化，虚拟机将这段时间对象的变化记录在线程 <code>Remembered Set Logs</code> 里面，最终标记需要把 <code>Remembered Set Logs</code>的数据合并到 <code>Remembered Set</code>中。这个阶段也需要 <code>Stop The World</code>。<br>什么是 <code>Remembered Set</code>呢？有什么用？<br>我们前面说了，G1 把 堆内存分成大小相等的 <code>Region</code>，按照 <code>Region</code>的回收优先级来觉得回收哪些 Region，避免了全堆回收，但有可能出现 优先级 高的 Region 中对象引用了 其他Region中的对象。虚拟机都是通过<code>Remembered Set</code>来避免全堆扫描的。G1中 每一个Region都有一个与之对应的 <code>Remembered Set</code>，虚拟机发现程序对引用类型的数据进行操作时，会产生一个 <code>Write Barrier</code> 暂时中断写操作，检测 <code>Reference</code>引用的对象是否处于不同的Region之中，如果是，便通过<code>CardTable</code> 把相关引用信息记录到被引用对象所属的Region的<code>Remembered Set</code> 之中。当进行内存回收时，在GC 根节点的枚举范围中加入 <code>Remembered Set</code> 即可保证不对全堆扫描，也不会遗漏。  </p>
<p><mark>筛选回收</mark>:这个阶段首先会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>
<p>一下是 G1的运行示意图:  </p>
<p><img src="/img/jvm_gc/gc_g1.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前 收集器种类比较多，适用场景也各不相同，所以，我们可以根据不同的使用场景来选择。虽然最新的 G1 收集器 比较先进，但目前使用范围并不是最广泛的，它的JDK9中才正式成为默认的垃圾收集器。</p>
<p><em>参考:</em> <a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">深入理解Java虚拟机</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/img/avatar.png"
                alt="AICoding Team" />
            
              <p class="site-author-name" itemprop="name">AICoding Team</p>
              <p class="site-description motion-element" itemprop="description">As a blog, included a variety of technical articles</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/aicodeing" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:gerenvip@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-email"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                优秀Blog
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dailycast.github.io" title="DailycastTeam" target="_blank">DailycastTeam</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://codedrinker.github.io" title="麻酱" target="_blank">麻酱</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AiCoding Team</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  
      <script type="text/javascript">
        var commenthub_id = '5436710';
        var commenthub_website = 'https://aicodeing.github.io';
        var commenthub_identifier = 'index.html';
        var commenthub_url = '';
        var commenthub_title = '';
        var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = 'https://commenthub.herokuapp.com/js/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      </script>
  


  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("hsAB629SmVs7VBe0HfQbUPaR-gzGzoHsz", "rcCMRRhPb29Rps6qC6WAW7Wg");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
