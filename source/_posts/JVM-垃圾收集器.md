---
title: JVM-垃圾收集器
date: 2019-02-18 14:29:52
tags:
	- JVM
	- GC
category: JVM
comments: ture
---

前面一篇文章 [JVM-垃圾回收算法](/JVM-垃圾回收算法/) 介绍了内存回收的 各种实现方案，这篇文章继续介绍一下 基于这些算法的 __垃圾收集器的具体实现__ 。  

Java 虚拟机规范对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商，不同的版本的虚拟机所提供的垃圾收集器可能都不相同。目前商用的垃圾收集器大致如下图所示：  

![](/img/jvm_gc/gc-garbage_collector.jpg)

在不同的 内存划分区域，使用不同的垃圾回收器 搭配使用。  

### Serial收集器

`Serial 收集器`是 `新生代` 内存区域，使用 `复制算法` 的最基本，最悠久的收集器。这个收集器是 `单线程`的收集器，它只会使用一个收集线程去完成垃圾收集工作，它在进行垃圾收集时，必须暂停其他工作线程，直到 GC 过程完成后，才重新恢复 工作线程。因此，这个收集器工作时，就会 产生 `Stop The World`的情况。  

对应的 `老年代`内存区域的回收算法 是 `Serial Old`收集器。它们工作的过程如下:  

![](/img/jvm_gc/gc_serial.jpg)

可以看出，不管是 新生代还是老年代，用户线程和 GC 线程不能同时工作。  

竟然 `Serial收集器`是这么的低效率，那为什么还存在呢？ 其实在 特殊的场景下，该收集器还是有自己的优点的，比如在 Client 模式下，`Serial收集器`就是默认的新生代收集器。它简单，高效，对于单个Cpu和小内存的环境来说，`Serial收集器`由于没有线程交互的开销，可以获得最高的单线程收集效率。所以`Serial收集器`对于运行Client模式下的虚拟机来说是一个很好的选择。  

### ParNew收集器

`ParNew收集器`其实就是 `Serial收集器`的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为和 `Serial收集器`完全一致。它的工作过程如下:  

![](/img/jvm_gc/gc_parnew.jpg)

由于 `ParNew收集器`和 `Serial收集器`几乎一样，所以 他们两个都可以和 老年代的`Serial Old收集器`搭配使用。 

### Parallel Scavenge 收集器

`Parallel Scavenge收集器`也是作用在 `新生代`的 一款收集器,它也是使用 `复制算法`，并且和 `ParNew收集器`一样，也是并行的多线程收集器。看上去和 `ParNew收集器`没有什么不一样？  

`Parallel Scavenge收集器`的特定是它与 其他收集器的关注点不同，`ParNew收集器`以及后面会讲的 老年代的 `CMS收集器`关注点都是 __尽可能的缩短垃圾收集时用户线程的停顿时间__ 。而 `Parallel Scavenge收集器`的目标是达到一个可控制的`吞吐量`. 也就是CPU运行用户代码的时间与CPU总耗时的比值，即：  

```
吞吐量 = 用户代码运行时间 / (用户代码运行时间+GC时间)
```

停顿时间越短就越适合需要与用户交互的程序，可以提升用户的体验，例如 Client模式下。  

而高吞吐量则可以高效的利用CPU时间尽快完成运算任务，主要适合在 后台运算，而不需要太多的交互。一般 Server 程序需要一个比较高的吞吐量。  

`Parallel Scavenge收集器`有两个重要的可配置参数 `-XX:MaxGCPauseMillis`和`-XX:GCTimeRatio`。   

`-XX:MaxGCPauseMillis`参数控制最大垃圾收集停顿时间，允许的值是一个大于0的毫秒数，收集器尽可能的保证内存回收花费的时间不超过设定的值。但 它和参数`-XX:GCTimeRatio`是互斥的。如果  `-XX:MaxGCPauseMillis`调小些，为了尽快完成回收，会把新生代区域的大小设定的比较小，就会导致 新生代会频繁的触发 GC。   
 
`-XX:GCTimeRatio`参数设置 吞吐量的大小，它的值应当在 0 到100 之间，取整数。  
如果要提高吞吐量，势必会 减少 GC的次数，那么 新生代的大小会大一些，并且每次GC的时间比较长。  

由于`Parallel Scavenge收集器`比较重视 提高吞吐量，所以 它也常被称为`吞吐量优先收集器`。一般不建议直接设置 参数 `-XX:MaxGCPauseMillis`和`-XX:GCTimeRatio`。建议使用`-XX:+UseAdaptiveSizePolicy`该参数的开启，虚拟机会根据当前系统的运行情况动态调整 GC 停顿时间和 吞吐量，也成为`GC自适应调整策略`。


__上面介绍的是 新生代的 垃圾收集器, 后面会谈下 老年代的收集器__

### Serial Old 收集器

刚才谈到 新生代的 收集器 `Serial收集器`的时候 提到了与之搭配的 老年代 收集器是 `Serial Old收集器`。它不同于`Serial收集器`使用的 `复制算法`，`Serial Old收集器`采用的是 `标记-整理`算法，它也是推荐在 Client模式下使用的。   
在 Server 模式下，它也有特定的作用，比如和 新生代的 `Parallel Scavenge收集器`搭配使用；还有就是 当做 后面会讲到的 `CMS收集器`的 候补收集器。

### Parallel Old 收集器

同 `Serial Old收集器`是 `Serial收集器`在 老年代的 对应方案，`Parallel Old 收集器`是前面提到的`Parallel Scavenge收集器`在老年代的收集器版本。

它使用的也是多线程工作 和 `标记-整理`算法。  
它与 `Parallel Scavenge收集器` 搭配使用的过程如下:  

![](/img/jvm_gc/gc_parallel.jpg)

从图中可以看出，不管是老年代还是新生代，都使用并行GC线程进行收集。

### CMS收集器

前面提到的 不管是 `Serial`收集器 还是 `Parall`收集器，他们虽然有的可以有多个GC线程进行回收，但都无法与用户线程`并发执行`。也就是说 GC过程中 `Stop The World` 还是一个上帝准则。  

`CMS收集器`全称(Concurrent Mark Sweep) 作用于`老年代`内存区域，是第一款真正意义上的`并发收集器`，它实现了让用户线程与垃圾收集线程同时(几乎)工作。但 它只能和新生代中的 `Serial收集器`或 `ParNew收集器`搭配使用。

`CMS收集器`是一种以获取最短回收停顿时间为目标的收集器。从名字中可以看出，它采用的是 `标记-清除`算法，它的整个GC 过程分为 4个步骤:

- 初始化标记 (CMS initial mark)
- 并发标记(CMS concurrent mark)
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

其中第一步和第三步，任然需要`Stop The Work` 无法做到 完全并发。

<mark>初始化标记</mark>: 仅仅是标记一下 GC Roots 能直接关联到的对象，所以速度很快。  

<mark>并发标记</mark>: 就是进行 `GC Roots Tracing` 的过程(简历引用链),这部分是很耗时的。不过采用了并发操作，可以和用户线程同时运行，所以能大大提升 用户的卡顿情况。   

<mark>重新标记</mark>:重新标记 是因为在 并发标记的过程中，由于用户线程在并发执行，可能导致一些对象的引用关系发生了变化，这个阶段就是 修正 标记结果。由于需要避免对象引用的再次改变，所以，这个步骤是 需要 `Stop The World`的，这里的耗时比 `初始化标记`耗时长，但远比 `并发标记`时间短。  

<mark>并发清除</mark>:这个阶段就是 清除 无用的对象。由于这个过程是并发执行的，用户在这个过程中可能也改变了引用关系，所以 `CMS收集器`无法处理类似的 浮动垃圾,需要等到下一次GC 过程再处理。  

`CMS收集器`的过程如下:  

![](/img/jvm_gc/gc_cms.jpg)

__缺点:__   

__内存使用率降低__  
由于GC过程中，用户线程在并发执行，那就还需要预留足够的内存空间给用户线程使用，因此 `CMS 收集器`不能像其他收集器一样，等到 老年代 几乎被填满后再进行收集，需要预留一部分空间提供给并发的用户线程,所以 内存的利用率会稍微低一些，在 `JDK1.5`中默认设置下，CMS收集器 当 老年代使用了 68% 的空间就会触发GC。在后来的 `JDK1.6`中，CMS的
这个阈值提升到了 92%。要是在 CMS 运行期间，预留的内存无法满足程序使用了，就会触发 `Concurrent Mode Failure`的失败，这时候启用前面提到的备用方案`Serial Old收集器`。这样的话，停顿的时间就更长了，所以还是降低一下内存的使用了，来提升性能，也就是 __空间换时间啦__ 。

__CPU吞吐量降低__  
在 CMS收集器 并发阶段，虽然不会导致用户线程停顿，但是会因为 占用了一部分线程从而导致用户线程变慢，总吞吐量会有所降低。CMS模式的回收线程数是 `(CPU数+3)/4`,也就是说 当 CPU个数在4个以上时，并发回收线程会占用不少于 25%的CPU资源，并且随着CPU数量的增加而降低，如果 CPU的数量不足 4个，CMS 对用户程序的影响可能变得更大。

还有一个缺点: `CMS收集器` 采用的是 `标记-清除`算法，而非`标记-整理`算法，所以垃圾收集结束后，会产生内存碎片。碎片过多的时候，将会影响大对象的内存分配，这时候不得不进行一次 `Full GC`。为了解决这个问题 CMS 提供了一个参数 `-XX:+UseCMSCompactAtFullCollection`开关参数，这个开关参数模式是开的。用于当 CMS 收集器 顶不住要进行 `FullGC`时 开启内存碎片的整理过程。而内存整理的过程是无法并发的，所以也会导致卡顿时间变长。


## 最前沿的垃圾收集器

### G1收集器

`G1(Garbage-First)收集器`是当今收集器技术发展的最前沿成果之一，在 `JDK1.7` 才正式商用。 这是一款面向 `Server 端`的垃圾收集器。它的目的是希望未来能替换 `CMS收集器`。  
G1 收集器的特点:

- 并行与并发:`G1` 能充分利用多CPU，多核心来缩短 `Stop The World`的时间
- 分代收集:`G1` 可以不需要其他收集器配合就能独立管理整个 GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活一段时间的老对象。
- 空间整合: 与 `CMS` 采用的`标记-清除`算法不同，G1 整体来看采用的是 `标记-整理`算法，从局部(两个`Region`之间)上来看是基于 `复制`算法来实现的，G1 运行期间，不会产生内存碎片。
- 可预测的停顿:与其他收集器相比，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为`M`毫秒的时间片段内，消耗在垃圾收集上的时间不得超过`N`毫秒。

在 G1 之前的其他收集器进行回收的范围是整个新生代或老年代，而 G1 不是这样。它将堆内存划分为多个 大小相等的`独立Region`,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一些`Region`，这些`Region`可以不连续。


G1 收集器能建立可预测的停顿时间模型，是因为它可以进行有计划地避免整个Java堆中进行全区域的垃圾收集。 __G1跟踪每个`Region` 回收所获得空间的大小，已经回收所需要的时间__ 。它在后台维护一个 __优先级列表__ ，每次根据允许的收集时间， __优先回收价值最大的Region。__ 这样有优先级的回收，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。  

G1 收集器的过程步骤大致划分为:  

- 初始化标记
- 并发标记
- 最终标记
- 筛选回收

<mark>初始化标记</mark>:与`CMS收集器`一样 需要 `Stop The World`，仅仅标记一下与 `GC Roots对象`直接关联的对象。 不同之处是，需要修改 `TAMS(Next Top at Mark Start)`的值，让下一阶段用户程序并发运行时，能在正确可用的 `Region`中创建新对象。
 
<mark>并发标记</mark>:也是 从 `GC Roots` 开始对堆中的对象进行 引用链分析，该阶段可以与用户线程并发执行。

<mark>最终标记</mark>:是为了修正 用户程序 并发期间，导致的对象引用变化，虚拟机将这段时间对象的变化记录在线程 `Remembered Set Logs` 里面，最终标记需要把 `Remembered Set Logs`的数据合并到 `Remembered Set`中。这个阶段也需要 `Stop The World`。  
什么是 `Remembered Set`呢？有什么用？  
我们前面说了，G1 把 堆内存分成大小相等的 `Region`，按照 `Region`的回收优先级来觉得回收哪些 Region，避免了全堆回收，但有可能出现 优先级 高的 Region 中对象引用了 其他Region中的对象。虚拟机都是通过`Remembered Set`来避免全堆扫描的。G1中 每一个Region都有一个与之对应的 `Remembered Set`，虚拟机发现程序对引用类型的数据进行操作时，会产生一个 `Write Barrier` 暂时中断写操作，检测 `Reference`引用的对象是否处于不同的Region之中，如果是，便通过`CardTable` 把相关引用信息记录到被引用对象所属的Region的`Remembered Set` 之中。当进行内存回收时，在GC 根节点的枚举范围中加入 `Remembered Set` 即可保证不对全堆扫描，也不会遗漏。  

<mark>筛选回收</mark>:这个阶段首先会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

一下是 G1的运行示意图:  

![](/img/jvm_gc/gc_g1.jpg)


## 总结

目前 收集器种类比较多，适用场景也各不相同，所以，我们可以根据不同的使用场景来选择。虽然最新的 G1 收集器 比较先进，但目前使用范围并不是最广泛的，它的JDK9中才正式成为默认的垃圾收集器。

_参考:_ [深入理解Java虚拟机](https://item.jd.com/11252778.html)




