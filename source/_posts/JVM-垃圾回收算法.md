---
title: JVM-垃圾回收算法
date: 2019-02-14 18:18:05
tags:
	- JVM
	- GC
category: JVM
comments: ture
---

垃圾回收是Java 语言的一个重要特征，在Java 内存堆里面存放着JAVA 世界中几乎所有的对象实例，垃圾收集器在对堆内存就行回收前，第一件事就是要确定对象该不该被回收。那么垃圾收集器是如何判断一个对象是否需要被回收呢？  

## 垃圾回收-标记算法

如何判断是否需要被回收呢？ 有几类算法:  

#### 1.引用计数器算法  

大家最常提到的就是 给每个对象添加一个引用计数器，当增加一个引用的时候，计数器 `+1`，如果引用失效后，计数器 `-1`。  
这种 计数方法看似效率很高，但是也有很严重的问题，所以目前 没有一个JVM 使用该算法。  
主要原因就是 它 无法解决__`循环引用`__的问题。

#### 2.可达性分析算法  

可达性分析就是通过定义一系列的 `GC Roots`对象，作为起始点，从这些起始节点往下搜索，而搜索经过的路径成为`引用链(Reference Chain)`，当一个对象到 `GC Roots` 没有任何引用链相连接，也就是从 `GC Roots 对象` 到这个对象不可达时，就说明该对象是不可用的，需要被回收。  

那么，哪些对象可以作为 `GC Roots 对象`呢？ 一般包括以下几种:

-  虚拟机栈中引用的对象
-  方法区中静态变量引用的对象
-  方法区中常量引用的对象
-  Native方法栈中JNI引用的对象

为什么是这些对象呢？通过同性不难发现，他们的存活时间比较久，或者局部存活较久。

不管是通过 计数器算法还是可达性分析算法，来决定一个对象是否存活，都是针对的 `强引用类型`, `Java` 中还有其他引用类型，某些引用对象，即使通过垃圾回收算法判断不需要回收，但也有可能被GC回收。  

## 引用类型
Java 虚拟机中引用类型分为 `强引用(Strong Reference)`,`软引用 Soft Reference`,`弱引用 Weak Reference`,`虚引用Phantom Reference`。这四种引用类型的强度依次递减。  

- **强引用**，就是写代码中常用的 如 `Object o = new Object()`类型的引用。只有引用还存在，垃圾回收器就永远不会回收被引用的对象。  
- **软引用**，是用来描述对象有用，但是也并不是必须的，在适当的时候，可以被回收，一般是在内存不足的时候，会触发 软引用对象的回收，但有__一个特殊的就是 `Android 平台` 上，只要`GC` 经过，就会回收掉 软引用，并不会等到内存不足时__。
- **弱引用**，也是来描述它是非必需的，但是它比 软引用更弱，被 弱引用引用的对象只能生存到下次GC发生之前。无论当前内存是否充足，都会回收掉弱引用关联的对象，它的声明周期是，从弱引用对象的建立，到 GC 来临之间的时间。
- **虚引用**，它也成为 **幽灵引用** ，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间带来影响，我们也无法通过虚引用来获取一个对象实例。那么虚引用的使用场景是什么呢？唯一的使用场景就是在对象被回收时，收到一个系统通知。

__问题：如果一个对象在 回收算法中被认为是需要回收的对象,是否意味着一定会被回收呢？__

如果一个对象在经过`可达性分析算法`分析后发现没有与 `GC Roots`相连的引用链，那么它将会被标记并且进行一次 <mark>筛选</mark>。怎么筛选呢？ 其实就是筛选 有没有必要执行对象的 `finalize()`方法。当对象没有覆盖 `finalize()`方法，或者 `finalize()`方法已经在之前被 虚拟机调用过了，那这个对象就认为没有必要执行 `finalize()`,那这个对象就可以直接被回收了。  
如果 通过 `筛选`，需要执行`finalize()`方法呢？其实虚拟机会把该对象放置在一个 队列之中，并且稍后会由虚拟机创建一个优先级很低的 `Finalizer 线程`去`执行`它。但这个执行并不会承诺一定等待`finalize()`方法执行完毕，因为如果在 `finalize()`方法中做耗时的操作将会影响队列中其他 对象的`finalize()`方法执行。但是我们可以在 `finalize()`方法中把 对象本身与 `GC Roots `关联上，这样在 GC 做第二次标记的时候，该对象将从 `即将回收`的集合中移除。如果没有做上述的关联操作，这个对象就会被立刻回收掉了。

我们知道，`JVM` 将内存 划分为几大块:`堆内存`,`方法区`,`虚拟机栈`,`Native栈`,`程序计数器`，那么刚才所说的 回收都只是在 `堆内存`这个分区上;  

__问题: 方法区也被称为永久代，这个区域是否存在垃圾回收机制呢？__  

其实 Java 虚拟机规范中确实不要钱虚拟机在方法区进行回收，由于方法区的对象生命周期很长，而且 在 堆内存进行垃圾回收就能回收 大部分空间，那的确就没有必要在方法区进行垃圾回收了，但在 方法区 也是可以做垃圾回收的，一般回收的内容是: `废弃的常量`，和`无用的类`。  

**回收废弃的常量** 和回收 `Java 堆`中的对象差不多，比如回收 常量池中的字符串 `“abc”`，如果当前系统中没有任何` String `对象引用常量池中的 `"abc"` 常量，也没有其他地方应用了这个字面量，如果需要执行方法区的垃圾回收的话，就可以把 `“abc”` 常量从常量池中清理掉。因为在 编译期就知道 常量池中的常量有没有被引用，所以 判断 一个常量字符串有没有被应用，也很容易。  

**回收类呢？** 判断一个类 有用无用，分几个方面:

- 该类所有的实例都已经被回收，在Java的堆内存中不存在该类的任何实例
- 加载该类的`ClassLoader`已经被回收或不存在
- 该类对应的 `java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类。

只有满足 以上条件，就可以回收 方法区 中的类。

__刚谈了 `堆内存`和 `方法区 `中对象 <mark>是否需要回收的问题，那么下面我们谈一下 如何回收的。</mark>

## 垃圾回收-回收算法

### 1.标记-清除算法

这是最基础的收集算法，它分为 `标记`和`清除`两部分。在前面已经谈过 `标记`算法了。  
这种最基础的 `标记-清除`算法，通过 标记 来确定，对象是否需要被回收，通过清除 来将对象占用的内存回收，那么显而易见，这个最基础的算法有两个很严重的问题:  

- 效率低，标记过程是一个比较耗时的过程，同样沿着标记链，清除对应的内存区域，效率也不高
- 空间碎片化，直接清除对象占用的内存，会导致 产生大量的不连续的内存碎片，当碎片化很严重的时候，如果需要再分配大块内存，由于没有大块的内存可分配了，还是会触发 `GC`，但是同样无法解决问题.  

![](/img/jvm_gc/gc-mem_mark_sweep.jpg "")  

### 2.复制算法

该算法是 `标记-清除`算法的改进版, 它将内存按容量划分成大小相等的两块内存，每次只使用其中的一块。当一块内存用完了，就将还存活的对象复制到 另一块内存上，然后把之前的一块内存全部清理掉。这样每次都是对整个半区的内存进行回收，避免了内存的碎片化，而且新内存的申请，可以顺序分配，该实现方式简单，高效。  
但很容易也发现，这种 算法的缺点是 ：`太浪费`,只能使用内存的`50%`。

### 3.改进版的复制算法

据调查，目前的商业虚拟机都是采用 这种算法来回收`新生代内存区`,IBM 研究表明，新生代中的对象 98% 都是 `'朝生夕死'`，所以并不需要按 `1:1`来划分内存空间。而是将内存分为一块较大的`Eden空间`和两块较小的`Survivor空间`，当回收时，将 `Eden` 和 `Survivor` 区(我们称为 __Survivor From__)中还存活的对象一次性复制到另一块 Survivor 空间(称为 **Survivor To**)上，最后清理掉 `Eden 和 Survivor From 空间`。 `HotSpot` 虚拟机默认 `Eden 和 Survivor` 的大小比例是 `8:1` 。改进后的这种复制算法，空间利用率达到了90%，只有10%的内存会被浪费掉。  

很明显，只要采用 类似的`复制算法`,就会有一个问题，如果 内存中存活的对象 很多呢，而不是 IBM 研究的 98%的可以释放呢？由于 `Survivor To` 的空间较小，不足以 存放 所有存活的对象。这样就无法达到回收效果。这就需要依赖其他内存，比如 存放在 老年代。(老年代的任务就是存放 __大内存对象__,*_一般是超过 Survivor 的大小_*, __对象的年龄达到了老年标准的对象,也即声明周期长的对象__, __Survivor To 存储不下的对象__)  

__一直在介绍的是 新生代 的回收算法，那么老年代肯定也需要做垃圾回收的。__

简单说明一下，老年代 由于对象声明周期比较长，比较问题，所以 触发GC的次数不会很频繁，老年代的 GC我们成为 `MajorGC`，新生代的GC 我们称为 `MinorGC`。在进行`MajorGC` 前 一般都会进行一次`MinorGC`，使得新生代的对象晋升到老年代，在 老年代空间不够的时候，才触发MajorGC。  

前面提到 目前的商业 虚拟机 新生代的 `MinorGC` 采用的都是 复制算法，而 老年代的 `MajorGC` 采用的是 容易产生 内存碎片的`标记-清除`算法。`MajorGC`的耗时比较长，因为为了解决 碎片化内存问题，每次 `标记-清除`后，都会进行`合并整理`内存。

如果老年代 也装不下了，就会抛出 `OOM` 异常了。

### 4.标记-整理算法

在刚才介绍 老年代 `MajorGC`时 提到了，`MajorGC` 采用的的 `标记-清除` + `内存的合并整理`。这其实就是 `标记-整理`算法。  
标记-整理 算法就是在 标记-清除后，让所有存活的内存对象都向一端移动，然后直接清理掉端边界 以外的内存，标记-整理算法 如图:  

![](/img/jvm_gc/gc-mem-arrange.jpg "") 

## 综上

通过前面的分析，我们发现没有一种算法是完美无缺的，我们只需要利用各种算法的优缺点，分情况使用，最大化各种算法的优点。  
所以目前的商业虚拟机的垃圾回收算法 综合来说就是 __`分代收集算法`__。这种算法不是新的收集算法思路，而是综合各种算法的优点，根据对象存活周期的不同，将内存划分成几块，不同的块 使用不同的回收算法。

目前 商业虚拟机一般的做法是把内存划分为新生代，老年代:

- 新生代 使用 `标记-复制算法`
- 老年代使用 `标记-整理算法`

