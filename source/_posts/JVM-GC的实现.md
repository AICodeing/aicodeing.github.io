---
title: JVM-GC Roots的枚举
date: 2019-02-18 10:14:22
tags:
	- JVM
	- GC
category: JVM
comments: ture
---

在 前面一篇文章 [JVM-垃圾回收算法](/JVM-垃圾回收算法/) 介绍了，目前的垃圾回收算法 都是用 __`可达性分析算法`__ 来进行标记; 可达性分析从 `GC Roots` 对象节点查找引用链，而 `GC Roots` 对象 主要包含以下几种:  

- 虚拟机栈中引用的对象
- 方法区中静态变量引用的对象
- 方法区中常量引用的对象
- Native方法栈中JNI引用的对象

换句话说，	GC Roots	 对象主要是全局性的引用(如，常量或 `static` 属性)和 执行栈帧中的 `Local 变量`。然而，这些地方是很庞大的，如果 全部枚举出 这些符合条件的`GC Roots` 对象节点，需要耗费很多的时间，这样势必导致用户线程卡顿时间较长，影响体验。  

`GC Roots` 的枚举是GC 开始的第一步，在枚举 根节点的过程中，就会 `Stop the world` 。那么我们的目的就是尽量减少 用户线程的 `Stop` 时间

## 枚举GC Roots 对象

既然枚举 `GC Roots` 对象比较 耗时，那有没有更好的办法呢？  

其实虚拟机在执行的过程中是肯定知道 哪些地方存放着对象引用的。在 `HotSpot` 的实现中，使用一组称为 `OopMap`的数据结构来达到这个目的的。当类加载完成的时候，`HotSpot` 就能计算出 `GC Roots` 引用,然后保存到 `OopMap` 数据结构中。当GC在扫描的时候，就可以直接使用这些信息了。

__问题:__   
在 `OopMap`的协助下，虚拟机可以快速准确的完成 `GC Roots` 的枚举，能导致 引用关系变化的指令很多，如果为每一条指令都生成对应的`OopMap`，那就会需要大量的额外空间，这样GC的空间成本就会变得很高。  

## Safe Point

目前 的 HotSpot 其实只是在 `特定的指令位置`记录 引用信息，这个特定的位置就成为 __`安全点`__，即程序执行时并非在所有的地方都能停顿下来开始GC的，只有在 到达 `安全点` 时 才能暂停，等待 GC 线程的执行。安全点我们称为 `SafePoint`,它的选定 既不能太少 导致 GC 线程等待的时间太长，也不能太多，导致频繁的检测 GC 状态，增大运行时的负荷。  

`SafePoint` 的选定基本上是以程序 __是否具有让程序长时间执行的特征__ 为标准进行选定的。`长时间执行` 的最明显的特征就是 指令序列复用，例如 方法调用，循环跳转，异常跳转等。所以 具有这些功能 的指令才会产生 `SafePoint`。  

### SafePoint 的同步

当发生GC的时候，如何让 所有的线程跑到最近的 `SafePoint` 呢? 

- 抢先式中断
- 主动式中断

<mark>抢先式中断</mark> 不需要线程的执行代码主动去配合GC，在 GC 发生的时候，首先把所有线程全部中断，如果发现 线程中断的地方不在 `SafePoint`，就恢复该线程，让其跑到最近的 `SafePoint`上 再 停止。

抢先式 中断的一个问题就是 GC 过程需要干预用户线程的执行，目前虚拟机很少使用这种方式。

<mark>主动式中断</mark> 不直接对线程进行操作，仅仅是简单的设置一个标志，各线程执行时主动去轮询这个标志，发现中断标志为 true 时 就自动中断挂起。所以 __轮询标志的位置 和 安全点 是重合的__ 。由于创建对象需要分配内存时，由于容易引起GC，所以在 __分配内存的指令地方__ ，也会设置中断标志。


## Safe Region

在用户线程执行的时候，肯定会进入 `SafePoint`，但如果用户现在目前在 `sleep` 就没法在 GC的时候跑到 安全点。对于这种情况，引入了 `Safe Region` 来解决。  

`Safe Region` 是指 在一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方都可以开始GC，并且 GC 也是安全的。在线程执行到 `Safe Region` 的时候，首先标识自己已经进入了 `Safe Region`， 当这段时间`JVM` 要发起GC时，就不需要管 线程的状态了。只有在线程执行要离开 `Safe Region` 的时候，线程才需要检查自己是否已经完成了GC 过程。如果完成了，就继续执行，如果没有完成，就等待，直到收到 可以离开 `Safe Region`的信号为止。  

## 总结

`GC Roots` 对象节点的枚举是 GC 过程的第一步，为了尽快实现对 `GC Roots` 节点的枚举，引入了 `OopMap` 数据结构来存储 `GC Roots` 引用信息。为了减少不必要的 `Oop Map` 开销，使用了 `Safe Point `概念，为了解决 `SafePoint`的缺点，又引入了 `Safe Region` 概念。





