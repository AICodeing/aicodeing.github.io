---
title: Linux-mmap
date: 2019-03-03 23:09:56
tags:
	- Linux
	- IPC
category: Linux
comments: true
---
在文章[Linux-共享内存(Shared Memory)](/Linux-SharedMemory/)中介绍了通过
`shmget`和`shmat` 实现开辟一块共享内存，两个或多个进程共享这一块内存区域；今天介绍一个类似的概念，`mmap`函数。  

`mmap`函数 全名可以认为是`Memory Map`,可以将某个设备或者文件映射到应用进程的内存空间中，这样，访问这块内存就相当于对设备或文件进行读写，而不需要再通过 `read`和`write`了，所以由此可知，`mmap`也是支持进程间通信的，即通过映射同一块物理内存来共享内存。  虽然 `mmap`可以实现进程间通信，但是 `mmap`最出名的还是文件映射，即将一个物理硬盘上的文件映射到内存中，避免系统调用`read`和`write`。

为了便于理解 为何 避免了系统调用`read`和`write`就提升了效率，我们先看看普通的读写文件的原理。  

要读一个普通文件时，首先 进程调用`read`或是`write`后会陷入内核态，之后内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。  

Linux的内存映射函数`mmap`, 它把文件内容映射到一段内存上(准确说是虚拟内存上), 通过对这段内存的读取和修改, 实现对文件的读取和修改,`mmap()`系统调用使得进程之间可以通过映射一个普通的文件实现共享内存。

从前面的描述，不难发现 __`mmap`在最初并没有立马在物理内存上开辟空间，而 `共享内存shmget`和`shmat`正好相反，他们一开始就开辟了一份物理内存，而且这块是没有OOM的__

__区别:__  
`mmap`只是映射到虚地址空间上，并没有发生实际的copy，但访问这个文件的时候，内存发生了缺页中断，才会 copy 到 主存中，由于是虚地址空间，所以可操作的文件数据可以很多，大于物理主存，而且由于操作的可以是一个磁盘文件，所以读写速度肯定慢一些。    
`shmget`需要开劈一块实实在在的物理内存区域，受物理内存大小的影响，所以不能很大，不过由于操作的一直是内存，所以读写速度比较快。

假如我们想 进程A和进程B 都能读取一个硬盘上的文件，使用 `mmap`再合适不过了。  

```
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
```

这是 `mmap`函数的定义，先看看参数的意思:  

__addr：__ 指出文件或设备应该被映射到进程空间的哪个其实地址。这个参数如果为空,则由内核驱动自行决定被映射的地址。  

__length:__ 被映射到进程空间中内存块的大小  
__prot__ 指被映射内存的访问权限  

```
PROT_READ：内存页可读
PROT_WRITE：内存页可写
PROT_EXEC：内存页可执行
PROT_SEM：内存页可用于atomic操作
PROT_NONE：内存页不可访问
```

__flags__ 指定程序对内存块的修改带来的影响

__fd__ 被映射到进程空间的文件的描述符  
__offset__ 指定了从文件的哪一部分开始映射，一般为0

__返回值__ 成功时为0，否则错误码

